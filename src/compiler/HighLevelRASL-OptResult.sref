//FROM LibraryEx
$EXTERN Map, Fetch, Seq, MapReduce, Inc, Dec, Compare, Sort;

//FROM Library
$EXTERN Add, StrFromInt, WriteLine;

//FROM Escape
$EXTERN EscapeChar;

//FROM GST
$EXTERN GST;

/**
  <HighLevelRASL e.AST>
    == e.RASLAST

  e.RASLAST ::= t.RASLFunction*
  t.RASLFunction ::=
      (#Function s.ScopeClass (e.Name) t.HiRASLCommand*)
    | (s.SingularItem s.ScopeClass e.Name)
    | (#Ident e.Name)
    | (#Separator)
  s.SingularItem ::= #Enum | #Swap | #Stub | #Declaration
  t.HiRASLCommand ::=
      (#Cmd… e.Value)
    | (#CmdSentence t.HiRASLCommand*)
    | (#CmdOpenELoop #AlgLeft s.BracketNum s.VarNumber t.HiRASLCommand*)
*/
$ENTRY HighLevelRASL-OptResult {
  e.ProgramElements =
    <Map
      {
        (#Function s.ScopeClass (e.Name) e.Sentences) =
          <HighLevelRASL-Function
            s.ScopeClass (e.Name) e.Sentences
          >;

        (#Enum s.ScopeClass e.Name) =
          (#CmdEnum s.ScopeClass e.Name);

        (#Swap s.ScopeClass e.Name) =
          (#CmdSwap s.ScopeClass e.Name);

        (#Stub s.ScopeClass e.Name) =
          /* пусто */;

        (#Declaration s.ScopeClass e.Name) =
          (#CmdDeclaration s.ScopeClass e.Name);

        (#Ident e.Name) = (#CmdDefineIdent e.Name);

        (#Separator) = (#CmdSeparator);
      }
      e.ProgramElements
    >;
}

HighLevelRASL-Function {
  s.ScopeClass (e.Name) e.Sentences =
    <Fetch
      e.Sentences
      <Seq
        (Map
          {
            ((e.Pattern) (e.Result)) =
              (<HighLevelRASL-Sentence e.Name (e.Pattern) (e.Result)>);
          }
        )
        (MapReduce
          {
            s.MaxMemory ((#CmdIssueMem s.Memory) e.Sentence) =
              <Fetch
                <Compare s.MaxMemory s.Memory> {
                  '<' = s.Memory;
                  s.Other = s.MaxMemory;
                }
              >
              (#CmdSentence e.Sentence);
          }
          0
        )
        {
          s.MaxMemory e.Sentences^ (#CmdSentence e.LastSentence) =
            (#Function
              s.ScopeClass (e.Name)
              (#CmdIssueMem s.MaxMemory)
              e.Sentences
              <Fetch
                e.LastSentence
                {
                  e.Commands (#CmdOpenELoop e.OpenELoop) =
                    e.Commands (#CmdOpenELoop e.OpenELoop) (#CmdFail);

                  e.LastSentence^ = e.LastSentence;
                }
              >
            );

          0 /* нет предложений */ =
            (#CmdEnum s.ScopeClass e.Name);
        }
      >
    >;
}


HighLevelRASL-Sentence {
  e.Name (e.Pattern) (e.Result) =
    <Fetch
      <GenPattern ( #CallBrackets (e.Name) e.Pattern )>
      {
        (e.PatternVars) (e.MarkedPattern) s.ContextOffset (e.PatternCommands) =
          <Fetch
            <GST
              (
                (#LEFT-EDGE)
                e.MarkedPattern
                (#RIGHT-EDGE)
              )
              ((#LEFT-EDGE) <FlatResult e.Result> (#RIGHT-EDGE))
            >
            {
              (e.Trash) (e.MarkedResult) =
                <Fetch
                  <AddOffsets s.ContextOffset (e.PatternVars) e.MarkedResult>
                  {
                    s.ContextOffset^ e.MarkedResult^ =
                      <FoldOpenELoops
                        (#CmdIssueMem s.ContextOffset)
                        (#CmdInitB0-Lite)
                        e.PatternCommands
                        (#CmdResetAllocator)
                        <GenResult
                          (e.Trash) (e.MarkedResult)
                        >
                      >;
                  }
                >;
            }
          >;
      }
    >;
}

FlatResult {
  e.Range-B (#CallBrackets e.SubRange-E) e.Range-E =
    <FlatResult e.Range-B>
    (#TkOpenCall)
    <FlatResult e.SubRange-E>
    (#TkCloseCall)
    <FlatResult e.Range-E>
    ;

  e.Range-B (#Brackets e.SubRange-E) e.Range-E =
    <FlatResult e.Range-B>
    (#TkOpenBracket)
    <FlatResult e.SubRange-E>
    (#TkCloseBracket)
    <FlatResult e.Range-E>
    ;

  e.Range-B (#ADT-Brackets (e.Name) e.SubRange-E) e.Range-E =
    e.Range-B
    (#TkOpenADT)
    (#TkName e.Name)
    <FlatResult e.SubRange-E>
    (#TkCloseADT)
    <FlatResult e.Range-E>
    ;

  e.Range = e.Range;
}


// Основные команды работы с результатом
//  (#CmdAllocateElem s.Number s.ElType e.Info)
//  (#CmdLinkBrackets s.Left s.Right)
//  (#CmdPushStack s.Number)
//  (#CmdInsertElem s.Number)
//  (#CmdInsertVar s.Mode s.Number)

/*
  Порядок выполнения команд.
  1. Все выделения памяти (в порядке перечисления)
  2. Связывание крулых и угловых скобок и
  построение результата (в обратном порядке)
*/

GenResult {
  (e.Trash) (e.MarkedResult) =
    (#CmdComment 'TRASH:' <TextFromExpr e.Trash>)
    (#CmdComment 'RESULT:' <TextFromExpr e.MarkedResult>)

    //генерируем команды аллокаций
    <Map
      {
        (#Tile e.Tile) = ;

        (#TkVariableCopy 't' e.Index s.Level s.SampleOffset s.Offset) =
          (#CmdCopyVar 'e' s.Offset s.SampleOffset);

        (#TkVariableCopy s.Mode e.Index s.Level s.SampleOffset s.Offset) =
          (#CmdCopyVar s.Mode s.Offset s.SampleOffset);


        (#TkChar s.Char s.Offset) =
          (#CmdAllocateElem s.Offset #ElChar s.Char);

        (#TkNumber s.Number s.Offset) =
          (#CmdAllocateElem s.Offset #ElNumber s.Number);

        (#TkOpenBracket s.Offset) =
          (#CmdAllocateElem s.Offset #ElOpenBracket);

        (#TkCloseBracket s.Offset) =
          (#CmdAllocateElem s.Offset #ElCloseBracket);

        (#TkOpenADT s.Offset) =
          (#CmdAllocateElem s.Offset #ElOpenADT);

        (#TkCloseADT s.Offset) =
          (#CmdAllocateElem s.Offset #ElCloseADT);

        (#TkOpenCall s.Offset) =
          (#CmdAllocateElem s.Offset #ElOpenCall);

        (#TkCloseCall s.Offset) =
          (#CmdAllocateElem s.Offset #ElCloseCall);

        (#TkName e.Name s.Offset) =
          (#CmdAllocateElem s.Offset #ElName e.Name);

        (#TkIdentifier e.Name s.Offset) =
          (#CmdAllocateElem s.Offset #ElIdent e.Name);

      }
      e.MarkedResult
    >

    //Генерируем команды reinit/update
    <Map
      {
        (#Tile e.Tile) =
          <Map
            {
              (#AsIs t.Item) = /* пусто */;

              (#HalfReuse (#TkChar s.Char s.Offset)) =
                (#CmdReinitElem s.Offset #ElChar s.Char);

              (#HalfReuse (#TkNumber s.Number s.Offset)) =
                (#CmdReinitElem s.Offset #ElNumber s.Number);

              (#HalfReuse (#TkOpenBracket s.Offset)) =
                (#CmdReinitElem s.Offset #ElOpenBracket);

              (#HalfReuse (#TkCloseBracket s.Offset)) =
                (#CmdReinitElem s.Offset #ElCloseBracket);

              (#HalfReuse (#TkOpenADT s.Offset)) =
                (#CmdReinitElem s.Offset #ElOpenADT);

              (#HalfReuse (#TkCloseADT s.Offset)) =
                (#CmdReinitElem s.Offset #ElCloseADT);

              (#HalfReuse (#TkOpenCall s.Offset)) =
                (#CmdReinitElem s.Offset #ElOpenCall);

              (#HalfReuse (#TkCloseCall s.Offset)) =
                (#CmdReinitElem s.Offset #ElCloseCall);

              (#HalfReuse (#TkName e.Name s.Offset)) =
                (#CmdReinitElem s.Offset #ElName e.Name);

              (#HalfReuse (#TkIdentifier e.Name s.Offset)) =
                (#CmdReinitElem s.Offset #ElIdent e.Name);

              (#HalfReuse (#TkVariable 's' e.Index s.SampleOffset s.Offset)) =
                (#CmdReinitSVar s.Offset s.SampleOffset);


              (#Reuse (#TkChar s.Char s.Offset)) =
                (#CmdUpdateElem s.Offset #ElChar s.Char);

              (#Reuse (#TkNumber s.Number s.Offset)) =
                (#CmdUpdateElem s.Offset #ElNumber s.Number);

              (#Reuse (#TkOpenBracket s.Offset)) =
                (#CmdUpdateElem s.Offset #ElOpenBracket);

              (#Reuse (#TkCloseBracket s.Offset)) =
                (#CmdReinitElem s.Offset #ElCloseBracket);

              (#Reuse (#TkOpenADT s.Offset)) =
                (#CmdUpdateElem s.Offset #ElOpenADT);

              (#Reuse (#TkCloseADT s.Offset)) =
                (#CmdUpdateElem s.Offset #ElCloseADT);

              (#Reuse (#TkOpenCall s.Offset)) =
                (#CmdUpdateElem s.Offset #ElOpenCall);

              (#Reuse (#TkCloseCall s.Offset)) =
                (#CmdUpdateElem s.Offset #ElCloseCall);

              (#Reuse (#TkName e.Name s.Offset)) =
                (#CmdUpdateElem s.Offset #ElName e.Name);

              (#Reuse (#TkIdentifier e.Name s.Offset)) =
                (#CmdUpdateElem s.Offset #ElIdent e.Name);

              (#LEFT-EDGE) = /* пусто */;
              (#RIGHT-EDGE) = /* пусто */;
            }
            e.Tile
          >;

        t.Other = /* пусто */;
      }
      e.MarkedResult
    >

    //Генерируем команды связывания скобок
    <GenPushLinkComment
      <ModifyResult e.MarkedResult>
    >

    //Генерируем команды переноса из списка свободных узлов
    <GenSplicesComment (e.Trash) e.MarkedResult>;
}

GenPushLinkComment {
  e.MarkedResult =
    <Fetch
      <MapReduce
        {
          (e.Stack) (#TkOpenCall s.Offset) = (e.Stack s.Offset);
          (e.Stack) (#TkOpenADT s.Offset) = (e.Stack s.Offset);
          (e.Stack) (#TkOpenBracket s.Offset) = (e.Stack s.Offset);
          (e.Stack s.OpenOffset) (#TkCloseCall s.Offset) =
            (e.Stack)
            (#CmdPushStack s.OpenOffset)
            (#CmdPushStack s.Offset);
          (e.Stack s.OpenOffset) (#TkCloseADT s.Offset) =
            (e.Stack) (#CmdLinkBrackets s.OpenOffset s.Offset);
          (e.Stack s.OpenOffset) (#TkCloseBracket s.Offset) =
            (e.Stack) (#CmdLinkBrackets s.OpenOffset s.Offset);
          (e.Stack) (s.tag e.Info) = (e.Stack) ;
        }
        (/* стек */)
        e.MarkedResult
      >
      {
        () e.Commands = <Reverse e.Commands>;
      }
    >;
}

Reverse {
  e.Items t.Last = t.Last <Reverse e.Items>;

  /* empty */ = /* empty */;
}

ModifyResult {
  (#Tile e.Tile) e.Result = <ModifyTile e.Tile> <ModifyResult e.Result> ;
  (s.tag e.info) e.Result = (s.tag e.info) <ModifyResult e.Result> ;
  /*пусто*/ = ;
}

ModifyTile {
  (#RIGHT-EDGE) e.Range = <ModifyTile e.Range>;
  (#LEFT-EDGE) e.Range = <ModifyTile e.Range>;
  (#AsIs t.Item) e.Range = t.Item <ModifyTile e.Range>;
  (#HalfReuse t.Item) e.Range  = t.Item <ModifyTile e.Range>;
  (#Reuse t.Item) e.Range  = t.Item <ModifyTile e.Range>;
  /*пусто*/ = ;
}

GenSplicesComment {
  (e.Trash) (#Tile e.LeftTile) e.Result (#Tile e.RightTile) =
    (#CmdSetRes <CalcRes e.RightTile>)
    <Map
      {
        (t.OneItem) =
          (#CmdInsertTile
            <BeginOffset t.OneItem> <EndOffset t.OneItem>
          );

        (t.Begin e.Inner t.End) =
          (#CmdInsertTile <BeginOffset t.Begin> <EndOffset t.End>);
      }
      <CollectTiles e.Result>
    >
    (#CmdUseRes)
    <GenTrashComment (e.LeftTile) e.Trash>;

  (#RemovedTile) (#Tile e.OneTile) = (#CmdReturnResult-NoTrash);
}

CalcRes {
  (#RIGHT-EDGE) = #RIGHT-EDGE;

  t.First e.Tile = <BeginOffset t.First>;
}

CollectTiles {
  (#Tile e.Tile) e.Other =
    <CollectTiles e.Other> (e.Tile);

  e.Allocated (#Tile e.Tile) e.Other =
    <CollectTiles e.Other> (e.Tile) <CollectTiles-Alloc e.Allocated>;

  /* пусто */ = /* пусто */;

  e.Allocated = <CollectTiles-Alloc e.Allocated>;
}

CollectTiles-Alloc {
  (#TkVariableCopy 'e' e.Index s.Level s.Sample s.Offset) e.Alloc =
    <CollectTiles-Alloc e.Alloc>
    ((#TkVariableCopy 'e' e.Index s.Level s.Sample s.Offset));

  e.Alloc (#TkVariableCopy 'e' e.Index s.Level s.Sample s.Offset) =
    ((#TkVariableCopy 'e' e.Index s.Level s.Sample s.Offset))
    <CollectTiles-Alloc e.Alloc>;

  /* пусто */ = /* пусто */;

  e.Alloc = (e.Alloc);
}

GenTrashComment {
  (e.LeftTile) e.Trash-B #RemovedTile e.Trash-E =
    <GenTrashComment (e.LeftTile) e.Trash-B e.Trash-E>;

  (e.LeftTile) /* пусто */ =
    (#CmdReturnResult-NoTrash);

  ((#LEFT-EDGE)) e.Trash =
    (#CmdTrash #LEFT-EDGE);

  (e.LeftTile t.Last) e.Trash =
    (#CmdTrash <EndOffset t.Last>);
}

BeginOffset {
  (#AsIs t.Item) = <BeginOffset t.Item>;
  (#HalfReuse t.Item) = <BeginOffset t.Item>;
  (#Reuse t.Item) = <BeginOffset t.Item>;

  (s.Tag e.Info s.Offset) = s.Offset;
}

EndOffset {
  (#AsIs t.Item) = <EndOffset t.Item>;
  (#HalfReuse t.Item) = <EndOffset t.Item>;
  (#Reuse t.Item) = <EndOffset t.Item>;

  (#TkVariable 's' e.Index s.Depth s.Offset) = s.Offset;
  (#TkVariableCopy 's' e.Index s.Depth s.Sample s.Offset) = s.Offset;

  (#TkVariable s.Mode e.Index s.Depth s.Offset) = <Inc s.Offset>;
  (#TkVariableCopy s.Mode e.Index s.Depth s.Sample s.Offset) = <Inc s.Offset>;

  (s.Tag e.Info s.Offset) = s.Offset;
}
/*
  e.PatternVars ::= (s.Mode (e.Index) s.Offset*)*
*/
AddOffsets {
  s.ContextOffset (e.PatternVars) e.MarkedResult =
    /*
      Для переменных смещение брать из e.PatternVars + добавляем смещение для копии
      (+1 для s-переменных, +2 для t и e),
      для остальных элементов --- смещение s.ContextOffset.
    */
    <MapReduce
      {
        s.Offset (#Tile e.Tile) =
          s.Offset
          (#Tile
            <Map
              {
                (#HalfReuse (#TkVariable 's' e.Index s.Level s.Offset^)) =
                  <Fetch
                    e.PatternVars
                    {
                      e.Range-B
                      ('s' (e.Index s.Level) e.Offsets s.SampleOffset)
                      e.Range-E =
                        (#HalfReuse
                          (#TkVariable
                            's' e.Index s.Level s.SampleOffset s.Offset
                          )
                        );
                    }
                  >;

                t.Other = t.Other;
              }
              e.Tile
            >
          );

        s.Offset (#TkVariable 's' e.Index s.Level) =
          <Fetch
            e.PatternVars
            {
              e.Range-B ('s' (e.Index s.Level) e.Offsets s.SampleOffset) e.Range-E =
                <Add s.Offset 1> (#TkVariableCopy 's' e.Index s.Level s.SampleOffset s.Offset);
            }
          >;

        s.Offset (#TkVariable 't' e.Index s.Level) =
          <Fetch
            e.PatternVars
            {
              e.Range-B ('t' (e.Index s.Level) e.Offsets s.SampleOffset) e.Range-E =
                <Add s.Offset 2> (#TkVariableCopy 't' e.Index s.Level s.SampleOffset s.Offset);
            }
          >;

        s.Offset (#TkVariable 'e' e.Index s.Level) =
          <Fetch
            e.PatternVars
            {
              e.Range-B ('e' (e.Index s.Level) e.Offsets s.SampleOffset) e.Range-E =
                <Add s.Offset 2> (#TkVariableCopy 'e' e.Index  s.Level s.SampleOffset s.Offset);
            }
          >;

        s.Offset (s.Tag e.Info) = <Add s.Offset 1> (s.Tag e.Info s.Offset);
      }

      s.ContextOffset e.MarkedResult
    >;
}

FoldOpenELoops {
  e.Commands-B (#CmdOpenedE #AlgLeft s.BracketNum s.VarNumber) e.Commands-E =
    e.Commands-B
    (#CmdOpenELoop
      #AlgLeft s.BracketNum s.VarNumber
      <FoldOpenELoops e.Commands-E>
    );

  e.Commands = e.Commands;
}

/*
  e.Vars ::= (s.Count s.Mode e.Index)*
*/

//==============================================================================
// Генерация образца
//==============================================================================

/*
Команды распознавания
  Литералы, формат (#Cmd*** s.Direction s.BracketNum e.Literal)
  Скобки, формат (#CmdBrackets s.Direction s.BracketNum s.InnerNum)
  АТД, формат
    (#CmdADT s.Direction s.BracketNum s.InnerNum e.Name)
  Пустые скобки, формат (#CmdEmpty #AlgLeft s.BracketNum),
    направление добавлено для единнобразия, генератором не используется
  Переменные:
    повторные, формат
      (#CmdRepeated s.Direction s.BracketNum s.Mode s.VarNumber s.SampleNumber)
    новые s и t, формат (#CmdVar s.Direction s.BracketNum s.Mode s.VarNumber)
    открытые e:
      первоначальный формат (#CmdOpenedE #AlgLeft s.BracketNum s.VarNumber)
      после обработки:
        (#CmdOpenedE-Start #AlgLeft s.BracketNum 'e' e.Index)
        (#CmdOpenedE-End #AlgLeft s.BracketNum 'e' e.Index)
  Команды сохранения скобок
    (#CmdSave s.OldNumber e.NewNumber)
  Комментарий, вносимый в исходный код (#CmdComment e.Text)
*/

GenPattern {
  e.Pattern =
    //<WriteLine 'Pattern: ' e.Pattern>
    <Fetch
      <DoGenPattern
        2 /*5*/
        (#Junk) (#Range 0 /*3*/ e.Pattern) (#Junk) (/* vars */) (/* commands */)
      >
      <Seq
        {
          s.ContextOffset (e.Vars) (e.MarkedPattern) e.Commands =
            (e.Vars) (e.MarkedPattern)
            <FreezeRanges s.ContextOffset e.Commands>;
        }
        {
          (e.Vars) (e.MarkedPattern) s.ContextOffset e.Commands =
            (e.Vars) (e.MarkedPattern) s.ContextOffset
            <GetRangeReassigns e.Commands>;
        }
        {
          (e.Vars) (e.MarkedPattern) s.ContextOffset (e.Reassigns) e.Commands =
            (<FixupEVarIndexes (e.Reassigns) e.Vars>)
            (<FixupMarkedPatternIndexes (e.Reassigns) e.MarkedPattern>)
            s.ContextOffset e.Commands;
        }
        {
          (e.Vars) (e.MarkedPattern) s.ContextOffset e.Commands =
            (e.Vars) (e.MarkedPattern)
            s.ContextOffset
            ((#CmdComment <TextFromExpr e.MarkedPattern>) e.Commands);
        }
      >
    >;
}

GetRangeReassigns {
  e.Commands =
    <MapReduce
      {
        (e.Reassigns-B (s.First s.Old) e.Reassigns-E)
        (#CmdSave s.Old s.New) =
          (e.Reassigns-B (s.First s.New) e.Reassigns-E (s.Old s.New))
          (#CmdSave s.Old s.New);

        (e.Reassigns) (#CmdSave s.Old s.New) =
          (e.Reassigns (s.Old s.New)) (#CmdSave s.Old s.New);

        (e.Reassigns) t.OtherCommand =
          (e.Reassigns) t.OtherCommand;
      }
      (/* переназначения диапазонов */)
      e.Commands
    >;
}

FixupEVarIndexes {
  (e.Reassigns) e.Vars =
    <Map
      {
        ('e' (e.Index) e.Numbers) =
          ('e' (e.Index)
            <Map (FixupEVarIndexes-PatchNumber e.Reassigns) e.Numbers>
          );

        t.OtherVar = t.OtherVar;
      }
      e.Vars
    >;
}

FixupEVarIndexes-PatchNumber {
  e.Reassigns-B (s.Old s.New) e.Reassigns-E s.Old = s.New;

  e.Reassigns s.Number = s.Number;
}

FixupMarkedPatternIndexes {
  (e.Reassigns) e.MarkedPattern =
    <Map (FixupMarkedPatternTerm e.Reassigns) e.MarkedPattern>;
}

FixupMarkedPatternTerm {
  e.Reassigns-B (s.Old s.New) e.Reassigns-E
  (#TkVariable 'e' e.Index s.Depth s.Old) =
    (#TkVariable 'e' e.Index s.Depth s.New);

  e.Reassigns^ t.OtherTerm = t.OtherTerm;
}

Inc2 {
  s.Num = <Add 2 s.Num>;
}

/*
  <DoGenPattern s.Offset e.Ranges (e.Vars) (e.Commands)>

  e.Ranges ::=
    (#Junk e.Junk) (#Range s.Num e.Range) (#Junk e.Junk) ... (#Junk e.Junk)

  e.Range ::= e.Expression
  e.Junk ::= e.MarkedPattern
*/
DoGenPattern {
  // Распознавание литералов (символьных, целочисленных, имён)
  s.ContextOffset
  e.Ranges-B (#Junk e.Junk) (#Range s.Num (#TkChar s.Char) e.Range) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.ContextOffset>
      e.Ranges-B
      (#Junk e.Junk (#TkChar s.Char s.ContextOffset)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdCharSave #AlgLeft s.Num s.ContextOffset s.Char))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkNumber s.Number) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.ContextOffset>
      e.Ranges-B
      (#Junk e.Junk (#TkNumber s.Number s.ContextOffset)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdNumberSave #AlgLeft s.Num s.ContextOffset  s.Number))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkName e.Name) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.ContextOffset>
      e.Ranges-B
      (#Junk e.Junk (#TkName e.Name s.ContextOffset)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdNameSave #AlgLeft s.Num s.ContextOffset e.Name))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkIdentifier e.Name) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.ContextOffset>
      e.Ranges-B
      (#Junk e.Junk (#TkIdentifier e.Name s.ContextOffset)) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdIdentSave #AlgLeft s.Num s.ContextOffset  e.Name))
    >;

  s.ContextOffset
  e.Ranges-B (#Range s.Num e.Range (#TkChar s.Char)) (#Junk e.Junk) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.ContextOffset>
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkChar s.Char s.ContextOffset) e.Junk)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdCharSave #AlgRight s.Num s.ContextOffset s.Char))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#TkNumber s.Number)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.ContextOffset>
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkNumber s.Number s.ContextOffset) e.Junk)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdNumberSave #AlgRight s.Num s.ContextOffset s.Number))
    >;

  s.ContextOffset
  e.Ranges-B (#Range s.Num e.Range (#TkName e.Name)) (#Junk e.Junk) e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.ContextOffset>
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkName e.Name s.ContextOffset) e.Junk)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdNameSave #AlgRight s.Num s.ContextOffset  e.Name))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#TkIdentifier e.Name)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.ContextOffset>
      e.Ranges-B
      (#Range s.Num e.Range) (#Junk (#TkIdentifier e.Name s.ContextOffset) e.Junk)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdIdentSave #AlgRight s.Num s.ContextOffset e.Name))
    >;

  // Распознавание скобок конкретизации
  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk-L) (#Range s.Num (#CallBrackets (e.Name) e.SubRange)) (#Junk e.Junk-R)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Add s.ContextOffset 3>
      e.Ranges-B
      (
        #Junk
        e.Junk-L
        (#TkOpenCall s.Num)
        (#TkName e.Name <Add s.ContextOffset 2>)
      )
      (#Range s.ContextOffset e.SubRange)
      (
        #Junk
        (#TkCloseCall <Inc s.Num>)
        e.Junk-R
      )
      e.Ranges-E
      (e.Vars)
      (e.Commands (#CmdCallSave #AlgLeft s.Num s.ContextOffset e.Name))
    >;

  // Распознавание структурных скобок
  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#Brackets e.SubRange) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Add s.ContextOffset 4>
      e.Ranges-B
      (#Junk e.Junk (#TkOpenBracket <Add s.ContextOffset 2> ))
      (#Range s.ContextOffset e.SubRange)
      (#Junk (#TkCloseBracket <Add s.ContextOffset 3> )) (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdBracketsSave #AlgLeft s.Num s.ContextOffset))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#Brackets e.SubRange)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Add s.ContextOffset 4>
      e.Ranges-B
      (#Range s.Num e.Range)
      (#Junk (#TkOpenBracket <Add s.ContextOffset 2> ))
      (#Range s.ContextOffset e.SubRange)
      (#Junk (#TkCloseBracket <Add s.ContextOffset 3> ) e.Junk)
      e.Ranges-E
      (e.Vars) (e.Commands (#CmdBracketsSave #AlgRight s.Num s.ContextOffset))
    >;

  // Распознавание АТД-скобок
  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#ADT-Brackets (e.Name) e.SubRange) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Add s.ContextOffset 5>
      e.Ranges-B
      (
        #Junk
        e.Junk
        (#TkOpenADT  <Add s.ContextOffset 2>)
        (#TkName e.Name <Add s.ContextOffset 3>)
      )
      (#Range s.ContextOffset e.SubRange)
      (
        #Junk
        (#TkCloseADT  <Add s.ContextOffset 4>)
      )
      (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars)
      (e.Commands (#CmdADTSave #AlgLeft s.Num s.ContextOffset e.Name))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#ADT-Brackets (e.Name) e.SubRange)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Add s.ContextOffset 5>
      e.Ranges-B
      (#Range s.Num e.Range)
      (
        #Junk
        (#TkOpenADT  <Add s.ContextOffset 2>)
        (#TkName e.Name <Add s.ContextOffset 3>)
      )
      (#Range s.ContextOffset e.SubRange)
      (
        #Junk
        (#TkCloseADT  <Add s.ContextOffset 4>)
        e.Junk
      )
      e.Ranges-E
      (e.Vars)
      (e.Commands (#CmdADTSave #AlgRight s.Num s.ContextOffset e.Name))
    >;

  // Пустой диапазон
  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk1) (#Range s.Num /* пусто */) (#Junk e.Junk2)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B (#Junk e.Junk1 e.Junk2) e.Ranges-E
      (e.Vars) (e.Commands (#CmdEmpty #AlgLeft s.Num))
    >;

  // Распознавание переменных
  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkVariable s.Mode e.Index) e.Range)
  e.Ranges-E
  (e.Vars-B (s.Mode (e.Index) e.Offsets s.SampleOffset) e.Vars-E) (e.Commands) =
    <DoGenPattern
      <IncVarOffset s.ContextOffset s.Mode>
      e.Ranges-B
      (#Junk e.Junk (#TkVariable s.Mode e.Index s.ContextOffset))
      (#Range s.Num e.Range)
      e.Ranges-E
      (
        e.Vars-B
        (s.Mode (e.Index) e.Offsets s.SampleOffset s.ContextOffset)
        e.Vars-E
      )
      (
        e.Commands
        (#CmdRepeatedSave #AlgLeft s.Num s.Mode s.ContextOffset s.SampleOffset)
      )
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#TkVariable s.Mode e.Index)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars-B (s.Mode (e.Index) e.Offsets s.SampleOffset) e.Vars-E) (e.Commands) =
    <DoGenPattern
      <IncVarOffset s.ContextOffset s.Mode>
      e.Ranges-B
      (#Range s.Num e.Range)
      (#Junk (#TkVariable s.Mode e.Index s.ContextOffset) e.Junk)
      e.Ranges-E
      (
        e.Vars-B
        (s.Mode (e.Index) e.Offsets s.SampleOffset s.ContextOffset)
        e.Vars-E
      )
      (
        e.Commands
        (#CmdRepeatedSave #AlgRight s.Num s.Mode s.ContextOffset s.SampleOffset)
      )
    >;

  // Диапазон с закрытой переменной
  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk1) (#Range s.Num (#TkVariable 'e' e.Index)) (#Junk e.Junk2)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      s.ContextOffset
      e.Ranges-B
      (#Junk e.Junk1 (#TkVariable 'e' e.Index s.Num) e.Junk2)
      e.Ranges-E
      (e.Vars ('e' (e.Index) s.Num))
      (e.Commands
        (#CmdComment
          ' closed ' <PrintVar 'e' e.Index> ' as range ' <StrFromInt s.Num>
        )
      )
    >;

  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkVariable 's' e.Index) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.ContextOffset>
      e.Ranges-B
      (#Junk e.Junk (#TkVariable 's' e.Index s.ContextOffset))
      (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars ('s' (e.Index) s.ContextOffset))
      (e.Commands (#CmdVar #AlgLeft s.Num 's' s.ContextOffset))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkVariable 't' e.Index) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc2 s.ContextOffset>
      e.Ranges-B
      (#Junk e.Junk (#TkVariable 't' e.Index s.ContextOffset))
      (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars ('t' (e.Index) s.ContextOffset))
      (e.Commands (#CmdVarSave #AlgLeft s.Num 't' s.ContextOffset))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#TkVariable 's' e.Index)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc s.ContextOffset>
      e.Ranges-B
      (#Range s.Num e.Range)
      (#Junk (#TkVariable 's' e.Index s.ContextOffset) e.Junk)
      e.Ranges-E
      (e.Vars ('s' (e.Index) s.ContextOffset))
      (e.Commands (#CmdVar #AlgRight s.Num 's' s.ContextOffset))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Range s.Num e.Range (#TkVariable 't' e.Index)) (#Junk e.Junk)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc2 s.ContextOffset>
      e.Ranges-B
      (#Range s.Num e.Range)
      (#Junk (#TkVariable 't' e.Index s.ContextOffset) e.Junk)
      e.Ranges-E
      (e.Vars ('t' (e.Index) s.ContextOffset))
      (e.Commands (#CmdVarSave #AlgRight s.Num 't' s.ContextOffset))
    >;

  s.ContextOffset
  e.Ranges-B
  (#Junk e.Junk) (#Range s.Num (#TkVariable 'e' e.Index) e.Range)
  e.Ranges-E
  (e.Vars) (e.Commands) =
    <DoGenPattern
      <Inc2 s.ContextOffset>
      e.Ranges-B
      (#Junk e.Junk (#TkVariable 'e' e.Index s.ContextOffset))
      (#Range s.Num e.Range)
      e.Ranges-E
      (e.Vars ('e' (e.Index) s.ContextOffset))
      (e.Commands (#CmdOpenedE #AlgLeft s.Num s.ContextOffset))
    >;

  // Завершение разбора.
  s.ContextOffset (#Junk e.MarkedPattern) (e.Vars) (e.Commands) =
    s.ContextOffset (e.Vars) (e.MarkedPattern) e.Commands;
}

IncVarOffset {
  s.ContextOffset 'e' = <Inc2 s.ContextOffset>;
  s.ContextOffset 't' = <Inc2 s.ContextOffset>;
  s.ContextOffset 's' = <Inc s.ContextOffset>;
}

FreezeRanges {
  s.ContextTop e.Commands = <DoFreezeRanges s.ContextTop () e.Commands>;
}

DoFreezeRanges {
  s.ContextTop (e.Scanned)
  e.Commands-B (#CmdOpenedE #AlgLeft s.Num s.ContextOffset) e.Commands-E =
    <Fetch
      e.Scanned e.Commands-B (#CmdOpenedE #AlgLeft s.Num s.ContextOffset)
      {
        e.CommandsBeforeEMatch =
          <DoFreezeRanges-MakeSavers
            s.ContextTop
            ( <ExtractRanges e.CommandsBeforeEMatch> )
            ( e.CommandsBeforeEMatch )
            e.Commands-E
          >;
      }
    >;

  s.ContextTop (e.Scanned) e.Commands = s.ContextTop e.Scanned e.Commands;
}

DoFreezeRanges-MakeSavers {
  s.ContextTop
  (e.FrozenRanges-B s.Num e.FrozenRanges-E)
  (e.Scanned)
  e.Commands-B (s.Command s.Direction s.Num e.Args) e.Commands-E =
    <DoFreezeRanges-MakeSavers
      <Inc2 s.ContextTop>
      (e.FrozenRanges-B e.FrozenRanges-E)
      (e.Scanned (#CmdSave s.Num s.ContextTop))
      <Map
        {
          /*
            Все команды распознавания содержат номер скобок третьим термом,
            общий формат (s.Command s.Direction s.BracketNum e.Info)
          */
          (s.Command^ s.Direction^ s.Num e.Info^) =
            (s.Command s.Direction s.ContextTop e.Info);

          (#CmdRepeatedSave s.Direction^ s.OtherNum 'e' s.NewOffset s.Num) =
            (#CmdRepeatedSave s.Direction s.OtherNum 'e' s.NewOffset s.ContextTop);

          (s.Command^ s.Direction^ s.OtherNum e.Info^) =
            (s.Command s.Direction s.OtherNum e.Info);
        }
        e.Commands-B (s.Command s.Direction s.Num e.Args) e.Commands-E
      >
    >;

  s.ContextTop (e.UnusedFrozenRanges) (e.Scanned) e.Commands =
    <DoFreezeRanges s.ContextTop (e.Scanned) e.Commands>;
}

ExtractRanges {
  e.Commands =
    <UniqueRanges
      <Map
        {
          /*
            Все команды распознавания содержат номер скобок третьим термом,
            общий формат (s.Command s.Direction s.BracketNum e.Info)
          */
          (#CmdBracketsSave s.Direction s.BracketNum s.InnerNum) =
            s.BracketNum s.InnerNum;

          (#CmdADTSave s.Direction s.BracketNum s.InnerNum e.Name) =
            s.BracketNum s.InnerNum;

          (#CmdCallSave s.Direction s.BracketNum s.InnerNum e.Name) =
            s.BracketNum s.InnerNum;

          (#CmdComment e.Comment) =
            /* пусто */;

          (s.Command s.Direction s.BracketNum e.Info) = s.BracketNum;
        }
        e.Commands
      >
    >;
}

UniqueRanges {
  e.Unique s.Repeated e.Middle s.Repeated e.Rest =
    e.Unique <UniqueRanges s.Repeated e.Middle e.Rest>;

  e.Unique = e.Unique;
}

TextFromExpr {
  (#TkOpenBracket s.ContextOffset) e.Tail =
    ' (' <Offset s.ContextOffset> <TextFromExpr e.Tail>;
  (#TkCloseBracket s.ContextOffset) e.Tail =
    ' )' <Offset s.ContextOffset> <TextFromExpr e.Tail>;

  (#TkOpenCall s.ContextOffset) e.Tail =
    ' <' <Offset s.ContextOffset> <TextFromExpr e.Tail>;
  (#TkCloseCall s.ContextOffset) e.Tail =
    ' >' <Offset s.ContextOffset> <TextFromExpr e.Tail>;

  (#TkOpenADT s.ContextOffset) (#TkName e.Name s.NameOffset) e.Tail =
    ' [' <Offset s.ContextOffset> e.Name <Offset s.NameOffset> <TextFromExpr e.Tail>;
  (#TkOpenADT s.ContextOffset) e.Tail =
    ' [' <Offset s.ContextOffset> <TextFromExpr e.Tail>;
  (#TkCloseADT s.ContextOffset) e.Tail =
    ' ]' <Offset s.ContextOffset> <TextFromExpr e.Tail>;

  (#TkChar s.Char s.Offset) e.Tail =
    ' ''' <EscapeChar s.Char> '' <Offset s.Offset>
    <TextFromExpr e.Tail>;

  (#TkNumber s.Number s.Offset) e.Tail =
    ' ' <StrFromInt s.Number> <Offset s.Offset> <TextFromExpr e.Tail>;

  (#TkName e.Name s.Offset) e.Tail =
    ' & ' e.Name <Offset s.Offset> <TextFromExpr e.Tail>;

  (#TkVariable s.Mode e.Index s.Depth s.Offset) e.Tail =
    ' ' <PrintVar s.Mode e.Index s.Depth> <Offset s.Offset>
    <TextFromExpr e.Tail>;

  (#TkVariableCopy s.Mode e.Index s.Depth s.SampleOffset s.CopyOffset) e.Tail =
    ' ' <PrintVar s.Mode e.Index s.Depth>
    <Offset s.SampleOffset> <Offset s.CopyOffset>
    <TextFromExpr e.Tail>;

  (#TkIdentifier e.Name s.Offset) e.Tail =
    ' # ' e.Name <Offset s.Offset> <TextFromExpr e.Tail>;

  (#Tile e.SubRange) e.Tail = ' Tile{' <TextFromExpr e.SubRange> ' }' <TextFromExpr e.Tail>;
  (#AsIs e.SubRange) e.Tail = ' AsIs:' <TextFromExpr e.SubRange> <TextFromExpr e.Tail>;
  (#Reuse e.SubRange) e.Tail = ' Reuse:' <TextFromExpr e.SubRange> <TextFromExpr e.Tail>;
  (#HalfReuse e.SubRange) e.Tail = ' HalfReuse:' <TextFromExpr e.SubRange> <TextFromExpr e.Tail>;

  (#LEFT-EDGE) e.Tail = ' [[' <TextFromExpr e.Tail>;
  (#RIGHT-EDGE) = ' ]]';
  #RemovedTile e.Tail = ' {REMOVED TILE} ' <TextFromExpr e.Tail>;

  = ;
}

PrintVar {
  s.Mode e.Index s.Depth = s.Mode '.' e.Index '#' <StrFromInt s.Depth>;
}

Offset {
  #NoOffset = '/-';
  s.Offset = '/' <StrFromInt s.Offset>;
}

//==============================================================================
// Генерация результата
//==============================================================================


CollectStrings {
  (#TkChar s.Value1) (#TkChar s.Value2) e.Tail =
    <Fetch
      <BuildString (s.Value1 s.Value2) e.Tail>
      {
        (e.Chars) e.Tail^ = (#TkString e.Chars) <CollectStrings e.Tail>;
      }
    >;

  (#Brackets e.InBrackets) e.Tail =
    (#Brackets <CollectStrings e.InBrackets>) <CollectStrings e.Tail>;

  (#CallBrackets e.InBrackets) e.Tail =
    (#CallBrackets <CollectStrings e.InBrackets>) <CollectStrings e.Tail>;

  (#ADT-Brackets e.InBrackets) e.Tail =
    (#ADT-Brackets <CollectStrings e.InBrackets>) <CollectStrings e.Tail>;

  t.OtherTerm e.Tail = t.OtherTerm <CollectStrings e.Tail>;

  /* пусто */ = /* пусто */;
}

BuildString {
  (e.Chars) (#TkChar s.Value) e.Tail =
    <BuildString (e.Chars s.Value) e.Tail>;

  (e.Chars) e.Tail = (e.Chars) e.Tail;
}

