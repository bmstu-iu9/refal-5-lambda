$INCLUDE "LibraryEx";

*$FROM TreeUtils
$EXTERN ExtractVariables, NewVarName;


/**
  <GenericMatch (e.Pattern) (e.LPattern)>
    == Clear (e.Val ':' t.Var)*
    == Contracted ((t.Var ':' e.Val)* (e.Val ':' t.Var))*
    == Failure
    == Undefined

  e.Pattern, e.LPattern ::= t.PatternTerm*
  t.PatternTerm — см. src/compiler/README.md

  e.Val ::= t.PatternTerm*
  t.Var ::= (s.VarType e.Index)
  s.VarType ::= 's' | 't' | 'e'
*/

FormatAssigns {
  e.Assigns =
    <Map
      {
        (e.Left ':' (Var e.Index)) = (e.Left ':' (e.Index))
      }
      e.Assigns
    >
}

$ENTRY GenericMatch {
  (e.Pattern) (e.LPattern)
    = <Solve-Drive
        (<ExtractVariables ((e.Pattern e.LPattern) (/* пусто */))>)
        ((e.Pattern) ':' (e.LPattern))
      >
    : {
        Success (e._ () (e.Assigns)) = Clear <FormatAssigns e.Assigns>;
        Success e.Solutions = Contracted e.Solutions;
        Failure = Failure;
        Undefined = Undefined;
      }
}

/**
  <Solve-Drive (e.UsedVars) t.Equation>
    == Success t.Result* | Undefined | Failure

    t.Contr ::= (t.Var ':' e.Val)
    t.Equation ::= ((e.Expr) ':' (e.LExpr))
    t.Assign ::= (e.Val ':' t.Var)
    t.Result ::= (e.UsedVars^ (t.Contr*) (t.Assign*))
*/

$ENTRY Solve-Drive {
  (e.UsedVars) ((e.Expr) ':' (e.Lexpr))
    = <InitContractions e.Expr> : e.Contrs
    = <AddCoordinateLabels e.Expr> : e.Expr^
    = <Solve-Clashes
        (e.UsedVars)
        (None e.Contrs)
        ((e.Expr) ':' (e.Lexpr))
        (/* пусто */)
      >
    : {
        e._ (Generalize (e.Intervals)) e._ = Undefined;

        /* пусто */ = Failure;

        e.Success
          = <IsFlagOpen e.Success>
          : {
              True = Undefined;

              False = Success <CombineResults-Drive e.Success>;
            };
      };
}

/* Проверка на наличие поднятого флага в решениях */

IsFlagOpen {
  e._ (Success (e._) AfterOpen (e._) (e._)) e._ = True;

  e._ = False;
}

/*
  Преобразует решения в нужный формат для Solve-Drive

  <CombineResults-Drive e.RawSol*> == t.Sol*

  t.Sol ::= (e.UsedVars (t.Contr*) (t.Assign*))
  e.RawSol ::= (Success (e.UsedVars) s.OpenFlag (t.Contr*) (t.Assign*))
*/
CombineResults-Drive {
  e.RawSolutions
    = <Map
        {
          (Success (e.UsedVars) s.OpenFlag (e.Contrs) (e.Assigns))
            = <RemoveTrivialContractions e.Contrs> : e.Contrs^
            = <Map
                {
                  (e.Val ':' t.Var) = (<ClearCoordinates e.Val> ':' t.Var)
                }
                e.Assigns
              >
            : e.Assigns^
            = (e.UsedVars (e.Contrs) (e.Assigns));
        }
        e.RawSolutions
      >;
}

/**
  <Solve-Spec (e.UsedVars) (e.Left) (e.Right)>
    == Success ((t.Contr*) (t.Assign*))* (t.Assign*) (e.Left^)
    |  Failure

  t.Contr ::= (t.Var ':' e.Val)
  t.Assign ::= (e.Val ':' t.Var)
*/

$ENTRY Solve-Spec {
  (e.UsedVars) (e.Left) (e.Right)
    = <AddCoordinateLabels e.Left> : e.Left^
    = <Solve-Spec-DoFindGeneralization
        (e.UsedVars)
        ((e.Left) ':' (e.Right))
        ()
      >;
}

Solve-Spec-DoFindGeneralization {
  (e.UsedVars) ((e.L) ':' (e.R)) (e.GenAssigns)
    = <Solve-Clashes
        (e.UsedVars)
        (None <InitContractions e.L>)
        ((e.L) ':' (e.R))
        (/* пусто */)
      >
    : {
        e._ (Generalize (e.Intervals)) e._
          = <DoGeneralize
              (e.UsedVars) <UnionIfIntersect (e.Intervals)>
              (e.L) (e.GenAssigns)
            >
          : (e.UsedVars^) (e.L^) (e.GenAssigns^)
          = <Solve-Spec-DoFindGeneralization
              (e.UsedVars) ((e.L) ':' (e.R)) (e.GenAssigns)
            >;

        /* пусто */ = Failure;

        e.Success
          = Success
            <CombineResults-Spec e.Success>
            (e.GenAssigns)
            (<ClearCoordinates e.L>);
      }
}

/*
  Инициализирует список сужений тривиальными сужениями

  <InitContractions e.Expr> == t.Contr*
*/

InitContractions {
  e.Expr
    = <ExtractVariables ((e.Expr) (/* пусто */))> : e.Vars
    = <Map
        { (e.ModeIndex) = ((Var e.ModeIndex) ':' (Var e.ModeIndex)) }
        e.Vars
      >
}

/*
  Удаляет тривиальные сужения из набора сужений

  <RemoveTrivialContractions t.Contr*> == t.Contr*
*/

RemoveTrivialContractions {
  e.Contrs
    = <Map
        {
          ((Var e.ModeIndex) ':' (Var e.ModeIndex)) = /* пусто */;

          t.Contr = t.Contr;
        }
        e.Contrs
      >
}

/*
  Объединяет два интервала, если они пересекаются.
  В остальных случаях возвращает исходный список интервалов.

  <UnionIfIntersect (e.Intervals)> == (e.Intervals^)

  e.Intervals ::= t.Interval+
  t.Interval ::= ('{' s.BeginCoord s.EndCoord '}')
*/

UnionIfIntersect {
  (t.Interval-1 t.Interval-2)
    , <HasIntersection (t.Interval-1 t.Interval-2)> : True
    = t.Interval-1 : ('{' s.A s.B '}')
    = t.Interval-2 : ('{' s.C s.D '}')
    = <GetExtremum s.A '+' (s.B s.C s.D)> : s.Min
    = <GetExtremum s.A '-' (s.B s.C s.D)> : s.Max
    = (('{' s.Min s.Max '}'));

  t.Intervals = t.Intervals;
}

HasIntersection {
  (('{' s.A s.B '}') ('{' s.C s.D '}'))
    , <Compare s.C s.B> : '+'
    = False;

  (('{' s.A s.B '}') ('{' s.C s.D '}'))
    , <Compare s.A s.D> : '+'
    = False;

  t.Intervals = True;
}

GetExtremum {
  s.Extremum s.Sign (s.CurrentCoord e.Rest)
    , <Compare s.Extremum s.CurrentCoord> : s.Sign
    = <GetExtremum s.CurrentCoord s.Sign (e.Rest)>;

  s.Extremum s.Sign (s.CurrentCoord e.Rest)
    = <GetExtremum s.Extremum s.Sign (e.Rest)>;

  s.Extremum s.Sign (/* пусто */)
    = s.Extremum;
}

/*
  Преобразует решения в нужный формат для Solve-Spec

  <CombineResults-Spec e.RawSol*> == t.Sol*

  t.Sol ::= ((t.Contr*) (t.Assign*))
  e.RawSol ::= (Success (e.UsedVars) s.OpenFlag (t.Contr*) (t.Assign*))
*/

CombineResults-Spec {
  e.RawSolutions
    = <Map
        {
          (Success (e.UsedVars) s.OpenFlag (e.Contrs) (e.Assigns))
            = <RemoveTrivialContractions e.Contrs> : e.Contrs^
            = <Map
                {
                  (e.Val ':' t.Var) = (<ClearCoordinates e.Val> ':' t.Var)
                }
                e.Assigns
              >
            : e.Assigns^
            = ((e.Contrs) (e.Assigns));
        }
        e.RawSolutions
      >;
}

/*
  Функция, выполняющая динамическое обобщение

  <DoGeneralize (e.UsedVars) (t.Interval*) (e.Expr) (t.Assign*)>
    == (e.UsedVars^) (e.Expr^) (t.Assign*)

  t.Interval ::= ('{' s.A s.B '}')
*/

DoGeneralize {
  (e.UsedVars) (t.Interval e.Intervals)
  (e.Expr) (e.Assigns)
    = <DoGeneralize-Aux
        (e.UsedVars) t.Interval ()
        (e.Expr) (e.Assigns)
      >
    : (e.UsedVars^) (e.Expr^) (e.Assigns^)
    = <DoGeneralize
        (e.UsedVars) (e.Intervals)
        (e.Expr) (e.Assigns)
      >;

  (e.UsedVars) ()
  (e.Expr) (e.Assigns)
    = (e.UsedVars) (e.Expr) (e.Assigns);
}

DoGeneralize-Aux {
  (e.UsedVars) ('{' s.A s.B '}') (e.Begin)
  (e.E1 ('{'s.A'}') e.Inner ('{'s.B'}') e.E2) (e.Assigns)
    = <GetVarType e.Inner> : s.VarType
    = <ClearCoordinates
        <ApplyAssignments-toExpr (e.Assigns) e.Inner>
      >
    : e.VarVal
    = <NewVarName (e.UsedVars) s.VarType> : (e.UsedVars^) s.VarType^ e.New
    = (e.UsedVars)
      (e.E1 ('{'s.A'}') (Var s.VarType e.New) ('{'s.B'}') e.E2)
      (e.Assigns (e.VarVal ':' (s.VarType e.New)));

  (e.UsedVars) t.Interval (e.Begin)
  ((Brackets e.E) e.Rest) (e.Assigns)
    = <DoGeneralize-Aux
        (e.UsedVars) t.Interval ()
        (e.E) (e.Assigns)
      >
    : (e.UsedVars^) (e.E^) (e.Assigns^)
    = <DoGeneralize-Aux
        (e.UsedVars) t.Interval (e.Begin (Brackets e.E))
        (e.Rest) (e.Assigns)
      >;

  (e.UsedVars) t.Interval (e.Begin)
  ((ADT-Brackets (e.Name) e.E) e.Rest) (e.Assigns)
    = <DoGeneralize-Aux
        (e.UsedVars) t.Interval ()
        (e.E) (e.Assigns)
      >
    : (e.UsedVars^) (e.E^) (e.Assigns^)
    = <DoGeneralize-Aux
        (e.UsedVars) t.Interval (e.Begin (ADT-Brackets (e.Name) e.E))
        (e.Rest) (e.Assigns)
      >;

  (e.UsedVars) t.Interval (e.Begin)
  (t.T e.Rest) (e.Assigns)
    = <DoGeneralize-Aux
        (e.UsedVars) t.Interval (e.Begin t.T)
        (e.Rest) (e.Assigns)
      >;

  (e.UsedVars) t.Interval (e.Begin)
  () (e.Assigns)
    = (e.UsedVars) (e.Begin) (e.Assigns);
}

/* Определяет тип переменной, до которой выполнится динамическое обобщение */

GetVarType {
  (ClosureBrackets e._) = 's';

  e.Other = 'e';
}

* TODO: присваивания должны быть параллельными
ApplyAssignments-toExpr {
  (t.Assign e.Rest) e.Expr
    = <ApplyAssignments-toExpr
        (e.Rest)
        <ApplyAssignment-toExpr t.Assign e.Expr>
      >;

  () e.Expr = e.Expr;
}

ApplyAssignment-toExpr {
  (e.Val ':' (s.Type e.Index)) e.Begin (Var s.Type e.Index) e.End
    = <ApplyAssignment-toExpr (e.Val ':' (s.Type e.Index)) e.Begin>
      e.Val
      <ApplyAssignment-toExpr (e.Val ':' (s.Type e.Index)) e.End>;

  t.Assign e.Begin (Brackets e.E) e.End
    = <ApplyAssignment-toExpr t.Assign  e.Begin>
      (Brackets <ApplyAssignment-toExpr t.Assign e.E>)
      <ApplyAssignment-toExpr t.Assign e.End>;

  t.Assign e.Begin (ADT-Brackets e.E) e.End
    = <ApplyAssignment-toExpr t.Assign e.Begin>
      (ADT-Brackets <ApplyAssignment-toExpr t.Assign e.E>)
      <ApplyAssignment-toExpr t.Assign e.End>;

  t.Assign e.E = e.E;
}

/*
  Добавляет в левую часть уравнения метки координат

  <AddCoordinateLabels e.Expr> == e.Expr^
  <DoAddCoordinateLabels (e.Expr) s.CoordsNumber> == e.Expr^

  t.CoordinateLabel ::= ('{'s.CoordNumber'}')
*/

AddCoordinateLabels {
  /* пусто */ = /* пусто */;

  e.Expr = ('{'1'}') <DoAddCoordinateLabels (e.Expr) 2>
}

DoAddCoordinateLabels {
  ((Symbol s.SymType e.SymInfo) e.Rest) s.CoordNumber
    = (Symbol s.SymType e.SymInfo) ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Rest) <Add s.CoordNumber 1>>;

  ((Var s.Mode e.Index) e.Rest) s.CoordNumber
    = (Var s.Mode e.Index) ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Rest) <Add s.CoordNumber 1>>;

  ((ClosureBrackets e.Inner) e.Rest) s.CoordNumber
    = (ClosureBrackets e.Inner) ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Rest) <Add s.CoordNumber 1>>;

  ((CallBrackets e.Inner) e.Rest) s.CoordNumber
    = (CallBrackets e.Inner) ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Rest) <Add s.CoordNumber 1>>;

  ((Brackets e.Expr) e.Rest) s.CoordNumber
    = (Brackets ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Expr) <Add s.CoordNumber 1>>)
    : {
        (Brackets e.Inner ('{'s.LastCoord'}'))
          = (Brackets e.Inner ('{'s.LastCoord'}'))
            ('{'<Add s.LastCoord 1>'}')
            <DoAddCoordinateLabels (e.Rest) <Add s.LastCoord 2>>
      };

  ((ADT-Brackets (e.Name) e.Expression) e.Rest) s.CoordNumber
    = (ADT-Brackets (e.Name) ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Expression) <Add s.CoordNumber 1>>)
    : {
        (ADT-Brackets e.Inner ('{'s.LastCoord'}'))
          = (ADT-Brackets e.Inner ('{'s.LastCoord'}'))
            ('{'<Add s.LastCoord 1>'}')
            <DoAddCoordinateLabels (e.Rest) <Add s.LastCoord 2>>
      };

  (e.Other) s.CoordNumber
    = e.Other;
}

/*
  Упрощение координат (редуцирование их бессмысленного скопления)

  <SimplifyCoordinates (e.Contractions) t.Clash* (t.Assign*)>
    == (e.Contractions) t.Clash^* (t.Assign^*)
*/

SimplifyCoordinates {
  (e.Contrs) e.Clashes (e.Assigns)
    = (e.Contrs)
      <Map &SimplifyCoordinates-Clash e.Clashes>
      (<Map &SimplifyCoordinates-Assign e.Assigns>)
}

SimplifyCoordinates-Symm {
  (e.Contrs) e.SymmClashes (e.Assigns)
    = (e.Contrs)
      <Map &SimplifyCoordinates-SymmClash e.SymmClashes>
      (<Map &SimplifyCoordinates-Assign e.Assigns>)
}

SimplifyCoordinates-Clash {
  ((e.Left) ':' (e.Right))
    = ((<SimplifyCoordinates-Expr e.Left>) ':' (e.Right))
}

SimplifyCoordinates-SymmClash {
  (e.L '=' e.R)
    = (<SimplifyCoordinates-Expr e.L> '=' <SimplifyCoordinates-Expr e.R>)
}

SimplifyCoordinates-Assign {
  (e.Left ':' t.Right)
    = (<SimplifyCoordinates-Expr e.Left> ':' t.Right)
}

SimplifyCoordinates-Expr {
  /* {k} {m} E {n}  ↦  {m} E {n} */
  ('{'s.K'}') ('{'s.M'}') e.E ('{'s.N'}')
    = <SimplifyCoordinates-Expr ('{'s.M'}') e.E ('{'s.N'}')>;

  /* {k} E {m} {n}  ↦  {k} E {m} */
  ('{'s.K'}') e.E ('{'s.M'}') ('{'s.N'}')
    = <SimplifyCoordinates-Expr ('{'s.K'}') e.E ('{'s.M'}')>;

  /* {m} {n}  ↦  ε */
  ('{'s.M'}') ('{'s.N'}')
    = /* пусто */;

  ('{'s.M'}') e.E ('{'s.N'}')
    = ('{'s.M'}') <SimplifyCoordinates-Expr-Inner e.E> ('{'s.N'}');

  e.E = <SimplifyCoordinates-Expr-Inner e.E>;
}

SimplifyCoordinates-Expr-Inner {
  /* Ê1{k} {m} {n}Ê2  ↦  Ê1{k} {n}Ê2 */
  e.E1 ('{'s.K'}') ('{'s.M'}') ('{'s.N'}') e.E2
    = <SimplifyCoordinates-Expr-Inner e.E1 ('{'s.K'}') ('{'s.N'}') e.E2>;

  e.Begin (Brackets e.E) e.End
    = <SimplifyCoordinates-Expr-Inner e.Begin>
      (Brackets <SimplifyCoordinates-Expr e.E>)
      <SimplifyCoordinates-Expr-Inner e.End>;

  e.Begin (ADT-Brackets (e.Name) e.E) e.End
    = <SimplifyCoordinates-Expr-Inner e.Begin>
      (ADT-Brackets (e.Name) <SimplifyCoordinates-Expr e.E>)
      <SimplifyCoordinates-Expr-Inner e.End>;

  e.E = e.E;
}

/*
  <Solve-Clashes (e.UsedVars) (e.Contractions) t.Clash* (t.Assign*)>
    == t.Result*

    e.Contractions ::= s.OpenFlag t.Contr*
    s.OpenFlag ::= None | AfterOpen
    t.Contr ::= (t.Var ':' e.Val)
    t.Clash ::= ((e.L) ':' (e.R))
    t.Assign ::= (e.Val ':' t.Var)
    t.Result
      ::= (Success (e.UsedVars) s.OpenFlag (t.Contr*) (t.Assign*))
      |   (Generalize ( ('{' s.BeginCoord s.EndCoord '}')+ ))
*/

Solve-Clashes {
  /* {m} T {n} : t.X   ↦  {m} T {n} ← t.X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.T ('{'s.N'}')) ':' (t.X))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , t.X : (Var 't' e.Tindex)
    = <Solve-Clashes
        (e.UsedVars)
        (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (e.Assigns (('{'s.M'}') t.T ('{'s.N'}') ':' t.X))
      >;

  /* {m} Sym {n} : s.X   ↦  {m} Sym {n} ← s.X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.Sym ('{'s.N'}')) ':' (t.X))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Sym> : True
    , t.X : (Var 's' e.Sindex)
    = <Solve-Clashes
        (e.UsedVars)
        (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (e.Assigns (('{'s.M'}') t.Sym ('{'s.N'}') ':' t.X))
      >;

  /* {m} (E) {n} : (P)   ↦  {m} E {n} : P */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.L ('{'s.N'}')) ':' (t.R))
  e.ClashesEnd (e.Assigns)
    , t.L : (Brackets e.LBody)
    , t.R : (Brackets e.RBody)
    = <Solve-Clashes
        (e.UsedVars)
        (e.Contrs) e.ClashesStart
        <SimplifyCoordinates-Clash
          ((('{'s.M'}') e.LBody ('{'s.N'}')) ':' (e.RBody))
        >
        e.ClashesEnd (e.Assigns)
      >;

  /* {m} [X E] {n} : [X P]   ↦  {m} E {n} : P */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.L ('{'s.N'}')) ':' (t.R))
  e.ClashesEnd (e.Assigns)
    , t.L : (ADT-Brackets (e.Name) e.LBody)
    , t.R : (ADT-Brackets (e.Name) e.RBody)
    = <Solve-Clashes
        (e.UsedVars)
        (e.Contrs) e.ClashesStart
        <SimplifyCoordinates-Clash
          ((('{'s.M'}') e.LBody ('{'s.N'}')) ':' (e.RBody))
        >
        e.ClashesEnd (e.Assigns)
      >;

  /* {m} [X E] {n} : [Y P]  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.L ('{'s.N'}')) ':' (t.R))
  e.ClashesEnd (e.Assigns)
    , t.L : (ADT-Brackets e._)
    , t.R : (ADT-Brackets e._)
    = /* нет решений */;

  /* {m} [E] {n} : (P)  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.L ('{'s.N'}')) ':' (t.R))
  e.ClashesEnd (e.Assigns)
    , t.L : (ADT-Brackets e._)
    , t.R : (Brackets e._)
    = /* нет решений */;

  /* {m} (E) {n} : [P]  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.L ('{'s.N'}')) ':' (t.R))
  e.ClashesEnd (e.Assigns)
    , t.R : (ADT-Brackets e._)
    , t.L : (Brackets e._)
    = /* нет решений */;

  /* {m} (E) {n} : Psym  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.L ('{'s.N'}')) ':' (t.Psym))
  e.ClashesEnd (e.Assigns)
    , t.L : (Brackets e.LBody)
    , <IsSVarSubset t.Psym> : True
    = /* нет решений */;

  /* {m} [E] {n} : Psym  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.L ('{'s.N'}')) ':' (t.Psym))
  e.ClashesEnd (e.Assigns)
    , t.L : (ADT-Brackets (e.LName) e.LBody)
    , <IsSVarSubset t.Psym> : True
    = /* нет решений */;

  /* {m} Sym {n} : (P)  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.Sym ('{'s.N'}')) ':' (t.R))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Sym> : True
    , t.R : (Brackets e.RBody)
    = /* нет решений */;

  /* {m} Sym {n} : [P]  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.Sym ('{'s.N'}')) ':' (t.R))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Sym> : True
    , t.R : (ADT-Brackets (e.RName) e.RBody)
    = /* нет решений */;

  /* {m} t.X {n} : (P)  ↦  t.X → (e.NEW) */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.P))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 't' e.Tindex)
    , t.P : (Brackets e.PBody)
    = <NewVarName (e.UsedVars) 'e' e.Tindex> : t.NewVars 'e' e.NewIndex
    = <Solve-Clashes
        t.NewVars
        <AddContraction-Spec
          (t.X ':' (Brackets (Var 'e' e.NewIndex)))
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.P))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m} t.X {n} : [X P]   ↦  t.X → [X e.NEW] */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.P))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 't' e.Tindex)
    , t.P : (ADT-Brackets (e.PName) e.PBody)
    = <NewVarName (e.UsedVars) 'e' e.Tindex> : t.NewVars 'e' e.NewIndex
    = <Solve-Clashes
        t.NewVars
        <AddContraction-Spec
          (t.X ':' (ADT-Brackets (e.PName) (Var 'e' e.NewIndex)))
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.P))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m} t.X {n} : Psym  ↦  t.X → s.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.Psym))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 't' e.Tindex)
    , <IsSVarSubset t.Psym> : True
    = <NewVarName (e.UsedVars) 's' e.Tindex> : t.NewVars 's' e.NewIndex
    = <Solve-Clashes
        t.NewVars
        <AddContraction-Spec
          (t.X ':' (Var 's' e.NewIndex))
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.Psym))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m} s.X {n} :  X  ↦  s.X → X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.S))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 's' e.Sindex)
    , t.S : (Symbol e._)
    = <Solve-Clashes
        (e.UsedVars)
        <AddContraction-Spec
          (t.X ':' t.S)
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.S))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /*  {m} X {n}  :  X    ↦  стираем */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.X))
  e.ClashesEnd (e.Assigns)
    , t.X : (Symbol e._)
    = <Solve-Clashes
        (e.UsedVars)
        (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (e.Assigns)
      >;

  /*  {m} X {n}  :  Y    ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X ('{'s.N'}')) ':' (t.Y))
  e.ClashesEnd (e.Assigns)
    , t.X : (Symbol e._)
    , t.Y : (Symbol e._)
    = /* нет решений */;

  /* E : e.X  ↦  E ← e.X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((e.E) ':' (t.X))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 'e' e.XIndex)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (e.Assigns (e.E ':' t.X))
      >;

  /* {m} e.X E {n} : ε  ↦  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X e.E ('{'s.N'}')) ':' (/* пусто */))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 'e' e.XIndex)
    = <Solve-Clashes
        (e.UsedVars)
        <AddContraction-Spec
          (t.X ':' /* пусто */)
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') t.X e.E ('{'s.N'}')) ':' (/* пусто */))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m}  T E  {n} : ε  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.T e.E ('{'s.N'}')) ':' (/* пусто */))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    = /* решений нет */;

  /* ε : E1 Pt E2  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((/* пусто */) ':' (e.E1 t.Pt e.E2))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.Pt> : True
    = /* решений нет */;

  /* ε : ε  ↦  стираем */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((/* пусто */) ':' (/* пусто */))
  e.ClashesEnd (e.Assigns)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (e.Assigns)
      >;

  /* {m} T {n} E : Pt P   ↦  {m} T {n} : Pt  &&  {n} E : P */
  /* {m} T E* {n} E : Pt P   ↦  {m} T {n} : Pt  &&  {m} E* {n} E : P */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.T e.E) ':' (t.Pt e.P))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , <IsTerm t.Pt> : True
    , <HasTopLevelCoordinateLabels e.E> : True
    = <SeparateTermLeft ('{'s.M'}') t.T e.E>
    : (e.Left1) (e.Left2)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs) e.ClashesStart
        ((e.Left1) ':' (t.Pt))
        ((e.Left2) ':' (e.P))
        e.ClashesEnd (e.Assigns)
      >;

  /* E {m} T {n} : P  Pt  ↦  E {m} : P   &&  {m} T {n} : Pt */
  /* E {m} E* T {n} : P  Pt  ↦  E {m} E* {n} : P   &&  {m} T {n} : Pt */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((e.E t.T ('{'s.N'}')) ':' (e.P t.Pt))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , <IsTerm t.Pt> : True
    , <HasTopLevelCoordinateLabels e.E> : True
    = <SeparateTermRight e.E t.T ('{'s.N'}')>
    : (e.Left1) (e.Left2)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs) e.ClashesStart
        ((e.Left1) ':' (e.P))
        ((e.Left2) ':' (t.Pt))
        e.ClashesEnd (e.Assigns)
      >;

  /* {m} e.X E {n} : Pt P   ↦  e.X → t.NEW1 e.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.X e.E ('{'s.N'}')) ':' (t.Pt e.P))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 'e' e.XIndex)
    , <IsTerm t.Pt> : True
    = <NewVarName (e.UsedVars) 't' e.XIndex> : t.NewVars1 't' e.New1
    = <NewVarName t.NewVars1 'e' e.XIndex> : t.NewVars2 'e' e.New2
    = <AddContraction-Spec
        (t.X ':' (Var 't' e.New1) (Var 'e' e.New2))
        (e.Contrs) e.ClashesStart
        ((('{'s.M'}') t.X e.E ('{'s.N'}')) ':' (t.Pt e.P))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec
        (t.X ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        ((('{'s.M'}') t.X e.E ('{'s.N'}')) ':' (t.Pt e.P))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-Clashes t.NewVars2 e.Branch1>
      <Solve-Clashes (e.UsedVars) e.Branch2>;

  /* {m} E e.X {n} : P  Pt  ↦  e.X → e.NEW1 t.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') e.E t.X ('{'s.N'}')) ':' (e.P t.Pt))
  e.ClashesEnd (e.Assigns)
    , t.X : (Var 'e' e.XIndex)
    , <IsTerm t.Pt> : True
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : t.NewVars1 'e' e.New1
    = <NewVarName t.NewVars1 't' e.XIndex> : t.NewVars2 't' e.New2
    = <AddContraction-Spec
        (t.X ':' (Var 'e' e.New1) (Var 't' e.New2))
        (e.Contrs) e.ClashesStart
        ((('{'s.M'}') e.E t.X ('{'s.N'}')) ':' (e.P t.Pt))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec
        (t.X ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        ((('{'s.M'}') e.E t.X ('{'s.N'}')) ':' (e.P t.Pt))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-Clashes t.NewVars2 e.Branch1>
      <Solve-Clashes (e.UsedVars) e.Branch2>;

  /* могли остаться только клэши вида E : e.X P e.Y */
  (e.UsedVars) (s.OpenFlag e.Contrs)
  ((e.E) ':' (t.eX e.P t.eY))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    , e.E : ('{'s.M'}') e.Inner ('{'s.N'}')
    , <IsLeftPartTrivial e.E> : False
    , s.OpenFlag : AfterOpen
    = (Generalize (('{' s.M s.N '}')));

  (e.UsedVars) (e.Contrs)
  ((('{'s.M'}') t.eVar ('{'s.N'}')) ':' (t.eX e.P t.eY))
  e.ClashesEnd (e.Assigns)
    , t.eVar : (Var 'e' e.Index)
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    , <IsVarInAssigns t.eVar (e.Assigns)> : True
    = (Generalize (('{' s.M s.N '}')));

  (e.UsedVars) (e.Contrs)
  ((e.E) ':' (t.eX e.P t.eY))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <SplitLeftPart e.E> : (e.Parts)
    = <Map
        {
          t.Part
            = <SplitSolve
                (e.UsedVars) (e.Contrs)
                (t.Part ':' (t.eX e.P t.eY))
                e.ClashesEnd (e.Assigns)
              >
        }
        e.Parts
      >;

  /* клэши закончились */
  (e.UsedVars) (e.Contrs) (e.Assigns)
    = <CreateSymmClashes (e.Assigns)> : (e.Assigns^) (e.SymmClashes)
    = <Solve-SymmClashes
        (e.UsedVars) (e.Contrs)
        e.SymmClashes
        (e.Assigns)
      >;

  /* все остальное будет трактоваться как противоречие */
  (e.UsedVars) (e.Contrs) e.Clashes (e.Assigns)
    = /* решений нет */;
}

/*
  Проверяет на тривиальность левую часть клэша с открытой переменной

  <IsLeftPartTrivial e.LeftPart> == True | False
*/

IsLeftPartTrivial {
  ('{'s.M'}') (Var 'e' e._) ('{'s.N'}') = True;

  /* пусто */ = True;

  e.Other = False;
}

/*
  Проверяет, встречается ли переменная в левой части какого-нибудь присваивания

  <IsVarInAssigns t.Var (t.Assign*)> == True | False
*/

IsVarInAssigns {
  t.Var ((e.Expr ':' t._) e.Assigns)
    = <IsVarInExpr t.Var (e.Expr)>
    : {
        True = True;

        False = <IsVarInAssigns t.Var (e.Assigns)>;
      };

  t.Var (/* пусто */)
    = False;
}

IsVarInExpr {
  t.Var (t.Var e.End)
    = True;

  t.Var ((s.BracketsTag e.E) e.End)
    , <OneOf s.BracketsTag Brackets ADT-Brackets> : True
    = <IsVarInExpr t.Var (e.E)>
    : {
        True = True;

        False = <IsVarInExpr t.Var (e.End)>;
      };

  t.Var (t.Term e.End)
    = <IsVarInExpr t.Var (e.End)>;

  t.Var (/* пусто */)
    = False;
}

/*
  Разбивает левую часть клэша на список выражений,
  каждое из которых содержит одну точку разбиения

  <SplitLeftPart e.LeftPart>
    == (t.Part*)
  <SplitLeftPart-Aux (e.Begin) (e.Expr) (e.Parts)>
    == (t.Part*)

  t.Part ::= (e.LeftPartWithSplitPoint)
  t.SplitPoint ::= ('sp' e.Content)
*/

SplitLeftPart {
  /* Если E начинается на терм, то точка разбиения добавляется в начало */
  ('{'s.BeginCoord'}') t.T e.Rest
    , <IsTerm t.T> : True
    = <SplitLeftPart-Aux
        (('{'s.BeginCoord'}'))
        (t.T e.Rest)
        ((('sp' ('{'s.BeginCoord'}')) t.T e.Rest))
      >;

  ('{'s.BeginCoord'}') e.Rest
    = <SplitLeftPart-Aux
        (('{'s.BeginCoord'}'))
        (e.Rest)
        ()
      >;

  /* пусто */ = ((('sp')));
}

SplitLeftPart-Aux {
  /* Точки разбиения добавляются между двумя смежными термами */
  (e.Begin) (t.T1 t.T2 e.Rest) (e.Parts)
    , <IsTerm t.T1> : True
    , <IsTerm t.T2> : True
    = <SplitLeftPart-Aux
        (e.Begin t.T1)
        (t.T2 e.Rest)
        (e.Parts (e.Begin t.T1 ('sp') t.T2 e.Rest))
      >;

  /* Точки разбиения добавляются между двумя смежными термами */
  (e.Begin) (t.T1 ('{'s.Coord'}') t.T2 e.Rest) (e.Parts)
    , <IsTerm t.T1> : True
    , <IsTerm t.T2> : True
    = <SplitLeftPart-Aux
        (e.Begin t.T1 ('{'s.Coord'}'))
        (t.T2 e.Rest)
        (e.Parts (e.Begin t.T1 ('sp' ('{'s.Coord'}')) t.T2 e.Rest))
      >;

  /* Если E заканчивается на терм, то точка разбиения добавляется в конец */
  (e.Begin) (t.T ('{'s.Coord'}')) (e.Parts)
    , <IsTerm t.T> : True
    = (e.Parts (e.Begin t.T ('sp' ('{'s.Coord'}'))));

  (e.Begin) (t.T e.Rest) (e.Parts)
    , <IsTerm t.T> : True
    = <SplitLeftPart-Aux
        (e.Begin t.T)
        (e.Rest)
        (e.Parts)
      >;

  /* Точки разбиения находятся «внутри» e-параметров */
  (e.Begin) (t.eX e.Rest) (e.Parts)
    , t.eX : (Var 'e' e.XIndex)
    = <SplitLeftPart-Aux
        (e.Begin t.eX)
        (e.Rest)
        (e.Parts (e.Begin ('sp' t.eX) e.Rest))
      >;

  (e.Begin) (('{'s.Coord'}') e.Rest) (e.Parts)
    = <SplitLeftPart-Aux
        (e.Begin ('{'s.Coord'}'))
        (e.Rest)
        (e.Parts)
      >;

  (e.Begin) () (e.Parts)
    = (e.Parts);
}

/*
  Разрешает систему клэшей для одной точки разбиения

  <SplitSolve
    (e.UsedVars) (e.Contractions)
    t.ClashWithSplitPoint t.Clash*
    (t.Assign*)
  > == t.Result*
*/

SplitSolve {
*  {m} E {n} : e.X P e.Y  ↦  ε ← e.X,  {m} E {n} : P e.Y
*   ↑
  (e.UsedVars) (e.Contrs)
  ((('sp' ('{'s.M'}')) e.E ('{'s.N'}')) ':' (t.eX e.P t.eY))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        ((('{'s.M'}') e.E ('{'s.N'}')) ':' (e.P t.eY))
        e.ClashesEnd (e.Assigns (/* пусто */ ':' t.eX))
      >;

*  {k} E1 T2 {m} T3 E4 {n} : e.X P e.Y  ↦  {k} E1 T2 {m} ← e.X,
*             ↑                            {m} T3 E4 {n} : P e.Y
  (e.UsedVars) (e.Contrs)
  (
    (
      ('{'s.K'}') e.E1 t.T2
      ('sp' ('{'s.M'}'))
      t.T3 e.E4 ('{'s.N'}')
    )
    ':' (t.eX e.P t.eY)
  )
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T2> : True
    , <IsTerm t.T3> : True
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        ((('{'s.M'}') t.T3 e.E4 ('{'s.N'}')) ':' (e.P t.eY))
        e.ClashesEnd (e.Assigns (('{'s.K'}') e.E1 t.T2 ('{'s.M'}') ':' t.eX))
      >;

*  E1 {m} E2* T3 . T4 E5* {n} E6 : e.X P e.Y  ↦  E1 {m} E2* T3 {n} ← e.X,
*                ↑                               {m} T4 E5* {n} E6 : P e.Y
  (e.UsedVars) (e.Contrs)
  (
    (
      e.E1 ('{'s.M'}') e.E2
      t.T3 ('sp') t.T4
      e.E5 ('{'s.N'}') e.E6
    )
    ':' (t.eX e.P t.eY)
  )
  e.ClashesEnd (e.Assigns)
    , <HasTopLevelCoordinateLabels e.E2> : False
    , <IsTerm t.T3> : True
    , <IsTerm t.T4> : True
    , <HasTopLevelCoordinateLabels e.E5> : False
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        ((('{'s.M'}') t.T4 e.E5 ('{'s.N'}') e.E6) ':' (e.P t.eY))
        e.ClashesEnd
        (e.Assigns (e.E1 ('{'s.M'}') e.E2 t.T3 ('{'s.N'}') ':' t.eX))
      >;

*  {m} E {n} : e.X P e.Y  ↦  {m} E {n} ← e.X,  ε : P e.Y
*         ↑
  (e.UsedVars) (e.Contrs)
  (
    (('{'s.M'}') e.E ('sp' ('{'s.N'}')))
    ':' (t.eX e.P t.eY)
  )
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        ((/* пусто */) ':' (e.P t.eY))
        e.ClashesEnd (e.Assigns (('{'s.M'}') e.E ('{'s.N'}') ':' t.eX))
      >;

*  ε : e.X P e.Y  ↦  ε ← e.X, ε : P e.Y
*  ↑
  (e.UsedVars) (e.Contrs)
  ((('sp')) ':' (t.eX e.P t.eY))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        ((/* пусто */) ':' (e.P t.eY))
        e.ClashesEnd (e.Assigns (/* пусто */ ':' t.eX))
      >;

*  E1 e.X {m} e.Y E2 : e.L P e.R  ↦  e.X → e.NEW1! t.NEW2 e.NEW3,
*      ↑                              E1 e.NEW1! {m} ← e.L,
*                                     {n} t.NEW2 e.NEW3 {m} e.Y E2 : P e.R
*                  где E1 = E3 {n} E4*
  (e.UsedVars) (e.Contrs)
  ((e.E1 ('sp' t.eX) ('{'s.M'}') t.eY e.E2) ':' (t.eL e.P t.eR))
  e.ClashesEnd (e.Assigns)
    , e.E1 : e.E3 ('{'s.N'}') e.E4
    , <HasTopLevelCoordinateLabels e.E4> : False
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    , t.eL : (Var 'e' e.LIndex)
    , t.eR : (Var 'e' e.RIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New1
    = <NewVarName (e.UsedVars) 't' e.XIndex> : (e.UsedVars^) 't' e.New2
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New3
    = (Var 'e' e.New1) : t.eNew1
    = (Var 't' e.New2) : t.tNew2
    = (Var 'e' e.New3) : t.eNew3
    = <Solve-Clashes
        (e.UsedVars)
        <AddContraction-Spec
          (t.eX ':' t.eNew1 t.tNew2 t.eNew3)
          (e.Contrs)
          ((('{'s.N'}') t.tNew2 t.eNew3 ('{'s.M'}') t.eY e.E2) ':' (e.P t.eR))
          e.ClashesEnd (e.Assigns (e.E1 t.eNew1 ('{'s.M'}') ':' t.eL))
        >
      >;

*  E1 e.X E2 : e.L P e.R  ↦  e.X → e.NEW1! e.NEW2,
*      ↑                  E1 e.NEW1! {m} ← e.L,
*                         {n} e.NEW2 E2 : P e.R
*                  где E1 = E3 {n} E4*
*                      E2 = E5* {m} E6
  (e.UsedVars) (e.Contrs)
  ((e.E1 ('sp' t.eX) e.E2) ':' (t.eL e.P t.eR))
  e.ClashesEnd (e.Assigns)
    , e.E1 : e.E3 ('{'s.N'}') e.E4
    , <HasTopLevelCoordinateLabels e.E4> : False
    , t.eX : (Var 'e' e.XIndex)
    , e.E2 : e.E5 ('{'s.M'}') e.E6
    , <HasTopLevelCoordinateLabels e.E5> : False
    , t.eL : (Var 'e' e.LIndex)
    , t.eR : (Var 'e' e.RIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New1
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New2
    = (Var 'e' e.New1) : t.eNew1
    = (Var 'e' e.New2) : t.eNew2
    = <Solve-Clashes
        (e.UsedVars)
        <AddContraction-Spec
          (t.eX ':' t.eNew1 t.eNew2)
          (e.Contrs)
          ((('{'s.N'}') t.eNew2 e.E2) ':' (e.P t.eR))
          e.ClashesEnd (e.Assigns (e.E1 t.eNew1 ('{'s.M'}') ':' t.eL))
        >
      >;
}

/*
  Формирует по списку присваиваний список симметричных клэшей
  и обновленный список присваиваний

  <CreateSymmClashes (t.Assign*)>
    == (t.Assign*) (t.SymmClash*)
  <CreateSymmClashes-Aux (t.Assign*) (t.SymmClash*) (t.Assign*)>
    == (t.Assign*) (t.SymmClash*)

  t.SymmClash ::= (e.L '=' e.R)
*/

CreateSymmClashes {
  (e.Assigns)
    = <CreateSymmClashes-Aux (e.Assigns) () ()>
    : (e.Assigns^) (e.SymmClashes)
    = (e.Assigns) (<RemoveTautologies e.SymmClashes>);
}

CreateSymmClashes-Aux {
  ((e.Left ':' t.Var) e.Rest) (e.SymmClashes) (e.NewAssigns)
    = <GroupAssignsByVar (e.Rest) t.Var ()> : (e.Rest^) (e.Group)
    = <CreateSymmClashes-Aux
        (e.Rest)
        (<CreateSymmClashesFromGroup
          (e.Left ':' t.Var)
          (e.Group)
          (e.SymmClashes)
        >)
        (e.NewAssigns (e.Left ':' t.Var))
      >;

  () (e.SymmClashes) (e.NewAssigns)
    = (e.NewAssigns) (e.SymmClashes);
}

/*
  Группирует присваивания с одинаковой переменной в правой части.
  Возвращает сформированную группу и список присваиваний без
  участия присваиваний, которые попали в группу

  <GroupAssignsByVar (t.Assign*) t.Var t.Group> == (t.Assign*) t.Group

  t.Var ::= (Var s.Type e.Index)
  t.Group ::= (t.Assign*)
*/

GroupAssignsByVar {
  (e.Begin (e.Left ':' t.Var) e.End) t.Var (e.Group)
    = <GroupAssignsByVar
        (e.Begin e.End)
        t.Var
        (e.Group (e.Left ':' t.Var))
      >;

  (e.Assigns) t.Var (e.Group)
    = (e.Assigns) (e.Group);
}

/*
  Формирует список симметричных клэшей на основании группы из
  присваиваний с одинаковыми переменными в правой части

  <CreateSymmClashesFromGroup t.FirstAssign t.Group (t.SymmClash*)>
    == t.SymmClash*
  <CreateSymmClashesFromGroup-Aux t.CurrentAssign t.Group (t.SymmClash*)>
    == t.SymmClash*

  t.FirstAssign, t.CurrentAssign ::= t.Assign
*/

CreateSymmClashesFromGroup {
  (e.E1 ':' t.Var) ((e.Ei ':' t.Var) e.Rest) (e.SymmClashes)
    = <CreateSymmClashesFromGroup
        (e.E1 ':' t.Var)
        (e.Rest)
        (<CreateSymmClashesFromGroup-Aux
            (e.Ei ':' t.Var)
            (e.Rest)
            (e.SymmClashes (e.E1 '=' e.Ei))
        >)
      >;

  t.FirstAssign () (e.SymmClashes)
    = e.SymmClashes;
}

CreateSymmClashesFromGroup-Aux {
  (e.Ei ':' t.Var) ((e.Ej ':' t.Var) e.Rest) (e.SymmClashes)
    = <CreateSymmClashesFromGroup-Aux
        (e.Ei ':' t.Var)
        (e.Rest)
        (e.SymmClashes (e.Ei '=' e.Ej))
      >;

  t.CurrentAssign () (e.SymmClashes)
    = e.SymmClashes;
}

/*
  Удаляет все координаты из выражения

  <ClearCoordinates e.Expr> == e.ExprWithoutCoordinates
*/

ClearCoordinates {
  e.Begin ('{'s.M'}') e.End
    = <ClearCoordinates e.Begin e.End>;

  e.Begin (Brackets e.E) e.End
    = <ClearCoordinates e.Begin>
      (Brackets <ClearCoordinates e.E>)
      <ClearCoordinates e.End>;

  e.Begin (ADT-Brackets (e.Name) e.E) e.End
    = <ClearCoordinates e.Begin>
      (ADT-Brackets (e.Name) <ClearCoordinates e.E>)
      <ClearCoordinates e.End>;

  e.Expr = e.Expr;
}

/*
  Вспомогательные функции отделения термов от выражений
  (отделений слева и справа соответственно)

  <SeparateTermLeft e.Expr>
    == (t.CoordinateLabel t.Term t.CoordinateLabel)
       (e.RestExpr)

  <SeparateTermRight e.Expr>
    == (e.RestExpr)
       (t.CoordinateLabel t.Term t.CoordinateLabel)
*/

SeparateTermLeft {
*  {a} T {b} E  ↦  {a} T {b}, {b} E
  ('{'s.A'}') t.T ('{'s.B'}') e.E
    , <IsTerm t.T> : True
    = <Eq (e.E) (/* пусто */)>
    : {
        True = (('{'s.A'}') t.T ('{'s.B'}')) (/* пусто */);

        False = (('{'s.A'}') t.T ('{'s.B'}')) (('{'s.B'}') e.E);
      };

*  {a} T E1* {b} E2  ↦  {a} T {b}, {a} E1* {b} E2
  ('{'s.A'}') t.T e.E1 ('{'s.B'}') e.E2
    , <IsTerm t.T> : True
    , <HasTopLevelCoordinateLabels e.E1> : False
    = (('{'s.A'}') t.T ('{'s.B'}'))
      (('{'s.A'}') e.E1 ('{'s.B'}') e.E2);
}

SeparateTermRight {
*  E {a} T {b}  ↦  E {a}, {a} T {b}
  e.E ('{'s.A'}') t.T ('{'s.B'}')
    , <IsTerm t.T> : True
    = <Eq (e.E) (/* пусто */)>
    : {
        True = (/* пусто */) (('{'s.A'}') t.T ('{'s.B'}'));

        False = (e.E ('{'s.A'}')) (('{'s.A'}') t.T ('{'s.B'}'));
      };

*  E1 {a} E2* T {b}  ↦  E1 {a} E2* {b}, {a} T {b}
  e.E1 ('{'s.A'}') e.E2 t.T ('{'s.B'}')
    , <HasTopLevelCoordinateLabels e.E2> : False
    , <IsTerm t.T> : True
    = (e.E1 ('{'s.A'}') e.E2 ('{'s.B'}'))
      (('{'s.A'}') t.T ('{'s.B'}'));
}

/*
  Проверяет, является ли симметричный клэш тавтологией

  <IsTautology t.SymmClash> == True | False
*/

IsTautology {
  (e.L '=' e.R)
    = <ClearCoordinates e.L> : e.LWithoutCoords
    = <ClearCoordinates e.R> : e.RWithoutCoords
    = <Eq (e.LWithoutCoords) (e.RWithoutCoords)>
}

/*
  Отфильтровывает тавтологии из списка симметричных клэшей

  <RemoveTautologies t.SymmClash*> == t.SymmClash*
*/

RemoveTautologies {
  e.SymmClashes
    = <Map
        {
          t.SymmClash, <IsTautology t.SymmClash> : True = /* пусто */;

          t.SymmClash = t.SymmClash;
        }
        e.SymmClashes
      >
}

/*
  Функция, разрешающая симметричные клэши

  <Solve-SymmClashes (e.UsedVars) (e.Contractions) t.SymmClash* (t.Assign*)>
    == t.Result*
*/

Solve-SymmClashes {
  (e.UsedVars) (e.Contrs) e.SymmClashes (e.Assigns)
    = <RemoveTautologies e.SymmClashes> : e.SymmClashes^
    = <Solve-SymmClashes-Aux
        (e.UsedVars) (e.Contrs)
        e.SymmClashes (e.Assigns)
      >;
}

Solve-SymmClashes-Aux {
  /* {a} e.X {b} = {c} e.Y {d}  ↦  e.X → e.NEW, e.Y → e.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.eX ('{'s.B'}') '=' ('{'s.C'}') t.eY ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New
    = (Var 'e' e.New) : t.eNew
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContractions-Spec-Symm
          ((t.eX ':' t.eNew) (t.eY ':' t.eNew))
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} e.X {b} = {c} t.Y {d}  ↦  e.X → t.NEW, t.Y → t.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.eX ('{'s.B'}') '=' ('{'s.C'}') t.tY ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.tY : (Var 't' e.YIndex)
    = <NewVarName (e.UsedVars) 't' e.YIndex> : (e.UsedVars^) 't' e.New
    = (Var 't' e.New) : t.tNew
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContractions-Spec-Symm
          ((t.eX ':' t.tNew) (t.tY ':' t.tNew))
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} t.Y {b} = {c} e.X {d}  ↦  t.Y → t.NEW, e.X → t.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.tY ('{'s.B'}') '=' ('{'s.C'}') t.eX ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.tY : (Var 't' e.YIndex)
    = <NewVarName (e.UsedVars) 't' e.YIndex> : (e.UsedVars^) 't' e.New
    = (Var 't' e.New) : t.tNew
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContractions-Spec-Symm
          ((t.tY ':' t.tNew) (t.eX ':' t.tNew))
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} e.X {b} = {c} s.Y {d}  ↦  e.X → s.NEW, s.Y → s.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.eX ('{'s.B'}') '=' ('{'s.C'}') t.sY ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.sY : (Var 's' e.YIndex)
    = <NewVarName (e.UsedVars) 's' e.YIndex> : (e.UsedVars^) 's' e.New
    = (Var 's' e.New) : t.sNew
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContractions-Spec-Symm
          ((t.eX ':' t.sNew) (t.sY ':' t.sNew))
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} s.Y {b} = {c} e.X {d}  ↦  s.Y → s.NEW, e.X → s.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.sY ('{'s.B'}') '=' ('{'s.C'}') t.eX ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.sY : (Var 's' e.YIndex)
    = <NewVarName (e.UsedVars) 's' e.YIndex> : (e.UsedVars^) 's' e.New
    = (Var 's' e.New) : t.sNew
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContractions-Spec-Symm
          ((t.sY ':' t.sNew) (t.eX ':' t.sNew))
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} t.X {b} = {c} t.Y {d}  ↦  t.X → t.NEW, t.Y → t.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.tX ('{'s.B'}') '=' ('{'s.C'}') t.tY ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.tX : (Var 't' e.XIndex)
    , t.tY : (Var 't' e.YIndex)
    = <NewVarName (e.UsedVars) 't' e.XIndex> : (e.UsedVars^) 't' e.New
    = (Var 't' e.New) : t.tNew
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContractions-Spec-Symm
          ((t.tX ':' t.tNew) (t.tY ':' t.tNew))
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} t.X {b} = {c} s.Y {d}  ↦  t.X → s.NEW, s.Y → s.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.tX ('{'s.B'}') '=' ('{'s.C'}') t.sY ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.tX : (Var 't' e.XIndex)
    , t.sY : (Var 's' e.YIndex)
    = <NewVarName (e.UsedVars) 's' e.YIndex> : (e.UsedVars^) 's' e.New
    = (Var 's' e.New) : t.sNew
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContractions-Spec-Symm
          ((t.tX ':' t.sNew) (t.sY ':' t.sNew))
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} s.Y {b} = {c} t.X {d}  ↦  s.Y → s.NEW, t.X → s.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.sY ('{'s.B'}') '=' ('{'s.C'}') t.tX ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.tX : (Var 't' e.XIndex)
    , t.sY : (Var 's' e.YIndex)
    = <NewVarName (e.UsedVars) 's' e.YIndex> : (e.UsedVars^) 's' e.New
    = (Var 's' e.New) : t.sNew
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContractions-Spec-Symm
          ((t.sY ':' t.sNew) (t.tX ':' t.sNew))
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} s.X {b} = {c} s.Y {d}  ↦  s.X → s.NEW, s.Y → s.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.sX ('{'s.B'}') '=' ('{'s.C'}') t.sY ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.sX : (Var 's' e.XIndex)
    , t.sY : (Var 's' e.YIndex)
    = <NewVarName (e.UsedVars) 's' e.XIndex> : (e.UsedVars^) 's' e.New
    = (Var 's' e.New) : t.sNew
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContractions-Spec-Symm
          ((t.sX ':' t.sNew) (t.sY ':' t.sNew))
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* ε = {m} e.X E {n}  ↦  e.X → ε, ε = {m} E {n} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (/* пусто */ '=' ('{'s.M'}') t.eX e.E ('{'s.N'}'))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.eX ':' /* пусто */)
          (e.Contrs) e.ClashesStart
          (/* пусто */ '=' ('{'s.M'}') e.E ('{'s.N'}'))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m} e.X E {n} = ε  ↦  e.X → ε, {m} E {n} = ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.M'}') t.eX e.E ('{'s.N'}') '=' /* пусто */)
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.eX ':' /* пусто */)
          (e.Contrs) e.ClashesStart
          (('{'s.M'}') e.E ('{'s.N'}') '=' /* пусто */)
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* ε = {m} T E {n}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (/* пусто */ '=' ('{'s.M'}') t.T e.E ('{'s.N'}'))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    = /* решений нет */;

  /* {m} T E {n} = ε  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.M'}') t.T e.E ('{'s.N'}') '=' /* пусто */)
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    = /* решений нет */;

  /* {a} t.X {b} = {c} {{ &F e.X }} {d}  ↦  обобщаем {c−d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.tX ('{'s.B'}') '=' ('{'s.C'}') t.Closure ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.tX : (Var 't' e._)
    , t.Closure : (ClosureBrackets e._)
    = (Generalize (('{' s.C s.D '}')));

  /* {c} {{ &F e.X }} {d} = {a} t.X {b}  ↦  обобщаем {c−d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Closure ('{'s.D'}') '=' ('{'s.A'}') t.tX ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.tX : (Var 't' e._)
    , t.Closure : (ClosureBrackets e._)
    = (Generalize (('{' s.C s.D '}')));

  /* {a} s.X {b} = {c} {{ &F e.X }} {d}  ↦  обобщаем {c−d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.sX ('{'s.B'}') '=' ('{'s.C'}') t.Closure ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.sX : (Var 's' e._)
    , t.Closure : (ClosureBrackets e._)
    = (Generalize (('{' s.C s.D '}')));

  /* {c} {{ &F e.X }} {d} = {a} s.X {b}  ↦  обобщаем {c−d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Closure ('{'s.D'}') '=' ('{'s.A'}') t.sX ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.sX : (Var 's' e._)
    , t.Closure : (ClosureBrackets e._)
    = (Generalize (('{' s.C s.D '}')));

  /* {a}  X  {b} = {c} {{ &F e.X }} {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.X ('{'s.B'}') '=' ('{'s.C'}') t.Closure ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.X : (Symbol e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {c} {{ &F e.X }} {d} = {a}  X  {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Closure ('{'s.D'}') '=' ('{'s.A'}') t.X ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.X : (Symbol e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {a} (E) {b} = {c} {{ &F e.X }} {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.BrE ('{'s.B'}') '=' ('{'s.C'}') t.Closure ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.BrE : (Brackets e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {c} {{ &F e.X }} {d} = {a} (E) {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Closure ('{'s.D'}') '=' ('{'s.A'}') t.BrE ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.BrE : (Brackets e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {a} [X E] {b} = {c} {{ &F e.X }} {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.BrE ('{'s.B'}') '=' ('{'s.C'}') t.Closure ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.BrE : (ADT-Brackets e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {c} {{ &F e.X }} {d} = {a} [X E] {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Closure ('{'s.D'}') '=' ('{'s.A'}') t.BrE ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.BrE : (ADT-Brackets e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {a} [X E1] {b} = {c} (E2) {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br1 ('{'s.B'}') '=' ('{'s.C'}') t.Br2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br1 : (ADT-Brackets e._)
    , t.Br2 : (Brackets e._)
    = /* решений нет */;

  /* {c} (E2) {d} = {a} [X E1] {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Br2 ('{'s.D'}') '=' ('{'s.A'}') t.Br1 ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br1 : (ADT-Brackets e._)
    , t.Br2 : (Brackets e._)
    = /* решений нет */;

  /* {a} t.X {b} = {c} X {d}  ↦  t.X → X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.tX ('{'s.B'}') '=' ('{'s.C'}') t.X ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.tX : (Var 't' e.XIndex)
    , t.X : (Symbol e._)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' t.X)
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {c} X {d} = {a} t.X {b}  ↦  t.X → X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.X ('{'s.D'}') '=' ('{'s.A'}') t.tX ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.tX : (Var 't' e.XIndex)
    , t.X : (Symbol e._)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' t.X)
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} s.X {b} = {c} X {d}  ↦  s.X → X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.sX ('{'s.B'}') '=' ('{'s.C'}') t.X ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.sX : (Var 's' e.XIndex)
    , t.X : (Symbol e._)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.sX ':' t.X)
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {c} X {d} = {a} s.X {b}  ↦  s.X → X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.X ('{'s.D'}') '=' ('{'s.A'}') t.sX ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.sX : (Var 's' e.XIndex)
    , t.X : (Symbol e._)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.sX ':' t.X)
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} X {b} = {c} Y {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.X ('{'s.B'}') '=' ('{'s.C'}') t.Y ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.X : (Symbol e._)
    , t.Y : (Symbol e._)
    , <Eq t.X t.Y> : False
    = /* решений нет */;

  /* {a} (E1) {b} = {c} (E2) {d}  ↦  {a} E1 {b} = {c} E2 {d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br1 ('{'s.B'}') '=' ('{'s.C'}') t.Br2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br1 : (Brackets e.E1)
    , t.Br2 : (Brackets e.E2)
    = <Solve-SymmClashes
        (e.UsedVars)
        (e.Contrs) e.ClashesStart
        <SimplifyCoordinates-SymmClash
          (('{'s.A'}') e.E1 ('{'s.B'}') '=' ('{'s.C'}') e.E2 ('{'s.D'}'))
        >
        e.ClashesEnd (e.Assigns)
      >;

  /* {a} [X E1] {b} = {c} [X E2] {d}  ↦  {a} E1 {b} = {c} E2 {d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br1 ('{'s.B'}') '=' ('{'s.C'}') t.Br2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br1 : (ADT-Brackets (e.Name) e.E1)
    , t.Br2 : (ADT-Brackets (e.Name) e.E2)
    = <Solve-SymmClashes
        (e.UsedVars)
        (e.Contrs) e.ClashesStart
        <SimplifyCoordinates-SymmClash
          (('{'s.A'}') e.E1 ('{'s.B'}') '=' ('{'s.C'}') e.E2 ('{'s.D'}'))
        >
        e.ClashesEnd (e.Assigns)
      >;

  /* {a} [X E1] {b} = {c} [Y E2] {d}  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br1 ('{'s.B'}') '=' ('{'s.C'}') t.Br2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br1 : (ADT-Brackets e._)
    , t.Br2 : (ADT-Brackets e._)
    = /* нет решений */;

  /* {a} ({b} E {c}) {d} = {e} t.X {f}  ↦  t.X → (e.NEW) */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets ('{'s.B'}') e.E ('{'s.C'}'))
    , t.tX : (Var 't' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' (Brackets (Var 'e' e.New)))
          (e.Contrs) e.ClashesStart
          (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /*
    {a} (E) {d} = {e} t.X {f}  ↦  обобщение

    Правило нужно, иначе может произойти зацикливание
    на стадии отделения термов
  */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets e._)
    , t.tX : (Var 't' e._)
    = (Generalize (('{' s.A s.D '}') ('{' s.E s.F '}')));

  /* {e} t.X {f} = {a} ({b} E {c}) {d}  ↦  t.X → (e.NEW) */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets ('{'s.B'}') e.E ('{'s.C'}'))
    , t.tX : (Var 't' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' (Brackets (Var 'e' e.New)))
          (e.Contrs) e.ClashesStart
          (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {e} t.X {f} = {a} (E) {d}  ↦  обобщение */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets e._)
    , t.tX : (Var 't' e._)
    = (Generalize (('{' s.E s.F '}') ('{' s.A s.D '}')));

  /* {a} [X {b} E {c}] {d} = {e} t.X {f}  ↦  t.X → [e.NEW] */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets (e.Name) ('{'s.B'}') e.E ('{'s.C'}'))
    , t.tX : (Var 't' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' (ADT-Brackets (e.Name) (Var 'e' e.New)))
          (e.Contrs) e.ClashesStart
          (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {a} [X E] {d} = {e} t.X {f}  ↦  обобщение */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets (e.Name) e._)
    , t.tX : (Var 't' e._)
    = (Generalize (('{' s.A s.D '}') ('{' s.E s.F '}')));

  /* {e} t.X {f} = {a} [X {b} E {c}] {d}  ↦  t.X → [e.NEW] */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets (e.Name) ('{'s.B'}') e.E ('{'s.C'}'))
    , t.tX : (Var 't' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' (ADT-Brackets (e.Name) (Var 'e' e.New)))
          (e.Contrs) e.ClashesStart
          (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {e} t.X {f} = {a} [X E] {d}  ↦  обобщение */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets (e.Name) e._)
    , t.tX : (Var 't' e._)
    = (Generalize (('{' s.E s.F '}') ('{' s.A s.D '}')));

  /* {a} (E) {b} = {c} Sym {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.B'}') '=' ('{'s.C'}') t.Sym ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets e.E)
    , <IsSVarSubset t.Sym> : True
    = /* решений нет */;

  /* {c} Sym {d} = {a} (E) {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Sym ('{'s.D'}') '=' ('{'s.A'}') t.Br ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets e.E)
    , <IsSVarSubset t.Sym> : True
    = /* решений нет */;

  /* {a} [E] {b} = {c} Sym {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.B'}') '=' ('{'s.C'}') t.Sym ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets e._)
    , <IsSVarSubset t.Sym> : True
    = /* решений нет */;

  /* {c} Sym {d} = {a} [E] {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Sym ('{'s.D'}') '=' ('{'s.A'}') t.Br ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets e._)
    , <IsSVarSubset t.Sym> : True
    = /* решений нет */;

*  {a} T1 E1 = {b} T2 E2  ↦  {c} T1 {d} = {e} T2 {f} && {g} E1′ = {h} E2′
*    где {c} T1 {d}, {g} E1′ := TERM_LEFT({a} T1 E1)
*        {e} T2 {f}, {h} E2′ := TERM_LEFT({b} T2 E2)
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.T1 e.E1 '=' ('{'s.B'}') t.T2 e.E2)
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T1> : True
    , <IsTerm t.T2> : True
    , <HasTopLevelCoordinateLabels e.E1> : True
    , <HasTopLevelCoordinateLabels e.E2> : True
    = <SeparateTermLeft ('{'s.A'}') t.T1 e.E1> : (e.Left1) (e.Left2)
    = <SeparateTermLeft ('{'s.B'}') t.T2 e.E2> : (e.Right1) (e.Right2)
    = <Solve-SymmClashes
        (e.UsedVars) (e.Contrs) e.ClashesStart
        (e.Left1 '=' e.Right1) (e.Left2 '=' e.Right2)
        e.ClashesEnd (e.Assigns)
      >;

*  E1 T1 {a} = E2 T2 {b}  ↦  E1′ {c} = E2′ {d} && {e} T1 {f} = {g} T2 {h}
*    где E1′ {c}, {e} T1 {f} := TERM_RIGHT(E1 T1 {a})
*        E2′ {d}, {g} T2 {h} := TERM_RIGHT(E2 T2 {b})
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (e.E1 t.T1 ('{'s.A'}') '=' e.E2 t.T2 ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T1> : True
    , <IsTerm t.T2> : True
    , <HasTopLevelCoordinateLabels e.E1> : True
    , <HasTopLevelCoordinateLabels e.E2> : True
    = <SeparateTermRight e.E1 t.T1 ('{'s.A'}')> : (e.Left1) (e.Left2)
    = <SeparateTermRight e.E2 t.T2 ('{'s.B'}')> : (e.Right1) (e.Right2)
    = <Solve-SymmClashes
        (e.UsedVars) (e.Contrs) e.ClashesStart
        (e.Left1 '=' e.Right1) (e.Left2 '=' e.Right2)
        e.ClashesEnd (e.Assigns)
      >;

  /* {a} T {b} E1 = {c} e.X E2  ↦  e.X → t.NEW1 e.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.T ('{'s.B'}') e.E1 '=' ('{'s.C'}') t.eX e.E2)
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , t.eX : (Var 'e' e.XIndex)
    = <NewVarName (e.UsedVars) 't' e.XIndex> : t.NewVars1 't' e.New1
    = <NewVarName t.NewVars1 'e' e.XIndex> : t.NewVars2 'e' e.New2
    = (Var 't' e.New1) : t.tNew1
    = (Var 'e' e.New2) : t.eNew2
    = <AddContraction-Spec-Symm
        (t.eX ':' t.tNew1 t.eNew2)
        (e.Contrs) e.ClashesStart
        (('{'s.A'}') t.T ('{'s.B'}') e.E1 '=' ('{'s.C'}') t.eX e.E2)
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec-Symm
        (t.eX ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        (('{'s.A'}') t.T ('{'s.B'}') e.E1 '=' ('{'s.C'}') t.eX e.E2)
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-SymmClashes t.NewVars2 e.Branch1>
      <Solve-SymmClashes (e.UsedVars) e.Branch2>;

  /* {c} e.X E2 = {a} T {b} E1  ↦  e.X → t.NEW1 e.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.eX e.E2 '=' ('{'s.A'}') t.T ('{'s.B'}') e.E1)
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , t.eX : (Var 'e' e.XIndex)
    = <NewVarName (e.UsedVars) 't' e.XIndex> : t.NewVars1 't' e.New1
    = <NewVarName t.NewVars1 'e' e.XIndex> : t.NewVars2 'e' e.New2
    = (Var 't' e.New1) : t.tNew1
    = (Var 'e' e.New2) : t.eNew2
    = <AddContraction-Spec-Symm
        (t.eX ':' t.tNew1 t.eNew2)
        (e.Contrs) e.ClashesStart
        (('{'s.C'}') t.eX e.E2 '=' ('{'s.A'}') t.T ('{'s.B'}') e.E1)
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec-Symm
        (t.eX ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        (('{'s.C'}') t.eX e.E2 '=' ('{'s.A'}') t.T ('{'s.B'}') e.E1)
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-SymmClashes t.NewVars2 e.Branch1>
      <Solve-SymmClashes (e.UsedVars) e.Branch2>;

  /* E1 {a} T {b} = E2 e.X {c}  ↦  e.X → e.NEW1 t.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (e.E1 ('{'s.A'}') t.T ('{'s.B'}') '=' e.E2 t.eX ('{'s.C'}'))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , t.eX : (Var 'e' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : t.NewVars1 'e' e.New1
    = <NewVarName t.NewVars1 't' e.XIndex> : t.NewVars2 't' e.New2
    = (Var 'e' e.New1) : t.eNew1
    = (Var 't' e.New2) : t.tNew2
    = <AddContraction-Spec-Symm
        (t.eX ':' t.eNew1 t.tNew2)
        (e.Contrs) e.ClashesStart
        (e.E1 ('{'s.A'}') t.T ('{'s.B'}') '=' e.E2 t.eX ('{'s.C'}'))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec-Symm
        (t.eX ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        (e.E1 ('{'s.A'}') t.T ('{'s.B'}') '=' e.E2 t.eX ('{'s.C'}'))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-SymmClashes t.NewVars2 e.Branch1>
      <Solve-SymmClashes (e.UsedVars) e.Branch2>;

  /* E2 e.X {c} = E1 {a} T {b}  ↦  e.X → e.NEW1 t.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (e.E2 t.eX ('{'s.C'}') '=' e.E1 ('{'s.A'}') t.T ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , t.eX : (Var 'e' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : t.NewVars1 'e' e.New1
    = <NewVarName t.NewVars1 't' e.XIndex> : t.NewVars2 't' e.New2
    = (Var 'e' e.New1) : t.eNew1
    = (Var 't' e.New2) : t.tNew2
    = <AddContraction-Spec-Symm
        (t.eX ':' t.eNew1 t.tNew2)
        (e.Contrs) e.ClashesStart
        (e.E2 t.eX ('{'s.C'}') '=' e.E1 ('{'s.A'}') t.T ('{'s.B'}'))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec-Symm
        (t.eX ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        (e.E2 t.eX ('{'s.C'}') '=' e.E1 ('{'s.A'}') t.T ('{'s.B'}'))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-SymmClashes t.NewVars2 e.Branch1>
      <Solve-SymmClashes (e.UsedVars) e.Branch2>;

*  Если остались клэши, к которым не применимы вышеперечисленные правила,
*  то производим запрос на обобщение
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') e.E1 ('{'s.B'}') '=' ('{'s.C'}') e.E2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    = (Generalize (('{' s.A s.B '}') ('{' s.C s.D '}')));

*  Если клэши кончились, возвращаем решение
  (e.UsedVars) (s.OpenFlag e.Contrs) (e.Assigns)
    = (Success (e.UsedVars) s.OpenFlag (e.Contrs) (e.Assigns));
}

/* Проверка на эквивалентность */

Eq {
  (e.X) (e.X) = True;

  e.Other = False
}

/* Проверка на параметризованный символ */

IsSVarSubset {
  (Symbol s.Type e.Info) = True;
  (Var 's' e.Tindex) = True;
  (Closure e.Body) = True;
  (ClosureBrackets e.Context) = True;

  t.OtherTerm = False;
}

/* Проверка на терм */

IsTerm {
  (Var 'e' e.Index) = False;

  /* Рассматриваем для оптимизаций встраивания, прогонки и специализации */
  (CallBrackets e.Nested) = False;
  (ColdCallBrackets e.Nested) = False;

  /* Метки координат не будем считать термами */
  ('{'s.Coord'}') = False;

  /* s-, t-переменная, скобки обоих видов, символ */
  t.OtherTerm = True;
}

AddContractions-Spec-Symm {
  (t.toAdd e.Rest) (e.Contrs) e.SymmClashes (e.Assigns)
    = <AddContractions-Spec-Symm
        (e.Rest)
        <AddContraction-Spec-Symm
          t.toAdd
          (e.Contrs)
          e.SymmClashes
          (e.Assigns)
        >
      >;

  () e.PRTC = e.PRTC;
}

/*
  Добавление сужения к PRTC

  <AddContraction t.toAdd (t.Contraction*) t.Equation* (t.Assign*)>
   == PRTC
*/

AddContraction-Spec {
  t.toAdd (s.OpenFlag e.Contrs) e.Clashes (e.Assigns)
    = t.toAdd
    : {
        ((Var 'e' e._) ':' (Var 'e' e._) (Var 'e' e._)) = AfterOpen;

        ((Var 'e' e._) ':' (Var 'e' e._) (Var 't' e._) (Var 'e' e._))
          = AfterOpen;

        t._ = s.OpenFlag;
      }
    : s.OpenFlag^
    = <SimplifyCoordinates
        (
          s.OpenFlag
          <Map (&ApplyContraction-toContraction t.toAdd) e.Contrs>
        )
        <Map (&ApplyContraction-toEquation t.toAdd) e.Clashes>
        (<Map (&ApplyContraction-toAssign t.toAdd) e.Assigns>)
      >;
}

AddContraction-Spec-Symm {
  t.toAdd (s.OpenFlag e.Contrs) e.SymmClashes (e.Assigns)
    = t.toAdd
    : {
        ((Var 'e' e._) ':' (Var 'e' e._) (Var 'e' e._)) = AfterOpen;

        ((Var 'e' e._) ':' (Var 'e' e._) (Var 't' e._) (Var 'e' e._))
          = AfterOpen;

        t._ = s.OpenFlag;
      }
    : s.OpenFlag^
    = <SimplifyCoordinates-Symm
        (
          s.OpenFlag
          <Map (&ApplyContraction-toContraction t.toAdd) e.Contrs>
        )
        <Map (&ApplyContraction-toSymmClash t.toAdd) e.SymmClashes>
        (<Map (&ApplyContraction-toAssign t.toAdd) e.Assigns>)
      >;
}

/*
  Применение сужения к другому сужению

  <ApplyContraction-toContraction t.Contr t.OtherContr> == t.OtherContr^
*/

ApplyContraction-toContraction {
  t.Contr (t.Var ':' e.Right)
    = (t.Var ':' <ApplyContraction-toExpr t.Contr e.Right>);
}

/*
  Применение сужения к присваиванию

  <ApplyContraction-toAssign t.Contraction t.Assign == t.Assign
*/

ApplyContraction-toAssign {
   t.Contraction (e.M ':' t.Rval)
     = (<ApplyContraction-toExpr t.Contraction e.M> ':' t.Rval);
}

/*
   Применение сужения к уравнению

   <ApplyContraction-toEquation t.Contraction t.Equation> == t.Equation
*/

ApplyContraction-toEquation {
   t.Contraction ((e.Expr) ':' (e.Lexpr)) =
     ((<ApplyContraction-toExpr t.Contraction e.Expr>) ':' (e.Lexpr))
}

ApplyContraction-toSymmClash {
  t.Contr (e.L '=' e.R)
    = (
        <ApplyContraction-toExpr t.Contr e.L>
        '='
        <ApplyContraction-toExpr t.Contr e.R>
      )
    : {
        /* стираем тавтологию */
        t.SymmClash, <IsTautology t.SymmClash> : True = /* пусто */;

        t.SymmClash = t.SymmClash;
      }
}

/*
    Применение сужения к выражению

    <ApplyContraction-toExpr t.Contraction e.Expr> == e.Expr
*/

ApplyContraction-toExpr {
   (t.Var ':' e.Lval) e.B t.Var e.E =
     <ApplyContraction-toExpr (t.Var ':' e.Lval) e.B>
     e.Lval
     <ApplyContraction-toExpr (t.Var ':' e.Lval) e.E>;

   t.Contraction e.B (Brackets e.M) e.E =
     <ApplyContraction-toExpr t.Contraction e.B>
     (Brackets <ApplyContraction-toExpr t.Contraction e.M>)
     <ApplyContraction-toExpr t.Contraction e.E>;

   t.Contraction e.B (ADT-Brackets e.M) e.E =
     <ApplyContraction-toExpr t.Contraction e.B>
     (ADT-Brackets <ApplyContraction-toExpr t.Contraction e.M>)
     <ApplyContraction-toExpr t.Contraction e.E>;

   t.Contraction e.Expr = e.Expr
}

/*
  Проверка на то, что выражение содержит
  метки координат на верхнем уровне
*/

HasTopLevelCoordinateLabels {
  e.Begin ('{'s.M'}') e.End = True;

  e.Other = False
}
