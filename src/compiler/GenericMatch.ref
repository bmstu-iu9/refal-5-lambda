$INCLUDE "LibraryEx";

*$FROM TreeUtils
$EXTERN ExtractVariables, NewVarName, ApplyContractions;


gen_e__ { e.arg = e.arg }


/**
  <GenericMatch (e.Pattern) (e.LPattern)>
    == Clear (e.Val ':' t.Var)*
    == Contracted ((t.Var ':' e.Val)* (e.Val ':' t.Var))*
    == Failure
    == Undefined

  e.Pattern, e.LPattern ::= t.PatternTerm*
  t.PatternTerm — см. src/compiler/README.md

  e.Val ::= t.PatternTerm*
  t.Var ::= (s.VarType e.Index)
  s.VarType ::= 's' | 't' | 'e'
*/

FormatAssigns {
  e.Assigns =
    <Map
      {
        (e.Left ':' (Var e.Index)) = (e.Left ':' (e.Index))
      }
      e.Assigns
    >
}

$ENTRY GenericMatch {
  (e.Pattern) (e.LPattern)
    = <Solve-Drive
        (<ExtractVariables ((e.Pattern e.LPattern) (/* пусто */))>)
        ((e.Pattern) ':' (e.LPattern))
      >
    : {
        /* Если все решения без сужений, то берём первое */
        Success (e._ () (e.Assigns)) e.OtherSolutions
          , <AllUncontracted e.OtherSolutions> : True
          = Clear <FormatAssigns e.Assigns>;

        Success /* пусто */ = Failure;

        Success e.Solutions = Contracted e.Solutions;

        Undefined = Undefined;
      }
}

AllUncontracted {
  e.Solutions
    = <Map
        {
          (e._ (/* нет суженй */) (e._)) = /* пропускаем */;
          t.OtherSolution = t.OtherSolution; /* оставляем */
        }
        e.Solutions
      >
    : {
        /* пусто */ = True;
        e._ = False;
      }
}

/**
  <Solve-Drive (e.UsedVars) t.Equation>
    == Success t.Result* | Undefined

    t.Contr ::= (t.Var ':' e.Val)
    t.Equation ::= ((e.Expr) ':' (e.LExpr))
    t.Assign ::= (e.Val ':' t.Var)
    t.Result ::= (e.UsedVars^ (t.Contr*) (t.Assign*))
*/

$ENTRY Solve-Drive {
  (e.UsedVars) ((e.Expr) ':' (e.Lexpr))
    = <AddCoordinateLabels e.Expr> : e.Expr^
    = <Solve-Clashes
        (e.UsedVars)
        (None <gen_e__ /* сужения */>)
        ((e.Expr) ':' (e.Lexpr))
        (<gen_e__ /* присваивания */>)
      >
    : {
        e._ (Generalize (e.Intervals)) e._ = Undefined;
        e._ (Success (e._) AfterOpen (e._) (e._)) e._ = Undefined;

        e.Success = Success <CombineResults-Drive e.Success>;
      };
}

/* Проверка на наличие поднятого флага в решениях */

IsFlagOpen {
  e._ (Success (e._) AfterOpen (e._) (e._)) e._ = True;

  e._ = False;
}

/*
  Преобразует решения в нужный формат для Solve-Drive

  <CombineResults-Drive e.RawSol*> == t.Sol*

  t.Sol ::= (e.UsedVars (t.Contr*) (t.Assign*))
  e.RawSol ::= (Success (e.UsedVars) s.OpenFlag (t.Contr*) (t.Assign*))
*/
CombineResults-Drive {
  e.RawSolutions
    = <Map
        {
          (Success (e.UsedVars) s.OpenFlag (e.Contrs) (e.Assigns))
            = <Map
                {
                  (e.Val ':' t.Var) = (<ClearCoordinates e.Val> ':' t.Var)
                }
                e.Assigns
              >
            : e.Assigns^
            = (e.UsedVars (e.Contrs) (e.Assigns));
        }
        e.RawSolutions
      >;
}

/**
  <Solve-Spec (e.UsedVars) (e.Left) (e.Right)>
    == (e.UsedVars^) ((t.Contr*) (t.Assign*))* (t.Assign*) (e.Left^)

  t.Contr ::= (t.Var ':' e.Val)
  t.Assign ::= (e.Val ':' t.Var)
*/

$ENTRY Solve-Spec {
  (e.UsedVars) (e.Left) (e.Right)
    = <AddCoordinateLabels e.Left> : e.Left^
    = <Solve-Spec-DoFindGeneralization
        (e.UsedVars)
        ((e.Left) ':' (e.Right))
        ()
      >;
}

Solve-Spec-DoFindGeneralization {
  (e.UsedVars) ((e.L) ':' (e.R)) (e.GenAssigns)
    = <Solve-Clashes
        (e.UsedVars)
        (None /* сужения */)
        ((e.L) ':' (e.R))
        (/* присваивания */)
      >
    : {
        e._ (Generalize (e.Intervals)) e._
          = <DoGeneralize
              (e.UsedVars) <UnionIfIntersect (e.Intervals)>
              (<gen_e__ e.L>) (<gen_e__ e.GenAssigns>)
            >
          : (e.UsedVars^) (e.L^) (e.GenAssigns^)
          = <Solve-Spec-DoFindGeneralization
              (e.UsedVars) ((e.L) ':' (e.R)) (e.GenAssigns)
            >;

        e.Success
          = (e.UsedVars)
            <CombineResults-Spec e.Success>
            (e.GenAssigns)
            (<ClearCoordinates e.L>);
      }
}

/*
  Объединяет два интервала, если они пересекаются.
  В остальных случаях возвращает исходный список интервалов.

  <UnionIfIntersect (e.Intervals)> == (e.Intervals^)

  e.Intervals ::= t.Interval+
  t.Interval ::= ('{' s.BeginCoord s.EndCoord '}')
*/

UnionIfIntersect {
  (t.Interval-1 t.Interval-2)
    , <HasIntersection (t.Interval-1 t.Interval-2)> : True
    = t.Interval-1 : ('{' s.A s.B '}')
    = t.Interval-2 : ('{' s.C s.D '}')
    = <GetExtremum s.A '+' (s.B s.C s.D)> : s.Min
    = <GetExtremum s.A '-' (s.B s.C s.D)> : s.Max
    = (('{' s.Min s.Max '}'));

  t.Intervals = t.Intervals;
}

HasIntersection {
  (('{' s.A s.B '}') ('{' s.C s.D '}'))
    , <Compare s.C s.B> : '+'
    = False;

  (('{' s.A s.B '}') ('{' s.C s.D '}'))
    , <Compare s.A s.D> : '+'
    = False;

  t.Intervals = True;
}

GetExtremum {
  s.Extremum s.Sign (s.CurrentCoord e.Rest)
    , <Compare s.Extremum s.CurrentCoord> : s.Sign
    = <GetExtremum s.CurrentCoord s.Sign (e.Rest)>;

  s.Extremum s.Sign (s.CurrentCoord e.Rest)
    = <GetExtremum s.Extremum s.Sign (e.Rest)>;

  s.Extremum s.Sign (/* пусто */)
    = s.Extremum;
}

/*
  Преобразует решения в нужный формат для Solve-Spec

  <CombineResults-Spec e.RawSol*> == t.Sol*

  t.Sol ::= ((t.Contr*) (t.Assign*))
  e.RawSol ::= (Success (e.UsedVars) s.OpenFlag (t.Contr*) (t.Assign*))
*/

CombineResults-Spec {
  e.RawSolutions
    = <Map
        {
          (Success (e.UsedVars) s.OpenFlag (e.Contrs) (e.Assigns))
            = <Map
                {
                  (e.Val ':' t.Var) = (<ClearCoordinates e.Val> ':' t.Var)
                }
                e.Assigns
              >
            : e.Assigns^
            = ((e.Contrs) (e.Assigns));
        }
        e.RawSolutions
      >;
}

/*
  Функция, выполняющая динамическое обобщение

  <DoGeneralize (e.UsedVars) (t.Interval*) (e.Expr) (t.Assign*)>
    == (e.UsedVars^) (e.Expr^) (t.Assign*)

  t.Interval ::= ('{' s.A s.B '}')
*/

DoGeneralize {
  (e.UsedVars) (t.Interval e.Intervals) (e.Expr) (e.Assigns)
    = <DoGeneralize-Rec
        (e.UsedVars) t.Interval (<gen_e__ /* scanned */>) (e.Expr) (e.Assigns)
      >
    : (e.UsedVars^) (e.Expr^) (e.Assigns^)
    = <DoGeneralize (e.UsedVars) (e.Intervals) (e.Expr) (e.Assigns)>;

  (e.UsedVars) (/* кончились интервалы */) (e.Expr) (e.Assigns)
    = (e.UsedVars) (e.Expr) (e.Assigns);
}

DoGeneralize-Rec {
  (e.UsedVars) ('{' s.A s.B '}')
  (e.Begin) (e.E1 ('{'s.A'}') e.Inner ('{'s.B'}') e.E2) (e.Assigns)
    = <GetVarType e.Inner> : s.VarType
    = <ClearCoordinates
        <ApplyAssignments-toExpr (e.Assigns) e.Inner>
      >
    : e.VarVal
    = <NewVarName (e.UsedVars) s.VarType> : (e.UsedVars^) s.VarType^ e.New
    = (e.UsedVars)
      (e.Begin e.E1 ('{'s.A'}') (Var s.VarType e.New) ('{'s.B'}') e.E2)
      ((e.VarVal ':' (Var s.VarType e.New)) e.Assigns);

  (e.UsedVars) t.Interval
  (e.Begin) ((Brackets e.Nested) e.Rest) (e.Assigns)
    = <DoGeneralize-Rec
        (e.UsedVars) t.Interval (/* scanned */) (e.Nested) (e.Assigns)
      >
    : (e.UsedVars^) (e.Nested^) (e.Assigns^)
    = <DoGeneralize-Rec
        (e.UsedVars) t.Interval
        (e.Begin (Brackets e.Nested)) (e.Rest) (e.Assigns)
      >;

  (e.UsedVars) t.Interval (e.Begin)
  ((ADT-Brackets (e.Name) e.Nested) e.Rest) (e.Assigns)
    = <DoGeneralize-Rec
        (e.UsedVars) t.Interval (/* scanned */) (e.Nested) (e.Assigns)
      >
    : (e.UsedVars^) (e.Nested^) (e.Assigns^)
    = <DoGeneralize-Rec
        (e.UsedVars) t.Interval
        (e.Begin (ADT-Brackets (e.Name) e.Nested)) (e.Rest) (e.Assigns)
      >;

  (e.UsedVars) t.Interval (e.Begin) (t.T e.Rest) (e.Assigns)
    = <DoGeneralize-Rec
        (e.UsedVars) t.Interval (e.Begin t.T) (e.Rest) (e.Assigns)
      >;

  (e.UsedVars) t.Interval (e.Begin) () (e.Assigns)
    = (e.UsedVars) (e.Begin) (e.Assigns);
}

/* Определяет тип переменной, до которой выполнится динамическое обобщение */

GetVarType {
  (ClosureBrackets e._) = 's';

  e.Other = 'e';
}

* TODO: присваивания должны быть параллельными
ApplyAssignments-toExpr {
  (t.Assign e.Rest) e.Expr
    = <ApplyAssignments-toExpr
        (e.Rest)
        <ApplyAssignment-toExpr t.Assign e.Expr>
      >;

  () e.Expr = e.Expr;
}

ApplyAssignment-toExpr {
  (e.Val ':' (s.Type e.Index)) e.Begin (Var s.Type e.Index) e.End
    = <ApplyAssignment-toExpr (e.Val ':' (s.Type e.Index)) e.Begin>
      e.Val
      <ApplyAssignment-toExpr (e.Val ':' (s.Type e.Index)) e.End>;

  t.Assign e.Begin (Brackets e.E) e.End
    = <ApplyAssignment-toExpr t.Assign  e.Begin>
      (Brackets <ApplyAssignment-toExpr t.Assign e.E>)
      <ApplyAssignment-toExpr t.Assign e.End>;

  t.Assign e.Begin (ADT-Brackets e.E) e.End
    = <ApplyAssignment-toExpr t.Assign e.Begin>
      (ADT-Brackets <ApplyAssignment-toExpr t.Assign e.E>)
      <ApplyAssignment-toExpr t.Assign e.End>;

  t.Assign e.E = e.E;
}

/*
  Добавляет в левую часть уравнения метки координат

  <AddCoordinateLabels e.Expr> == e.Expr^
  <DoAddCoordinateLabels (e.Expr) s.CoordsNumber> == e.Expr^

  t.CoordinateLabel ::= ('{'s.CoordNumber'}')
*/

AddCoordinateLabels {
  /* пусто */ = /* пусто */;

  e.Expr = ('{'1'}') <DoAddCoordinateLabels (e.Expr) 2>
}

DoAddCoordinateLabels {
  ((Symbol s.SymType e.SymInfo) e.Rest) s.CoordNumber
    = (Symbol s.SymType e.SymInfo) ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Rest) <Add s.CoordNumber 1>>;

  ((Var s.Mode e.Index) e.Rest) s.CoordNumber
    = (Var s.Mode e.Index) ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Rest) <Add s.CoordNumber 1>>;

  ((ScrVar s.Mode e.Index) e.Rest) s.CoordNumber
    = (ScrVar s.Mode e.Index) ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Rest) <Add s.CoordNumber 1>>;

  ((ClosureBrackets e.Inner) e.Rest) s.CoordNumber
    = (ClosureBrackets e.Inner) ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Rest) <Add s.CoordNumber 1>>;

  ((CallBrackets e.Inner) e.Rest) s.CoordNumber
    = (CallBrackets e.Inner) ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Rest) <Add s.CoordNumber 1>>;

  ((ColdCallBrackets e.Inner) e.Rest) s.CoordNumber
    = (CallBrackets e.Inner) ('{'s.CoordNumber'}')
      <DoAddCoordinateLabels (e.Rest) <Add s.CoordNumber 1>>;

  ((Brackets e.Expr) e.Rest) s.CoordNumber
    = (Brackets
        ('{'s.CoordNumber'}')
        <DoAddCoordinateLabels (e.Expr) <Add s.CoordNumber 1>>
      )
    : {
        (Brackets e.Inner ('{'s.LastCoord'}'))
          = (Brackets e.Inner ('{'s.LastCoord'}'))
            ('{'<Add s.LastCoord 1>'}')
            <DoAddCoordinateLabels (e.Rest) <Add s.LastCoord 2>>
      };

  ((ADT-Brackets (e.Name) e.Expression) e.Rest) s.CoordNumber
    = (ADT-Brackets
        (e.Name) ('{'s.CoordNumber'}')
        <DoAddCoordinateLabels (e.Expression) <Add s.CoordNumber 1>>
      )
    : {
        (ADT-Brackets e.Inner ('{'s.LastCoord'}'))
          = (ADT-Brackets e.Inner ('{'s.LastCoord'}'))
            ('{'<Add s.LastCoord 1>'}')
            <DoAddCoordinateLabels (e.Rest) <Add s.LastCoord 2>>
      };

  (/* пусто */) s.CoordNumber = /* пусто */;
}

/*
  Упрощение координат (редуцирование их бессмысленного скопления)
*/

SimplifyCoordinates-SymmClash {
  (e.L '=' e.R) = (<SimplifyCoordinates e.L> '=' <SimplifyCoordinates e.R>)
}

SimplifyCoordinates {
  /* {k} {m} E {n}  ↦  {m} E {n} */
  ('{'s.K'}') ('{'s.M'}') e.E ('{'s.N'}')
    = <SimplifyCoordinates ('{'s.M'}') e.E ('{'s.N'}')>;

  /* {k} E {m} {n}  ↦  {k} E {m} */
  ('{'s.K'}') e.E ('{'s.M'}') ('{'s.N'}')
    = <SimplifyCoordinates ('{'s.K'}') e.E ('{'s.M'}')>;

  /* {m} {n}  ↦  ε */
  ('{'s.M'}') ('{'s.N'}')
    = /* пусто */;

  ('{'s.M'}') e.E ('{'s.N'}') = ('{'s.M'}') e.E ('{'s.N'}');

  /* пусто */ = /* пусто */;
}

/*
  <Solve-Clashes (e.UsedVars) (e.Contractions) t.Clash* (t.Assign*)>
    == t.Result*

    e.Contractions ::= s.OpenFlag t.Contr*
    s.OpenFlag ::= None | AfterOpen
    t.Contr ::= (t.Var ':' e.Val)
    t.Clash ::= ((e.L) ':' (e.R))
    t.Assign ::= (e.Val ':' t.Var)
    t.Result
      ::= (Success (e.UsedVars) s.OpenFlag (t.Contr*) (t.Assign*))
      |   (Generalize ( ('{' s.BeginCoord s.EndCoord '}')+ ))
*/

Solve-Clashes {
  /* {m} T {n} : t.X   ↦  {m} T {n} ← t.X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.T ('{'s.N'}')) ':' ((Var 't' e.Index)))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    = <Solve-Clashes
        (e.UsedVars)
        (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (<gen_e__ e.Assigns (('{'s.M'}') t.T ('{'s.N'}') ':' (Var 't' e.Index))>)
      >;

  /* {m} Sym {n} : s.X   ↦  {m} Sym {n} ← s.X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.Sym ('{'s.N'}')) ':' ((Var 's' e.Index)))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Sym> : True
    = <Solve-Clashes
        (e.UsedVars)
        (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (
          <gen_e__
            e.Assigns (('{'s.M'}') t.Sym ('{'s.N'}') ':' (Var 's' e.Index))
          >
        )
      >;

  /* {m} #var {n} : s.X   ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (ScrVar e._) ('{'s.N'}')) ':' ((Var 's' e.Index)))
  e.ClashesEnd (e.Assigns)
    = /* нет решений */;

  /* {m} (E) {n} : (P)   ↦  {m} E {n} : P */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (Brackets e.LBody) ('{'s.N'}')) ':' ((Brackets e.RBody)))
  e.ClashesEnd (e.Assigns)
    = <Solve-Clashes
        (e.UsedVars)
        (e.Contrs) e.ClashesStart
        ((<SimplifyCoordinates ('{'s.M'}') e.LBody ('{'s.N'}')>) ':' (e.RBody))
        e.ClashesEnd (e.Assigns)
      >;

  /* {m} [X E] {n} : [X P]   ↦  {m} [X E] {n} : P */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (
    (('{'s.M'}') (ADT-Brackets (e.Name) e.LBody) ('{'s.N'}'))
    ':' ((ADT-Brackets (e.Name) e.RBody))
  )
  e.ClashesEnd (e.Assigns)
    = <Solve-Clashes
        (e.UsedVars)
        (e.Contrs) e.ClashesStart
        ((<SimplifyCoordinates ('{'s.M'}') e.LBody ('{'s.N'}')>) ':' (e.RBody))
        e.ClashesEnd (e.Assigns)
      >;

  /* {m} [X E] {n} : [Y P]  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (ADT-Brackets e._) ('{'s.N'}')) ':' ((ADT-Brackets e._)))
  e.ClashesEnd (e.Assigns)
    = /* нет решений */;

  /* {m} [X E] {n} : (P)  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (ADT-Brackets e._) ('{'s.N'}')) ':' ((Brackets e._)))
  e.ClashesEnd (e.Assigns)
    = /* нет решений */;

  /* {m} (E) {n} : [X P]  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (Brackets e._) ('{'s.N'}')) ':' ((ADT-Brackets e._)))
  e.ClashesEnd (e.Assigns)
    = /* нет решений */;

  /* {m} (E) {n} : Psym  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (Brackets e._) ('{'s.N'}')) ':' (t.Psym))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Psym> : True
    = /* нет решений */;

  /* {m} [X E] {n} : Psym  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (ADT-Brackets e._) ('{'s.N'}')) ':' (t.Psym))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Psym> : True
    = /* нет решений */;

  /* {m} Sym {n} : (P)  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.Sym ('{'s.N'}')) ':' ((Brackets e._)))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Sym> : True
    = /* нет решений */;

  /* {m} #var {n} : (P)  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (ScrVar e._) ('{'s.N'}')) ':' ((Brackets e._)))
  e.ClashesEnd (e.Assigns)
    = /* нет решений */;

  /* {m} Sym {n} : [X P]  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.Sym ('{'s.N'}')) ':' ((ADT-Brackets e._)))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Sym> : True
    = /* нет решений */;

  /* {m} #var {n} : [X P]  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (ScrVar e._) ('{'s.N'}')) ':' ((ADT-Brackets e._)))
  e.ClashesEnd (e.Assigns)
    = /* нет решений */;

  /* {m} t.X {n} : (P)  ↦  t.X → (e.NEW) */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (Var 't' e.Index) ('{'s.N'}')) ':' ((Brackets e.PBody)))
  e.ClashesEnd (e.Assigns)
    = <NewVarName (e.UsedVars) 'e' e.Index> : t.NewVars 'e' e.NewIndex
    = <Solve-Clashes
        t.NewVars
        <AddContraction-Spec
          ((Var 't' e.Index) ':' (Brackets (Var 'e' e.NewIndex)))
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') (Var 't' e.Index) ('{'s.N'}')) ':' ((Brackets e.PBody)))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m} t.X {n} : [X P]   ↦  t.X → [X e.NEW] */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (
    (('{'s.M'}') (Var 't' e.Index) ('{'s.N'}'))
    ':' ((ADT-Brackets (e.Name) e.PBody))
  )
  e.ClashesEnd (e.Assigns)
    = <NewVarName (e.UsedVars) 'e' e.Index> : t.NewVars 'e' e.NewIndex
    = <Solve-Clashes
        t.NewVars
        <AddContraction-Spec
          ((Var 't' e.Index) ':' (ADT-Brackets (e.Name) (Var 'e' e.NewIndex)))
          (e.Contrs) e.ClashesStart
          (
            (('{'s.M'}') (Var 't' e.Index) ('{'s.N'}'))
            ':' ((ADT-Brackets (e.Name) e.PBody))
          )
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m} t.X {n} : Psym  ↦  t.X → s.NEW */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (Var 't' e.Index) ('{'s.N'}')) ':' (t.Psym))
  e.ClashesEnd (e.Assigns)
    , <IsSVarSubset t.Psym> : True
    = <NewVarName (e.UsedVars) 's' e.Index> : t.NewVars 's' e.NewIndex
    = <Solve-Clashes
        t.NewVars
        <AddContraction-Spec
          ((Var 't' e.Index) ':' (Var 's' e.NewIndex))
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') (Var 't' e.Index) ('{'s.N'}')) ':' (t.Psym))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m} s.X {n} :  X  ↦  s.X → X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (Var 's' e.Index) ('{'s.N'}')) ':' ((Symbol s.Type e.Info)))
  e.ClashesEnd (e.Assigns)
    = <Solve-Clashes
        (e.UsedVars)
        <AddContraction-Spec
          ((Var 's' e.Index) ':' (Symbol s.Type e.Info))
          (e.Contrs) e.ClashesStart
          /* TODO: заведомая тавтология */
          (
            (('{'s.M'}') (Var 's' e.Index) ('{'s.N'}'))
            ':' ((Symbol s.Type e.Info))
          )
          e.ClashesEnd (e.Assigns)
        >
      >;

  /*  {m} X {n}  :  X    ↦  стираем */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (Symbol s.Type e.Info) ('{'s.N'}')) ':' ((Symbol s.Type e.Info)))
  e.ClashesEnd (e.Assigns)
    = <Solve-Clashes
        (e.UsedVars)
        (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (e.Assigns)
      >;

  /*  {m} X {n}  :  Y    ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (Symbol e._) ('{'s.N'}')) ':' ((Symbol e._)))
  e.ClashesEnd (e.Assigns)
    = /* нет решений */;

  /*  {m} #var {n}  :  Y    ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (ScrVar e._) ('{'s.N'}')) ':' ((Symbol e._)))
  e.ClashesEnd (e.Assigns)
    = /* нет решений */;

  /*
    {m} {{ &F e.X }} {n} : Pt  ↦  нет решений

    Случаи
    — {m} {{ &F e.X }} {n} : t.X
    — {m} {{ &F e.X }} {n} : s.X
    перехватываются предложениями выше
  */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (ClosureBrackets e._) ('{'s.N'}')) ':' (t.T))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    = /* решений нет */;

  /* E : e.X  ↦  E ← e.X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((e.E) ':' ((Var 'e' e.Index)))
  e.ClashesEnd (e.Assigns)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (<gen_e__ e.Assigns (e.E ':' (Var 'e' e.Index))>)
      >;

  /* {m} e.X E {n} : ε  ↦  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (Var 'e' e.Index) e.E ('{'s.N'}')) ':' (/* пусто */))
  e.ClashesEnd (e.Assigns)
    = <Solve-Clashes
        (e.UsedVars)
        <AddContraction-Spec
          ((Var 'e' e.Index) ':' /* пусто */)
          (e.Contrs) e.ClashesStart
          ((('{'s.M'}') (Var 'e' e.Index) e.E ('{'s.N'}')) ':' (/* пусто */))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m}  T E  {n} : ε  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.T e.E ('{'s.N'}')) ':' (/* пусто */))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    = /* решений нет */;

  /* ε : E1 Pt E2  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((/* пусто */) ':' (e.E1 t.Pt e.E2))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.Pt> : True
    = /* решений нет */;

  /* ε : ε  ↦  стираем */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((/* пусто */) ':' (/* пусто */))
  e.ClashesEnd (e.Assigns)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        e.ClashesStart e.ClashesEnd
        (e.Assigns)
      >;

  /* {m} T {n} E : Pt P   ↦  {m} T {n} : Pt  &&  {n} E : P */
  /* {m} T E* {n} E : Pt P   ↦  {m} T {n} : Pt  &&  {m} E* {n} E : P */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') t.T e.E) ':' (t.Pt e.P))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , <IsTerm t.Pt> : True
    = <SeparateTermLeft ('{'s.M'}') t.T e.E> : (e.Left1) (e.Left2)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        <gen_e__
          e.ClashesStart
          ((e.Left1) ':' (t.Pt))
          ((e.Left2) ':' (e.P))
          e.ClashesEnd
        >
        (e.Assigns)
      >;

  /* E {m} T {n} : P  Pt  ↦  E {m} : P   &&  {m} T {n} : Pt */
  /* E {m} E* T {n} : P  Pt  ↦  E {m} E* {n} : P   &&  {m} T {n} : Pt */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((e.E t.T ('{'s.N'}')) ':' (e.P t.Pt))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , <IsTerm t.Pt> : True
    = <SeparateTermRight e.E t.T ('{'s.N'}')> : (e.Left1) (e.Left2)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        <gen_e__
          e.ClashesStart
          ((e.Left1) ':' (e.P))
          ((e.Left2) ':' (t.Pt))
          e.ClashesEnd
        >
        (e.Assigns)
      >;

  /* {m} e.X E {n} : Pt P   ↦  e.X → t.NEW1 e.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') (Var 'e' e.Index) e.E ('{'s.N'}')) ':' (t.Pt e.P))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.Pt> : True
    = <NewVarName (e.UsedVars) 't' e.Index> : t.NewVars1 't' e.New1
    = <NewVarName t.NewVars1 'e' e.Index> : t.NewVars2 'e' e.New2
    = <AddContraction-Spec
        ((Var 'e' e.Index) ':' (Var 't' e.New1) (Var 'e' e.New2))
        (e.Contrs)
        <gen_e__
          e.ClashesStart
          ((('{'s.M'}') (Var 'e' e.Index) e.E ('{'s.N'}')) ':' (t.Pt e.P))
          e.ClashesEnd
        >
        (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec
        ((Var 'e' e.Index) ':' /* пусто */)
        (e.Contrs)
        <gen_e__
          e.ClashesStart
          ((('{'s.M'}') (Var 'e' e.Index) e.E ('{'s.N'}')) ':' (t.Pt e.P))
          e.ClashesEnd
        >
        (e.Assigns)
      >
    : e.Branch2
    = <Solve-Clashes t.NewVars2 e.Branch1>
      <Solve-Clashes (e.UsedVars) e.Branch2>;

  /* {m} E e.X {n} : P  Pt  ↦  e.X → e.NEW1 t.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  ((('{'s.M'}') e.E (Var 'e' e.Index) ('{'s.N'}')) ':' (e.P t.Pt))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.Pt> : True
    = <NewVarName (e.UsedVars) 'e' e.Index> : t.NewVars1 'e' e.New1
    = <NewVarName t.NewVars1 't' e.Index> : t.NewVars2 't' e.New2
    = <AddContraction-Spec
        ((Var 'e' e.Index) ':' (Var 'e' e.New1) (Var 't' e.New2))
        (e.Contrs)
        <gen_e__
          e.ClashesStart
          ((('{'s.M'}') e.E (Var 'e' e.Index) ('{'s.N'}')) ':' (e.P t.Pt))
          e.ClashesEnd
        >
        (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec
        ((Var 'e' e.Index) ':' /* пусто */)
        (e.Contrs)
        <gen_e__
          e.ClashesStart
          ((('{'s.M'}') e.E (Var 'e' e.Index) ('{'s.N'}')) ':' (e.P t.Pt))
          e.ClashesEnd
        >
        (e.Assigns)
      >
    : e.Branch2
    = <Solve-Clashes t.NewVars2 e.Branch1>
      <Solve-Clashes (e.UsedVars) e.Branch2>;

  /* могли остаться только клэши вида E : e.X P e.Y */
  (e.UsedVars) (s.OpenFlag e.Contrs)
  ((e.E) ':' ((Var 'e' e._) e.P (Var 'e' e._)))
  e.ClashesEnd (e.Assigns)
    , e.E : ('{'s.M'}') e.Inner ('{'s.N'}')
    , <IsLeftPartTrivial e.E> : False
    , s.OpenFlag : AfterOpen
    = (Generalize (('{' s.M s.N '}')));

  (e.UsedVars) (e.Contrs)
  ((('{'s.M'}') t.eVar ('{'s.N'}')) ':' ((Var 'e' e._) e.P (Var 'e' e._)))
  e.ClashesEnd (e.Assigns)
    , t.eVar : (Var 'e' e.Index)
    , <IsVarInAssigns t.eVar (e.Assigns)> : True
    = (Generalize (('{' s.M s.N '}')));

  (e.UsedVars) (e.Contrs)
  ((e.E) ':' ((Var 'e' e.OpenIndex) e.P (Var 'e' e.ClosedIndex)))
  e.ClashesEnd (e.Assigns)
    = <SplitLeftPart e.E> : (e.Parts)
    = <Map
        {
          t.Part
            = <SplitSolve
                (e.UsedVars) (e.Contrs)
                (t.Part ':' ((Var 'e' e.OpenIndex) e.P (Var 'e' e.ClosedIndex)))
                e.ClashesEnd (<gen_e__ e.Assigns>)
              >
        }
        e.Parts
      >;

  /* клэши закончились */
  (e.UsedVars) (e.Contrs) (e.Assigns)
    = <CreateSymmClashes (e.Contrs) (e.Assigns)> : (e.Assigns^) (e.SymmClashes)
    = <Solve-SymmClashes
        (e.UsedVars) (e.Contrs)
        e.SymmClashes
        (e.Assigns)
      >;

  /* все остальное будет трактоваться как противоречие */
  (e.UsedVars) (e.Contrs) e.Clashes (e.Assigns)
    = /* решений нет */;
}

/*
  Проверяет на тривиальность левую часть клэша с открытой переменной

  <IsLeftPartTrivial e.LeftPart> == True | False
*/

IsLeftPartTrivial {
  ('{'s.M'}') (Var 'e' e._) ('{'s.N'}') = True;

  /* пусто */ = True;

  e.Other = False;
}

/*
  Проверяет, встречается ли переменная в левой части какого-нибудь присваивания

  <IsVarInAssigns t.Var (t.Assign*)> == True | False
*/

IsVarInAssigns {
  t.Var ((e.Expr ':' t._) e.Assigns)
    = <IsVarInExpr t.Var (e.Expr)>
    : {
        True = True;

        False = <IsVarInAssigns t.Var (e.Assigns)>;
      };

  t.Var (/* пусто */)
    = False;
}

IsVarInExpr {
  t.Var (t.Var e.End)
    = True;

  t.Var ((s.BracketsTag e.E) e.End)
    , <OneOf s.BracketsTag Brackets ADT-Brackets> : True
    = <IsVarInExpr t.Var (e.E)>
    : {
        True = True;

        False = <IsVarInExpr t.Var (e.End)>;
      };

  t.Var (t.Term e.End)
    = <IsVarInExpr t.Var (e.End)>;

  t.Var (/* пусто */)
    = False;
}

/*
  Разбивает левую часть клэша на список выражений,
  каждое из которых содержит одну точку разбиения

  <SplitLeftPart e.LeftPart>
    == (t.Part*)
  <SplitLeftPart-Aux (e.Begin) (e.Expr) (e.Parts)>
    == (t.Part*)

  t.Part ::= (e.LeftPartWithSplitPoint)
  t.SplitPoint ::= ('sp' e.Content)
*/

SplitLeftPart {
  /* Если E начинается на терм, то точка разбиения добавляется в начало */
  ('{'s.BeginCoord'}') t.T e.Rest
    , <IsTermOrScreenVar t.T> : True
    = <SplitLeftPart-Aux
        (('{'s.BeginCoord'}'))
        (t.T e.Rest)
        ((('sp' ('{'s.BeginCoord'}')) t.T e.Rest))
      >;

  ('{'s.BeginCoord'}') e.Rest
    = <SplitLeftPart-Aux
        (('{'s.BeginCoord'}'))
        (e.Rest)
        ()
      >;

  /* пусто */ = ((('sp')));
}

IsTermOrScreenVar {
  (ScrVar e._) = True;
  t.Other = <IsTerm t.Other>;
}

SplitLeftPart-Aux {
  /* Точки разбиения добавляются между двумя смежными термами */
  (e.Begin) (t.T1 t.T2 e.Rest) (e.Parts)
    , <IsTermOrScreenVar t.T1> : True
    , <IsTermOrScreenVar t.T2> : True
    = <SplitLeftPart-Aux
        (<gen_e__ e.Begin t.T1>)
        (t.T2 e.Rest)
        (<gen_e__ e.Parts (e.Begin t.T1 ('sp') t.T2 e.Rest)>)
      >;

  /* Точки разбиения добавляются между двумя смежными термами */
  (e.Begin) (t.T1 ('{'s.Coord'}') t.T2 e.Rest) (e.Parts)
    , <IsTermOrScreenVar t.T1> : True
    , <IsTermOrScreenVar t.T2> : True
    = <SplitLeftPart-Aux
        (<gen_e__ e.Begin t.T1 ('{'s.Coord'}')>)
        (t.T2 e.Rest)
        (<gen_e__ e.Parts (e.Begin t.T1 ('sp' ('{'s.Coord'}')) t.T2 e.Rest)>)
      >;

  /* Если E заканчивается на терм, то точка разбиения добавляется в конец */
  (e.Begin) (t.T ('{'s.Coord'}')) (e.Parts)
    , <IsTermOrScreenVar t.T> : True
    = (e.Parts (e.Begin t.T ('sp' ('{'s.Coord'}'))));

  (e.Begin) (t.T e.Rest) (e.Parts)
    , <IsTermOrScreenVar t.T> : True
    = <SplitLeftPart-Aux
        (<gen_e__ e.Begin t.T>)
        (e.Rest)
        (e.Parts)
      >;

  /* Точки разбиения находятся «внутри» e-параметров */
  (e.Begin) (t.eX e.Rest) (e.Parts)
    , t.eX : (Var 'e' e.XIndex)
    = <SplitLeftPart-Aux
        (<gen_e__ e.Begin t.eX>)
        (e.Rest)
        (<gen_e__ e.Parts (e.Begin ('sp' t.eX) e.Rest)>)
      >;

  (e.Begin) (('{'s.Coord'}') e.Rest) (e.Parts)
    = <SplitLeftPart-Aux
        (<gen_e__ e.Begin ('{'s.Coord'}')>)
        (e.Rest)
        (e.Parts)
      >;

  (e.Begin) () (e.Parts)
    = (e.Parts);
}

/*
  Разрешает систему клэшей для одной точки разбиения

  <SplitSolve
    (e.UsedVars) (e.Contractions)
    t.ClashWithSplitPoint t.Clash*
    (t.Assign*)
  > == t.Result*
*/

SplitSolve {
*  {m} E {n} : e.X P e.Y  ↦  ε ← e.X,  {m} E {n} : P e.Y
*   ↑
  (e.UsedVars) (e.Contrs)
  ((('sp' ('{'s.M'}')) e.E ('{'s.N'}')) ':' (t.eX e.P t.eY))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        <gen_e__ ((('{'s.M'}') e.E ('{'s.N'}')) ':' (e.P t.eY)) e.ClashesEnd>
        (<gen_e__ e.Assigns (/* пусто */ ':' t.eX)>)
      >;

*  {k} E1 T2 {m} T3 E4 {n} : e.X P e.Y  ↦  {k} E1 T2 {m} ← e.X,
*             ↑                            {m} T3 E4 {n} : P e.Y
  (e.UsedVars) (e.Contrs)
  (
    (
      ('{'s.K'}') e.E1 t.T2
      ('sp' ('{'s.M'}'))
      t.T3 e.E4 ('{'s.N'}')
    )
    ':' (t.eX e.P t.eY)
  )
  e.ClashesEnd (e.Assigns)
    , <IsTermOrScreenVar t.T2> : True
    , <IsTermOrScreenVar t.T3> : True
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        <gen_e__
          ((('{'s.M'}') t.T3 e.E4 ('{'s.N'}')) ':' (e.P t.eY)) e.ClashesEnd
        >
        (<gen_e__ e.Assigns (('{'s.K'}') e.E1 t.T2 ('{'s.M'}') ':' t.eX)>)
      >;

*  E1 {m} E2* T3 . T4 E5* {n} E6 : e.X P e.Y  ↦  E1 {m} E2* T3 {n} ← e.X,
*                ↑                               {m} T4 E5* {n} E6 : P e.Y
  (e.UsedVars) (e.Contrs)
  (
    (
      e.E1 ('{'s.M'}') e.E2
      t.T3 ('sp') t.T4
      e.E5 ('{'s.N'}') e.E6
    )
    ':' (t.eX e.P t.eY)
  )
  e.ClashesEnd (e.Assigns)
    , <HasTopLevelCoordinateLabels e.E2> : False
    , <IsTermOrScreenVar t.T3> : True
    , <IsTermOrScreenVar t.T4> : True
    , <HasTopLevelCoordinateLabels e.E5> : False
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        <gen_e__
          ((('{'s.M'}') t.T4 e.E5 ('{'s.N'}') e.E6) ':' (e.P t.eY)) e.ClashesEnd
        >
        (<gen_e__ e.Assigns (e.E1 ('{'s.M'}') e.E2 t.T3 ('{'s.N'}') ':' t.eX)>)
      >;

*  {m} E {n} : e.X P e.Y  ↦  {m} E {n} ← e.X,  ε : P e.Y
*         ↑
  (e.UsedVars) (e.Contrs)
  (
    (('{'s.M'}') e.E ('sp' ('{'s.N'}')))
    ':' (t.eX e.P t.eY)
  )
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        <gen_e__ ((/* пусто */) ':' (e.P t.eY)) e.ClashesEnd>
        (<gen_e__ e.Assigns (('{'s.M'}') e.E ('{'s.N'}') ':' t.eX)>)
      >;

*  ε : e.X P e.Y  ↦  ε ← e.X, ε : P e.Y
*  ↑
  (e.UsedVars) (e.Contrs)
  ((('sp')) ':' (t.eX e.P t.eY))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    = <Solve-Clashes
        (e.UsedVars) (e.Contrs)
        <gen_e__ ((/* пусто */) ':' (e.P t.eY)) e.ClashesEnd>
        (<gen_e__ e.Assigns (/* пусто */ ':' t.eX)>)
      >;

*  E1 e.X {m} e.Y E2 : e.L P e.R  ↦  e.X → e.NEW1! t.NEW2 e.NEW3,
*      ↑                              E1 e.NEW1! {m} ← e.L,
*                                     {n} t.NEW2 e.NEW3 {m} e.Y E2 : P e.R
*                  где E1 = E3 {n} E4*
  (e.UsedVars) (e.Contrs)
  ((e.E1 ('sp' t.eX) ('{'s.M'}') t.eY e.E2) ':' (t.eL e.P t.eR))
  e.ClashesEnd (e.Assigns)
    , e.E1 : e.E3 ('{'s.N'}') e.E4
    , <HasTopLevelCoordinateLabels e.E4> : False
    , t.eX : (Var 'e' e.XIndex)
    , t.eY : (Var 'e' e.YIndex)
    , t.eL : (Var 'e' e.LIndex)
    , t.eR : (Var 'e' e.RIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New1
    = <NewVarName (e.UsedVars) 't' e.XIndex> : (e.UsedVars^) 't' e.New2
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New3
    = (Var 'e' e.New1) : t.eNew1
    = (Var 't' e.New2) : t.tNew2
    = (Var 'e' e.New3) : t.eNew3
    = <Solve-Clashes
        (e.UsedVars)
        <AddContraction-Spec
          (t.eX ':' t.eNew1 t.tNew2 t.eNew3)
          (e.Contrs)
          <gen_e__
            ((('{'s.N'}') t.tNew2 t.eNew3 ('{'s.M'}') t.eY e.E2) ':' (e.P t.eR))
            e.ClashesEnd
          >
          (<gen_e__ e.Assigns (e.E1 t.eNew1 ('{'s.M'}') ':' t.eL)>)
        >
      >;

*  E1 e.X E2 : e.L P e.R  ↦  e.X → e.NEW1! e.NEW2,
*      ↑                  E1 e.NEW1! {m} ← e.L,
*                         {n} e.NEW2 E2 : P e.R
*                  где E1 = E3 {n} E4*
*                      E2 = E5* {m} E6
  (e.UsedVars) (e.Contrs)
  ((e.E1 ('sp' t.eX) e.E2) ':' (t.eL e.P t.eR))
  e.ClashesEnd (e.Assigns)
    , e.E1 : e.E3 ('{'s.N'}') e.E4
    , <HasTopLevelCoordinateLabels e.E4> : False
    , t.eX : (Var 'e' e.XIndex)
    , e.E2 : e.E5 ('{'s.M'}') e.E6
    , <HasTopLevelCoordinateLabels e.E5> : False
    , t.eL : (Var 'e' e.LIndex)
    , t.eR : (Var 'e' e.RIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New1
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New2
    = (Var 'e' e.New1) : t.eNew1
    = (Var 'e' e.New2) : t.eNew2
    = <Solve-Clashes
        (e.UsedVars)
        <AddContraction-Spec
          (t.eX ':' t.eNew1 t.eNew2)
          (e.Contrs)
          <gen_e__ ((('{'s.N'}') t.eNew2 e.E2) ':' (e.P t.eR)) e.ClashesEnd>
          (<gen_e__ e.Assigns (e.E1 t.eNew1 ('{'s.M'}') ':' t.eL)>)
        >
      >;
}

/*
  Формирует по списку присваиваний список симметричных клэшей
  и обновленный список присваиваний

  <CreateSymmClashes (e.Contrs) (t.Assign*)>
    == (t.Assign*) (t.SymmClash*)
  <CreateSymmClashes-Aux (t.Assign*) (t.SymmClash*) (t.Assign*)>
    == (t.Assign*) (t.SymmClash*)

  t.SymmClash ::= (e.L '=' e.R)
*/

CreateSymmClashes {
  (e.Contrs) (e.Assigns)
    = <ApplyContractions-toAssigns (e.Contrs) (e.Assigns)> : e.Assigns^
    = <CreateSymmClashes-Aux (e.Assigns) () ()>
    : (e.Assigns^) (e.SymmClashes)
    = (e.Assigns) (<RemoveTautologies e.SymmClashes>);
}

CreateSymmClashes-Aux {
  ((e.Left ':' t.Var) e.Rest) (e.SymmClashes) (e.NewAssigns)
    = <GroupAssignsByVar (e.Rest) t.Var ()> : (e.Rest^) (e.Group)
    = <CreateSymmClashes-Aux
        (e.Rest)
        (<CreateSymmClashesFromGroup
          (e.Left ':' t.Var)
          (e.Group)
          (e.SymmClashes)
        >)
        (e.NewAssigns (e.Left ':' t.Var))
      >;

  () (e.SymmClashes) (e.NewAssigns)
    = (e.NewAssigns) (e.SymmClashes);
}

/*
  Группирует присваивания с одинаковой переменной в правой части.
  Возвращает сформированную группу и список присваиваний без
  участия присваиваний, которые попали в группу

  <GroupAssignsByVar (t.Assign*) t.Var t.Group> == (t.Assign*) t.Group

  t.Var ::= (Var s.Type e.Index)
  t.Group ::= (t.Assign*)
*/

GroupAssignsByVar {
  (e.Begin (e.Left ':' t.Var) e.End) t.Var (e.Group)
    = <GroupAssignsByVar
        (e.Begin e.End)
        t.Var
        (e.Group (e.Left ':' t.Var))
      >;

  (e.Assigns) t.Var (e.Group)
    = (e.Assigns) (e.Group);
}

/*
  Формирует список симметричных клэшей на основании группы из
  присваиваний с одинаковыми переменными в правой части

  <CreateSymmClashesFromGroup t.FirstAssign t.Group (t.SymmClash*)>
    == t.SymmClash*
  <CreateSymmClashesFromGroup-Aux t.CurrentAssign t.Group (t.SymmClash*)>
    == t.SymmClash*

  t.FirstAssign, t.CurrentAssign ::= t.Assign
*/

CreateSymmClashesFromGroup {
  (e.E1 ':' t.Var) ((e.Ei ':' t.Var) e.Rest) (e.SymmClashes)
    = <CreateSymmClashesFromGroup
        (e.E1 ':' t.Var)
        (e.Rest)
        (<CreateSymmClashesFromGroup-Aux
            (e.Ei ':' t.Var)
            (e.Rest)
            (e.SymmClashes (e.E1 '=' e.Ei))
        >)
      >;

  t.FirstAssign () (e.SymmClashes)
    = e.SymmClashes;
}

CreateSymmClashesFromGroup-Aux {
  (e.Ei ':' t.Var) ((e.Ej ':' t.Var) e.Rest) (e.SymmClashes)
    = <CreateSymmClashesFromGroup-Aux
        (e.Ei ':' t.Var)
        (e.Rest)
        (e.SymmClashes (e.Ei '=' e.Ej))
      >;

  t.CurrentAssign () (e.SymmClashes)
    = e.SymmClashes;
}

/*
  Удаляет все координаты из выражения

  <ClearCoordinates e.Expr> == e.ExprWithoutCoordinates
*/

ClearCoordinates {
  e.Begin ('{'s.M'}') e.End
    = <ClearCoordinates e.Begin e.End>;

  e.Begin (Brackets e.E) e.End
    = <ClearCoordinates e.Begin>
      (Brackets <ClearCoordinates e.E>)
      <ClearCoordinates e.End>;

  e.Begin (ADT-Brackets (e.Name) e.E) e.End
    = <ClearCoordinates e.Begin>
      (ADT-Brackets (e.Name) <ClearCoordinates e.E>)
      <ClearCoordinates e.End>;

  e.Expr = e.Expr;
}

/*
  Вспомогательные функции отделения термов от выражений
  (отделений слева и справа соответственно)

  <SeparateTermLeft e.Expr>
    == (t.CoordinateLabel t.Term t.CoordinateLabel)
       (e.RestExpr)

  <SeparateTermRight e.Expr>
    == (e.RestExpr)
       (t.CoordinateLabel t.Term t.CoordinateLabel)
*/

SeparateTermLeft {
*  {a} T {b} ε  ↦  {a} T {b}, ε
  ('{'s.A'}') t.T ('{'s.B'}') /* пусто */
    = (('{'s.A'}') t.T ('{'s.B'}')) (/* пусто */);

  ('{'s.A'}') t.T ('{'s.B'}') e.E
    = (('{'s.A'}') t.T ('{'s.B'}')) (<SimplifyCoordinates ('{'s.B'}') e.E>);

*  {a} T E1* {b} E2  ↦  {a} T {b}, {a} E1* {b} E2
  ('{'s.A'}') t.T e.E1 ('{'s.B'}') e.E2
    = (('{'s.A'}') t.T ('{'s.B'}'))
      (('{'s.A'}') e.E1 ('{'s.B'}') e.E2);
}

SeparateTermRight {
*  ε {a} T {b}  ↦  ε, {a} T {b}
  /* пусто */ ('{'s.A'}') t.T ('{'s.B'}')
    = (/* пусто */) (('{'s.A'}') t.T ('{'s.B'}'));

*  E {a} T {b}  ↦  E {a}, {a} T {b}
  e.E ('{'s.A'}') t.T ('{'s.B'}')
    = (<SimplifyCoordinates e.E ('{'s.A'}')>) (('{'s.A'}') t.T ('{'s.B'}'));

*  E1 {a} E2* T {b}  ↦  E1 {a} E2* {b}, {a} T {b}
  e.Expr t.T ('{'s.B'}')
    = <LastCoordinate e.Expr> : e.Expr^ s.A
    = (e.Expr ('{'s.B'}')) (('{'s.A'}') t.T ('{'s.B'}'));
}

LastCoordinate {
  ('{'s.A'}') e.Begin ('{'s.B'}') e.End
    = ('{'s.A'}') e.Begin <LastCoordinate ('{'s.B'}') e.End>;

  ('{'s.A'}') e.Expr = ('{'s.A'}') e.Expr s.A;
}

/*
  Проверяет, является ли симметричный клэш тавтологией

  <IsTautology t.SymmClash> == True | False
*/

IsTautology {
  (e.L '=' e.R)
    = <ClearCoordinates e.L> : e.LWithoutCoords
    = <ClearCoordinates e.R> : e.RWithoutCoords
    = <Eq (e.LWithoutCoords) (e.RWithoutCoords)>
}

/*
  Отфильтровывает тавтологии из списка симметричных клэшей

  <RemoveTautologies t.SymmClash*> == t.SymmClash*
*/

RemoveTautologies {
  e.SymmClashes
    = <Map
        {
          t.SymmClash, <IsTautology t.SymmClash> : True = /* пусто */;

          t.SymmClash = t.SymmClash;
        }
        e.SymmClashes
      >
}

/*
  Функция, разрешающая симметричные клэши

  <Solve-SymmClashes (e.UsedVars) (e.Contractions) t.SymmClash* (t.Assign*)>
    == t.Result*
*/

Solve-SymmClashes {
  (e.UsedVars) (e.Contrs) e.SymmClashes (e.Assigns)
    = <RemoveTautologies e.SymmClashes> : e.SymmClashes^
    = <Solve-SymmClashes-Aux
        (e.UsedVars) (<gen_e__ e.Contrs>) e.SymmClashes (e.Assigns)
      >;
}

MinMode {
  e._ ('s' e.Index) e._ = 's' e.Index;
  e._ ('t' e.Index) e._ = 't' e.Index;
  ('e' e.Index) ('e' e._) = 'e' e.Index;
}

Solve-SymmClashes-Aux {
  /* {a} u.X {b} = {c} v.Y {d}  ↦  u.X → w.NEW, v.Y → w.NEW, w = min(u,v) */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.uX ('{'s.B'}') '=' ('{'s.C'}') t.vY ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.uX : (Var s.uMode e.XIndex)
    , t.vY : (Var s.vMode e.YIndex)
    = <MinMode (s.uMode e.XIndex) (s.vMode e.YIndex)> : s.wMode e.wIndex
    = <NewVarName (e.UsedVars) s.wMode e.wIndex> : (e.UsedVars^) e.wNew
    = (Var e.wNew) : t.wNew
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContractions-Spec-Symm
          ((t.uX ':' t.wNew) (t.vY ':' t.wNew))
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} #var E1 {b} = {c} #var E2 {d}  ↦  {a} E1 {b} = {c} E2 {d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Var e.E1 ('{'s.B'}') '=' ('{'s.C'}') t.Var e.E2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Var : (ScrVar e.Var)
    = <Solve-SymmClashes
        (e.UsedVars) (e.Contrs) e.ClashesStart
        <SimplifyCoordinates-SymmClash
          (('{'s.A'}') e.E1 ('{'s.B'}') '=' ('{'s.C'}') e.E2 ('{'s.D'}'))
        >
        e.ClashesEnd (e.Assigns)
      >;

  /* {a} E1 #var {b} = {c} E2 #var {d}  ↦  {a} E1 {b} = {c} E2 {d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') e.E1 t.Var ('{'s.B'}') '=' ('{'s.C'}') e.E2 t.Var ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Var : (ScrVar e.Var)
    = <Solve-SymmClashes
        (e.UsedVars) (e.Contrs) e.ClashesStart
        <SimplifyCoordinates-SymmClash
          (('{'s.A'}') e.E1 ('{'s.B'}') '=' ('{'s.C'}') e.E2 ('{'s.D'}'))
        >
        e.ClashesEnd (e.Assigns)
      >;

  /* {a} #var E1 {b} = {c} E2 {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') (ScrVar e._) e.E1 ('{'s.B'}') '=' ('{'s.C'}') e.E2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    = /* решений нет */;

  /* {a} E1 {b} = {c} #var E2 {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') e.E1 ('{'s.B'}') '=' ('{'s.C'}') (ScrVar e._) e.E2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    = /* решений нет */;

  /* {a} E1 #var {b} = {c} E2 {d}  ↦  решений нет*/
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') e.E1 (ScrVar e._) ('{'s.B'}') '=' ('{'s.C'}') e.E2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    = /* решений нет */;

  /* {a} E1 {b} = {c} E2 #var2 {d}  ↦  решений нет*/
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') e.E1 ('{'s.B'}') '=' ('{'s.C'}') e.E2 (ScrVar e._) ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    = /* решений нет */;

  /* ε = {m} e.X E {n}  ↦  e.X → ε, ε = {m} E {n} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (/* пусто */ '=' ('{'s.M'}') t.eX e.E ('{'s.N'}'))
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.eX ':' /* пусто */)
          (e.Contrs) e.ClashesStart
          (/* пусто */ '=' ('{'s.M'}') e.E ('{'s.N'}'))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {m} e.X E {n} = ε  ↦  e.X → ε, {m} E {n} = ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.M'}') t.eX e.E ('{'s.N'}') '=' /* пусто */)
  e.ClashesEnd (e.Assigns)
    , t.eX : (Var 'e' e.XIndex)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.eX ':' /* пусто */)
          (e.Contrs) e.ClashesStart
          (('{'s.M'}') e.E ('{'s.N'}') '=' /* пусто */)
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* ε = {m} T E {n}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (/* пусто */ '=' ('{'s.M'}') t.T e.E ('{'s.N'}'))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    = /* решений нет */;

  /* {m} T E {n} = ε  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.M'}') t.T e.E ('{'s.N'}') '=' /* пусто */)
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    = /* решений нет */;

  /* {a} t.X {b} = {c} {{ &F e.X }} {d}  ↦  обобщаем {c−d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.tX ('{'s.B'}') '=' ('{'s.C'}') t.Closure ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.tX : (Var 't' e._)
    , t.Closure : (ClosureBrackets e._)
    = (Generalize (('{' s.C s.D '}')));

  /* {c} {{ &F e.X }} {d} = {a} t.X {b}  ↦  обобщаем {c−d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Closure ('{'s.D'}') '=' ('{'s.A'}') t.tX ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.tX : (Var 't' e._)
    , t.Closure : (ClosureBrackets e._)
    = (Generalize (('{' s.C s.D '}')));

  /* {a} s.X {b} = {c} {{ &F e.X }} {d}  ↦  обобщаем {c−d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.sX ('{'s.B'}') '=' ('{'s.C'}') t.Closure ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.sX : (Var 's' e._)
    , t.Closure : (ClosureBrackets e._)
    = (Generalize (('{' s.C s.D '}')));

  /* {c} {{ &F e.X }} {d} = {a} s.X {b}  ↦  обобщаем {c−d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Closure ('{'s.D'}') '=' ('{'s.A'}') t.sX ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.sX : (Var 's' e._)
    , t.Closure : (ClosureBrackets e._)
    = (Generalize (('{' s.C s.D '}')));

  /* {a}  X  {b} = {c} {{ &F e.X }} {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.X ('{'s.B'}') '=' ('{'s.C'}') t.Closure ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.X : (Symbol e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {c} {{ &F e.X }} {d} = {a}  X  {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Closure ('{'s.D'}') '=' ('{'s.A'}') t.X ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.X : (Symbol e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {a} (E) {b} = {c} {{ &F e.X }} {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.BrE ('{'s.B'}') '=' ('{'s.C'}') t.Closure ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.BrE : (Brackets e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {c} {{ &F e.X }} {d} = {a} (E) {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Closure ('{'s.D'}') '=' ('{'s.A'}') t.BrE ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.BrE : (Brackets e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {a} [X E] {b} = {c} {{ &F e.X }} {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.BrE ('{'s.B'}') '=' ('{'s.C'}') t.Closure ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.BrE : (ADT-Brackets e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {c} {{ &F e.X }} {d} = {a} [X E] {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Closure ('{'s.D'}') '=' ('{'s.A'}') t.BrE ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.BrE : (ADT-Brackets e._)
    , t.Closure : (ClosureBrackets e._)
    = /* решений нет */;

  /* {a} [X E1] {b} = {c} (E2) {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br1 ('{'s.B'}') '=' ('{'s.C'}') t.Br2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br1 : (ADT-Brackets e._)
    , t.Br2 : (Brackets e._)
    = /* решений нет */;

  /* {c} (E2) {d} = {a} [X E1] {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Br2 ('{'s.D'}') '=' ('{'s.A'}') t.Br1 ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br1 : (ADT-Brackets e._)
    , t.Br2 : (Brackets e._)
    = /* решений нет */;

  /* {a} t.X {b} = {c} X {d}  ↦  t.X → X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.tX ('{'s.B'}') '=' ('{'s.C'}') t.X ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.tX : (Var 't' e.XIndex)
    , t.X : (Symbol e._)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' t.X)
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {c} X {d} = {a} t.X {b}  ↦  t.X → X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.X ('{'s.D'}') '=' ('{'s.A'}') t.tX ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.tX : (Var 't' e.XIndex)
    , t.X : (Symbol e._)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' t.X)
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} s.X {b} = {c} X {d}  ↦  s.X → X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.sX ('{'s.B'}') '=' ('{'s.C'}') t.X ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.sX : (Var 's' e.XIndex)
    , t.X : (Symbol e._)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.sX ':' t.X)
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {c} X {d} = {a} s.X {b}  ↦  s.X → X */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.X ('{'s.D'}') '=' ('{'s.A'}') t.sX ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.sX : (Var 's' e.XIndex)
    , t.X : (Symbol e._)
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.sX ':' t.X)
          (e.Contrs)
          e.ClashesStart e.ClashesEnd
          (e.Assigns)
        >
      >;

  /* {a} X {b} = {c} Y {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.X ('{'s.B'}') '=' ('{'s.C'}') t.Y ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.X : (Symbol e._)
    , t.Y : (Symbol e._)
    , <Eq t.X t.Y> : False
    = /* решений нет */;

  /* {a} (E1) {b} = {c} (E2) {d}  ↦  {a} E1 {b} = {c} E2 {d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br1 ('{'s.B'}') '=' ('{'s.C'}') t.Br2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br1 : (Brackets e.E1)
    , t.Br2 : (Brackets e.E2)
    = <Solve-SymmClashes
        (e.UsedVars)
        (e.Contrs) e.ClashesStart
        <SimplifyCoordinates-SymmClash
          (('{'s.A'}') e.E1 ('{'s.B'}') '=' ('{'s.C'}') e.E2 ('{'s.D'}'))
        >
        e.ClashesEnd (e.Assigns)
      >;

  /* {a} [X E1] {b} = {c} [X E2] {d}  ↦  {a} E1 {b} = {c} E2 {d} */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br1 ('{'s.B'}') '=' ('{'s.C'}') t.Br2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br1 : (ADT-Brackets (e.Name) e.E1)
    , t.Br2 : (ADT-Brackets (e.Name) e.E2)
    = <Solve-SymmClashes
        (e.UsedVars)
        (e.Contrs) e.ClashesStart
        <SimplifyCoordinates-SymmClash
          (('{'s.A'}') e.E1 ('{'s.B'}') '=' ('{'s.C'}') e.E2 ('{'s.D'}'))
        >
        e.ClashesEnd (e.Assigns)
      >;

  /* {a} [X E1] {b} = {c} [Y E2] {d}  ↦  нет решений */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br1 ('{'s.B'}') '=' ('{'s.C'}') t.Br2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br1 : (ADT-Brackets e._)
    , t.Br2 : (ADT-Brackets e._)
    = /* нет решений */;

  /* {a} ({b} E {c}) {d} = {e} t.X {f}  ↦  t.X → (e.NEW) */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets ('{'s.B'}') e.E ('{'s.C'}'))
    , t.tX : (Var 't' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' (Brackets (Var 'e' e.New)))
          (e.Contrs) e.ClashesStart
          (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /*
    {a} (E) {d} = {e} t.X {f}  ↦  обобщение

    Правило нужно, иначе может произойти зацикливание
    на стадии отделения термов
  */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets e._)
    , t.tX : (Var 't' e._)
    = (Generalize (('{' s.A s.D '}') ('{' s.E s.F '}')));

  /* {e} t.X {f} = {a} ({b} E {c}) {d}  ↦  t.X → (e.NEW) */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets ('{'s.B'}') e.E ('{'s.C'}'))
    , t.tX : (Var 't' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' (Brackets (Var 'e' e.New)))
          (e.Contrs) e.ClashesStart
          (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {e} t.X {f} = {a} (E) {d}  ↦  обобщение */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets e._)
    , t.tX : (Var 't' e._)
    = (Generalize (('{' s.E s.F '}') ('{' s.A s.D '}')));

  /* {a} [X {b} E {c}] {d} = {e} t.X {f}  ↦  t.X → [e.NEW] */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets (e.Name) ('{'s.B'}') e.E ('{'s.C'}'))
    , t.tX : (Var 't' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' (ADT-Brackets (e.Name) (Var 'e' e.New)))
          (e.Contrs) e.ClashesStart
          (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {a} [X E] {d} = {e} t.X {f}  ↦  обобщение */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.D'}') '=' ('{'s.E'}') t.tX ('{'s.F'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets (e.Name) e._)
    , t.tX : (Var 't' e._)
    = (Generalize (('{' s.A s.D '}') ('{' s.E s.F '}')));

  /* {e} t.X {f} = {a} [X {b} E {c}] {d}  ↦  t.X → [e.NEW] */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets (e.Name) ('{'s.B'}') e.E ('{'s.C'}'))
    , t.tX : (Var 't' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : (e.UsedVars^) 'e' e.New
    = <Solve-SymmClashes
        (e.UsedVars)
        <AddContraction-Spec-Symm
          (t.tX ':' (ADT-Brackets (e.Name) (Var 'e' e.New)))
          (e.Contrs) e.ClashesStart
          (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
          e.ClashesEnd (e.Assigns)
        >
      >;

  /* {e} t.X {f} = {a} [X E] {d}  ↦  обобщение */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.E'}') t.tX ('{'s.F'}') '=' ('{'s.A'}') t.Br ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets (e.Name) e._)
    , t.tX : (Var 't' e._)
    = (Generalize (('{' s.E s.F '}') ('{' s.A s.D '}')));

  /* {a} (E) {b} = {c} Sym {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.B'}') '=' ('{'s.C'}') t.Sym ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets e.E)
    , <IsSVarSubset t.Sym> : True
    = /* решений нет */;

  /* {c} Sym {d} = {a} (E) {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Sym ('{'s.D'}') '=' ('{'s.A'}') t.Br ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (Brackets e.E)
    , <IsSVarSubset t.Sym> : True
    = /* решений нет */;

  /* {a} [E] {b} = {c} Sym {d}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.Br ('{'s.B'}') '=' ('{'s.C'}') t.Sym ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets e._)
    , <IsSVarSubset t.Sym> : True
    = /* решений нет */;

  /* {c} Sym {d} = {a} [E] {b}  ↦  решений нет */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.Sym ('{'s.D'}') '=' ('{'s.A'}') t.Br ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , t.Br : (ADT-Brackets e._)
    , <IsSVarSubset t.Sym> : True
    = /* решений нет */;

*  {a} T1 E1 = {b} T2 E2  ↦  {c} T1 {d} = {e} T2 {f} && {g} E1′ = {h} E2′
*    где {c} T1 {d}, {g} E1′ := TERM_LEFT({a} T1 E1)
*        {e} T2 {f}, {h} E2′ := TERM_LEFT({b} T2 E2)
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.T1 e.E1 '=' ('{'s.B'}') t.T2 e.E2)
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T1> : True
    , <IsTerm t.T2> : True
    , <HasTopLevelCoordinateLabels e.E1> : True
    , <HasTopLevelCoordinateLabels e.E2> : True
    = <SeparateTermLeft ('{'s.A'}') t.T1 e.E1> : (e.Left1) (e.Left2)
    = <SeparateTermLeft ('{'s.B'}') t.T2 e.E2> : (e.Right1) (e.Right2)
    = <Solve-SymmClashes
        (e.UsedVars) (e.Contrs) e.ClashesStart
        (e.Left1 '=' e.Right1) (e.Left2 '=' e.Right2)
        e.ClashesEnd (e.Assigns)
      >;

*  E1 T1 {a} = E2 T2 {b}  ↦  E1′ {c} = E2′ {d} && {e} T1 {f} = {g} T2 {h}
*    где E1′ {c}, {e} T1 {f} := TERM_RIGHT(E1 T1 {a})
*        E2′ {d}, {g} T2 {h} := TERM_RIGHT(E2 T2 {b})
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (e.E1 t.T1 ('{'s.A'}') '=' e.E2 t.T2 ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T1> : True
    , <IsTerm t.T2> : True
    , <HasTopLevelCoordinateLabels e.E1> : True
    , <HasTopLevelCoordinateLabels e.E2> : True
    = <SeparateTermRight e.E1 t.T1 ('{'s.A'}')> : (e.Left1) (e.Left2)
    = <SeparateTermRight e.E2 t.T2 ('{'s.B'}')> : (e.Right1) (e.Right2)
    = <Solve-SymmClashes
        (e.UsedVars) (e.Contrs) e.ClashesStart
        (e.Left1 '=' e.Right1) (e.Left2 '=' e.Right2)
        e.ClashesEnd (e.Assigns)
      >;

  /* {a} T {b} E1 = {c} e.X E2  ↦  e.X → t.NEW1 e.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') t.T ('{'s.B'}') e.E1 '=' ('{'s.C'}') t.eX e.E2)
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , t.eX : (Var 'e' e.XIndex)
    = <NewVarName (e.UsedVars) 't' e.XIndex> : t.NewVars1 't' e.New1
    = <NewVarName t.NewVars1 'e' e.XIndex> : t.NewVars2 'e' e.New2
    = (Var 't' e.New1) : t.tNew1
    = (Var 'e' e.New2) : t.eNew2
    = <AddContraction-Spec-Symm
        (t.eX ':' t.tNew1 t.eNew2)
        (e.Contrs) e.ClashesStart
        (('{'s.A'}') t.T ('{'s.B'}') e.E1 '=' ('{'s.C'}') t.eX e.E2)
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec-Symm
        (t.eX ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        (('{'s.A'}') t.T ('{'s.B'}') e.E1 '=' ('{'s.C'}') t.eX e.E2)
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-SymmClashes t.NewVars2 e.Branch1>
      <Solve-SymmClashes (e.UsedVars) e.Branch2>;

  /* {c} e.X E2 = {a} T {b} E1  ↦  e.X → t.NEW1 e.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.C'}') t.eX e.E2 '=' ('{'s.A'}') t.T ('{'s.B'}') e.E1)
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , t.eX : (Var 'e' e.XIndex)
    = <NewVarName (e.UsedVars) 't' e.XIndex> : t.NewVars1 't' e.New1
    = <NewVarName t.NewVars1 'e' e.XIndex> : t.NewVars2 'e' e.New2
    = (Var 't' e.New1) : t.tNew1
    = (Var 'e' e.New2) : t.eNew2
    = <AddContraction-Spec-Symm
        (t.eX ':' t.tNew1 t.eNew2)
        (e.Contrs) e.ClashesStart
        (('{'s.C'}') t.eX e.E2 '=' ('{'s.A'}') t.T ('{'s.B'}') e.E1)
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec-Symm
        (t.eX ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        (('{'s.C'}') t.eX e.E2 '=' ('{'s.A'}') t.T ('{'s.B'}') e.E1)
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-SymmClashes t.NewVars2 e.Branch1>
      <Solve-SymmClashes (e.UsedVars) e.Branch2>;

  /* E1 {a} T {b} = E2 e.X {c}  ↦  e.X → e.NEW1 t.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (e.E1 ('{'s.A'}') t.T ('{'s.B'}') '=' e.E2 t.eX ('{'s.C'}'))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , t.eX : (Var 'e' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : t.NewVars1 'e' e.New1
    = <NewVarName t.NewVars1 't' e.XIndex> : t.NewVars2 't' e.New2
    = (Var 'e' e.New1) : t.eNew1
    = (Var 't' e.New2) : t.tNew2
    = <AddContraction-Spec-Symm
        (t.eX ':' t.eNew1 t.tNew2)
        (e.Contrs) e.ClashesStart
        (e.E1 ('{'s.A'}') t.T ('{'s.B'}') '=' e.E2 t.eX ('{'s.C'}'))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec-Symm
        (t.eX ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        (e.E1 ('{'s.A'}') t.T ('{'s.B'}') '=' e.E2 t.eX ('{'s.C'}'))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-SymmClashes t.NewVars2 e.Branch1>
      <Solve-SymmClashes (e.UsedVars) e.Branch2>;

  /* E2 e.X {c} = E1 {a} T {b}  ↦  e.X → e.NEW1 t.NEW2  ||  e.X → ε */
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (e.E2 t.eX ('{'s.C'}') '=' e.E1 ('{'s.A'}') t.T ('{'s.B'}'))
  e.ClashesEnd (e.Assigns)
    , <IsTerm t.T> : True
    , t.eX : (Var 'e' e.XIndex)
    = <NewVarName (e.UsedVars) 'e' e.XIndex> : t.NewVars1 'e' e.New1
    = <NewVarName t.NewVars1 't' e.XIndex> : t.NewVars2 't' e.New2
    = (Var 'e' e.New1) : t.eNew1
    = (Var 't' e.New2) : t.tNew2
    = <AddContraction-Spec-Symm
        (t.eX ':' t.eNew1 t.tNew2)
        (e.Contrs) e.ClashesStart
        (e.E2 t.eX ('{'s.C'}') '=' e.E1 ('{'s.A'}') t.T ('{'s.B'}'))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch1
    = <AddContraction-Spec-Symm
        (t.eX ':' /* пусто */)
        (e.Contrs) e.ClashesStart
        (e.E2 t.eX ('{'s.C'}') '=' e.E1 ('{'s.A'}') t.T ('{'s.B'}'))
        e.ClashesEnd (e.Assigns)
      >
    : e.Branch2
    = <Solve-SymmClashes t.NewVars2 e.Branch1>
      <Solve-SymmClashes (e.UsedVars) e.Branch2>;

*  Если остались клэши, к которым не применимы вышеперечисленные правила,
*  то производим запрос на обобщение
  (e.UsedVars) (e.Contrs) e.ClashesStart
  (('{'s.A'}') e.E1 ('{'s.B'}') '=' ('{'s.C'}') e.E2 ('{'s.D'}'))
  e.ClashesEnd (e.Assigns)
    = (Generalize (('{' s.A s.B '}') ('{' s.C s.D '}')));

*  Если клэши кончились, возвращаем решение
  (e.UsedVars) (s.OpenFlag e.Contrs) (e.Assigns)
    = <ApplyContractions-toAssigns (e.Contrs) (e.Assigns)> : e.Assigns^
    = (Success (e.UsedVars) s.OpenFlag (e.Contrs) (e.Assigns));
}

/* Проверка на эквивалентность */

Eq {
  (e.X) (e.X) = True;

  e.Other = False
}

/* Проверка на параметризованный символ */

IsSVarSubset {
  (Symbol s.Type e.Info) = True;
  (Var 's' e.Tindex) = True;
  (ScrVar 's' e.Tindex) = True;
  (Closure e.Body) = True;
  (ClosureBrackets e.Context) = True;

  t.OtherTerm = False;
}

/* Проверка на терм */

IsTerm {
  (Var 'e' e.Index) = False;
  (ScrVar 'e' e.Index) = False;

  /* Рассматриваем для оптимизаций встраивания, прогонки и специализации */
  (CallBrackets e.Nested) = False;
  (ColdCallBrackets e.Nested) = False;

  /* Метки координат не будем считать термами */
  ('{'s.Coord'}') = False;

  /* s-, t-переменная, скобки обоих видов, символ */
  t.OtherTerm = True;
}

AddContractions-Spec-Symm {
  (t.toAdd e.Rest) (e.Contrs) e.SymmClashes (e.Assigns)
    = <AddContractions-Spec-Symm
        (e.Rest)
        <AddContraction-Spec-Symm
          t.toAdd
          (e.Contrs)
          e.SymmClashes
          (e.Assigns)
        >
      >;

  () e.PRTC = e.PRTC;
}

/*
  Добавление сужения к PRTC

  <AddContraction t.toAdd (t.Contraction*) t.Equation* (t.Assign*)>
   == PRTC
*/
$DRIVE AddContraction-Spec, AddContraction-Spec-Symm;

AddContraction-Spec {
  t.toAdd (s.OpenFlag e.Contrs) e.Clashes (e.Assigns)
    = t.toAdd
    : {
        ((Var 'e' e._) ':' (Var 'e' e._) (Var 'e' e._)) = AfterOpen;

        ((Var 'e' e._) ':' (Var 'e' e._) (Var 't' e._) (Var 'e' e._))
          = AfterOpen;

        t._ = s.OpenFlag;
      }
    : s.OpenFlag^
    = <gen_t__ t.toAdd> : t.toAdd^
    = (s.OpenFlag e.Contrs t.toAdd)
      <Map (&ApplyContraction-toEquation t.toAdd) e.Clashes>
      (e.Assigns);
}

gen_t__ { e.arg = <gen_e__ e.arg> }

AddContraction-Spec-Symm {
  t.toAdd (s.OpenFlag e.Contrs) e.SymmClashes (e.Assigns)
    = t.toAdd
    : {
        ((Var 'e' e._) ':' (Var 'e' e._) (Var 'e' e._)) = AfterOpen;

        ((Var 'e' e._) ':' (Var 'e' e._) (Var 't' e._) (Var 'e' e._))
          = AfterOpen;

        t._ = s.OpenFlag;
      }
    : s.OpenFlag^
    = (s.OpenFlag e.Contrs t.toAdd)
      <Map (&ApplyContraction-toSymmClash t.toAdd) e.SymmClashes>
      (e.Assigns);
}

/*
  Применение сужения к присваиванию

  <ApplyContractions-toAssigns (e.Contrs) (e.Assigns)> == e.Assigns^
*/
ApplyContractions-toAssigns {
  (e.Contrs) (e.Assigns)
    = <Map
        {
          (e.Expr ':' t.Var)
            = <ApplyContractions e.Expr (e.Contrs)> : e.Expr^
            = <SimplifyCoordinates e.Expr> : e.Expr^
            = (e.Expr ':' t.Var)
        }
        e.Assigns
      >
}

/*
   Применение сужения к уравнению

   <ApplyContraction-toEquation t.Contraction t.Equation> == t.Equation
*/

ApplyContraction-toEquation {
   t.Contraction ((e.Expr) ':' (e.Lexpr))
     = <ApplyContraction-toExpr t.Contraction e.Expr> : e.Expr^
     = <SimplifyCoordinates e.Expr> : e.Expr^
     = ((e.Expr) ':' (e.Lexpr))
}

ApplyContraction-toSymmClash {
  t.Contr (e.L '=' e.R)
    = <ApplyContraction-toExpr t.Contr e.L> : e.L^
    = <ApplyContraction-toExpr t.Contr e.R> : e.R^
    = <SimplifyCoordinates-SymmClash (e.L '=' e.R)>
    : {
        /* стираем тавтологию */
        t.SymmClash, <IsTautology t.SymmClash> : True = /* пусто */;

        t.SymmClash = t.SymmClash;
      }
}

/*
    Применение сужения к выражению

    <ApplyContraction-toExpr t.Contraction e.Expr> == e.Expr
*/

ApplyContraction-toExpr {
   (t.Var ':' e.Lval) e.B t.Var e.E =
     <ApplyContraction-toExpr (t.Var ':' e.Lval) e.B>
     e.Lval
     <ApplyContraction-toExpr (t.Var ':' e.Lval) e.E>;

   t.Contraction e.B (Brackets e.M) e.E =
     <ApplyContraction-toExpr t.Contraction e.B>
     (Brackets <ApplyContraction-toExpr t.Contraction e.M>)
     <ApplyContraction-toExpr t.Contraction e.E>;

   t.Contraction e.B (ADT-Brackets (e.N) e.M) e.E =
     <ApplyContraction-toExpr t.Contraction e.B>
     (ADT-Brackets (e.N) <ApplyContraction-toExpr t.Contraction e.M>)
     <ApplyContraction-toExpr t.Contraction e.E>;

   t.Contraction e.B (ClosureBrackets e.M) e.E =
     <ApplyContraction-toExpr t.Contraction e.B>
     (ClosureBrackets <ApplyContraction-toExpr t.Contraction e.M>)
     <ApplyContraction-toExpr t.Contraction e.E>;

   t.Contraction e.Expr = e.Expr
}

/*
  Проверка на то, что выражение содержит
  метки координат на верхнем уровне
*/

HasTopLevelCoordinateLabels {
  e.Begin ('{'s.M'}') e.End = True;

  e.Other = False
}
