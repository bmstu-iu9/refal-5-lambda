$INCLUDE "LibraryEx";

*$FROM TreeUtils
$EXTERN ExtractVariables, ExtractVariables-Expr, NewVarName, AddSuffix;

*$FROM GenericMatch
$EXTERN GenericMatch;

*$FROM Log
$EXTERN Log-PutLine, Log-InlineExpr;

*$FROM DisplayName
$EXTERN DisplayName;

*$FROM GlobalGen
$EXTERN GlobalGen;

/**
  <OptTree-Spec-Prepare s.OptSpec e.AST> == e.AST^

  s.OptSpec ::= OptSpec | NoOpt

  В дерево добавляется узел (SpecInfo e.SpecInfo).

  e.SpecInfo ::= (e.SpecFuncNames) e.SpecInfo-Specific
  e.SpecFuncNames ::= (e.FuncName)*
  e.SpecInfo-Specific ::= t.FunctionInfo* (e.Histories)
  t.FunctionInfo ::= ((e.Name) (e.Pattern) (e.Body) s.NextCounter t.Signature*)
  t.Signature ::= ((e.InstanceName) t.StaticVarVals*)
  t.StaticVarVals ::= (e.Expression)
  e.InstanceName ::= e.Name
  e.Histories ::= ((e.InstanceName) e.History)*
  e.History ::= ((e.FuncName) t.StaticVarVals*)*
*/
$ENTRY OptTree-Spec-Prepare {
  NoOpt e.AST = e.AST;

  OptSpec e.AST-B (SpecInfo e.SpecInfo) e.AST-E
    = <Prepare-Aux (e.SpecInfo) e.AST-B e.AST-E>;

  OptSpec e.AST
    = (/* no names */) /* no info */ (/* no histories */)
    : e.EmptyInfo
    = <Prepare-Aux (e.EmptyInfo) e.AST>;
}

Prepare-Aux {
  ((e.KnownNames) e.KnownInfo (e.KnownHistories)) e.AST
    = <Fetch
        ((/* no names */) /* no info */ (/* no histories */)) e.AST
        <Pipe
          (&MapAccum
            {
              /* Игнорируем новые $SPEC’и для известных функций */
              ((e.Names) e.Info (e.Histories)) (Spec t.Name e.Pattern)
                , e.KnownNames : e._B t.Name e._E
                = ((e.Names) e.Info (e.Histories)) /* пропускаем */;

              ((e.Names) e.Info (e.Histories)) (Spec t.Name e.Pattern)
                = t.Name : (e.Name)
                = (
                    (e.Names t.Name)
                    e.Info (t.Name (e.Pattern))
                    (e.Histories <TrivialHistory e.Name (e.Pattern)>)
                  )
                  <Log-PutLine
                    'New $SPEC function: ' <DisplayName e.Name> ' '
                    <Log-InlineExpr e.Pattern>
                  >;

              ((e.Names) e.Info (e.Histories)) t.Other
                = ((e.Names) e.Info (e.Histories)) t.Other;
            }
          )
          (&MapAccum
            {
              ((e.Names) e.Info-B (t.Name (e.Pattern)) e.Info-E (e.Histories))
              (Function s.ScopeClass t.Name Sentences e.Body)
                = (
                    (e.Names)
                    e.Info-B (t.Name (e.Pattern) (e.Body) 1) e.Info-E
                    (e.Histories)
                  )
                  (Function s.ScopeClass t.Name Sentences e.Body);

               ((e.Names) e.Info) t.Other = ((e.Names) e.Info) t.Other;
            }
          )
        >
      >
    : ((e.NewNames) e.NewInfo (e.NewHistories)) e.AST^

    = <AddGuardSentences e.NewInfo> : e.NewInfo^
    = <AddGuardEnums e.AST> : e.AST^

    = <CreateRemainderFunctions e.NewInfo> : e.NewInfo^

    = (SpecInfo
        (e.KnownNames e.NewNames)
        e.KnownInfo e.NewInfo
        (e.KnownHistories e.NewHistories)
      )
      e.AST
}

TrivialHistory {
  e.Name (e.Pattern)
    = (<AddSuffix e.Name ('@' 0)>)
      <Map
        {
          (s.Mode e.Index)
            , <IsSpecStaticVar (s.Mode e.Index)> : True
            = ((TkVariable s.Mode e.Index));

          (s.Mode e.Index) = /* пропускаем */;
        }
        <ExtractVariables-Expr e.Pattern>
      >
    : e.HistoryRecord
    = ((e.Name) (e.HistoryRecord));
}

* Добавляет вызов аварийной функции Func@0 в конец каждой специализируемой
* функции.Этот вызов облегчает отладку при аварийном завершении программы
* в специализированной функции.
AddGuardSentences {
  e.Info
    = <Map
        {
          ((e.Name) (e.SpecPattern) (e.Sentences) e.Signatures)
            = <AddSuffix e.Name ('@' 0)> : e.GuardName
            = (e.SpecPattern)
              ((CallBrackets (Symbol Name e.GuardName) e.SpecPattern))
            : e.GuardSentence
            = (
                (e.Name)
                (e.SpecPattern)
                (e.Sentences (e.GuardSentence))
                e.Signatures
              )
        }
        e.Info
      >
}

AddGuardEnums {
  e.AST
    = <Map
        {
          (Function s.ScopeClass (e.Name) e.Body)
            = (Function s.ScopeClass (e.Name) e.Body) <MakeGuardEnum e.Name>;

          (Declaration s.ScopeClass e.Name)
            = (Declaration s.ScopeClass e.Name) <MakeGuardEnum e.Name>;

          t.OtherItem = t.OtherItem;
        }
        e.AST
      >
}

GuardEnumName {
  e.Name = <AddSuffix e.Name ('@' 0)>
}

MakeGuardEnum {
  e.Name = (Function GN-Local (<GuardEnumName e.Name>) Sentences /* пусто */)
}

* Обеспечивает специализацию функций Func*n. Такие функции могут получаться
* при частичной прогонке функций, помеченных как прогоняемые
* и специализированные одновременно. Этот остаток тоже имеет смысл
* специализировать.
CreateRemainderFunctions {
  e.Info = <Map (&CreateRemainderFunctions-OneFunction 0) e.Info>
}

CreateRemainderFunctions-OneFunction {
  s.Count ((e.Name) (e.SpecPattern) ((e.GuardSentence)) 1 /* нет сигнатур */)
    = /* пусто */;

  s.Count ((e.Name) (e.SpecPattern) (e.Sentences) 1 /* нет сигнатур */)
    = s.Count
    : {
        0 = e.Name;
        s._ = <AddSuffix e.Name ('*' s.Count)>;
      }
    : e.RemainderName
    = ((e.RemainderName) (e.SpecPattern) (e.Sentences) 1 /* нет сигнатур */)
      <CreateRemainderFunctions-OneFunction
        <Inc s.Count>
        ((e.Name) (e.SpecPattern) (<Drop e.Sentences>) 1 /* нет сигнатур */)
      >;
}

Drop {
  t.First e.Rest = e.Rest
}

/**
  <OptTree-Spec s.OptSpec e.AST> == e.AST^

  s.OptSpec ::= OptSpec | NoOpt
*/
$ENTRY OptTree-Spec {
  NoOpt e.AST = <ColdAll e.AST>;

  OptSpec e.AST-B (SpecInfo (e.Names) e.SpecInfo (e.Histories)) e.AST-E
    = <PrintHistories e.Histories>
      <MapAccum
        &SpecUnit
        (e.SpecInfo (e.Histories) (/* new functions */))
        e.AST-B e.AST-E
      >
    : (e.SpecInfo^ (e.Histories^) (e.NewFunctions)) e.AST
    = (SpecInfo (e.Names) e.SpecInfo (e.Histories)) e.AST e.NewFunctions;
}

ColdAll {
  e.AST
    = <Map
        {
          (Function s.ScopeClass (e.Name) e.Body)
            = (ColdFunction SPEC s.ScopeClass (e.Name) e.Body);

          t.OtherItem = t.OtherItem;
        }
        e.AST
      >;
}

PrintHistories {
  e.Histories = <Map &PrintHistory e.Histories>;
}

PrintHistory {
  ((e.Function) e.History)
    = <Log-PutLine
        'History of ' <DisplayName e.Function> '\n'
        <Map
          {
            ((e.FuncName) e.StaticVarsVals)
              = '    ' <DisplayName e.FuncName> ':'
                ' [' <PrintSignature e.StaticVarsVals> ']\n';
          }
          e.History
        >
      >
}

PrintSignature {
  /* пусто */ = /* пусто */;
  t.First e.Last
    = <PrintSignatureItem t.First>
      <Map { t.Item = ', ' <PrintSignature t.Item> } e.Last>
}

PrintSignatureItem {
  (e.Expr) = <Log-InlineExpr e.Expr>;
}

SpecUnit {
  (e.SpecInfo
    (e.Histories-B (t.Name e.History) e.Histories-E) (e.NewFunctions)
  )
  (Function s.ScopeClass t.Name Sentences e.Sentences)
    = <MapAccum
        &SpecSentence
        (
          e.SpecInfo (e.Histories-B (t.Name e.History) e.Histories-E)
          (e.History) (e.NewFunctions)
        )
        e.Sentences
      >
    : (e.SpecInfo^ (e.Histories) (e.History^) (e.NewFunctions^)) e.Sentences^
    = (e.SpecInfo (e.Histories) (e.NewFunctions))
      (ColdFunction SPEC s.ScopeClass t.Name Sentences e.Sentences);

  (e.SpecInfo (e.Histories) (e.NewFunctions))
  (Function s.ScopeClass t.Name Sentences e.Sentences)
    = <MapAccum
        &SpecSentence
        (e.SpecInfo (e.Histories) (/* empty history */) (e.NewFunctions))
        e.Sentences
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^))
      e.Sentences^
    = (e.SpecInfo (e.Histories) (e.NewFunctions))
      (ColdFunction SPEC s.ScopeClass t.Name Sentences e.Sentences);

  (e.SpecInfo (e.Histories) (e.NewFunctions)) t.Other
    = (e.SpecInfo (e.Histories) (e.NewFunctions)) t.Other;
}

/**
  <SpecSentence
    (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
    t.Sentence
  >
    == (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^) t.Sentence^

  t.Sentence ::= ((e.Pattern) e.Conditions (e.Result))

  Функция ищет в правой части предложения вызовы специализируемых функций
  и пытается выполнить специализацию для него
*/
SpecSentence {
  (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  ((e.Pattern) e.Conditions (e.Result))
    = <MapAccum
        {
          (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^))
          (Condition (e.Name) (e.ConditionResult) (e.ConditionPattern))
            = <SpecResult
                (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
                e.ConditionResult
              >
            : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^))
              e.ConditionResult^
            = (e.SpecInfo (e.Histories) (e.History)  (e.NewFunctions))
              (Condition (e.Name) (e.ConditionResult) (e.ConditionPattern));
        }
        (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Conditions
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Conditions^
    = <SpecResult
        (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Result
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Result^
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      ((e.Pattern) e.Conditions (e.Result));
}


/**
  <SpecResult
    (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
    e.Results
  >
    == (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Result^

  Функция разбирает результирующее выражение, ищет в нем вызовы специализируемых
  функций и замыканий и пытается выполнить специализацию для них
*/
SpecResult {
  (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) e.Result
    = <SpecResult-Pass
        Functions (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Result
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Result^
    = <SpecResult-Pass
        Closures (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Result
      >;
}

SpecResult-Pass {
  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) e.Result
    = <MapAccum
        {
          (e.Info (e.CurHistories) (e.CurHistory) (e.NewFuncs)) t.Result-T
            = <SpecTerm
                s.Pass (e.Info (e.CurHistories) (e.CurHistory) (e.NewFuncs))
                t.Result-T
              >;
        }
        (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Result
      >;
}

/**
  <SpecTerm (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) t.Term>
    == (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) t.Term^

  Функция ищет в терме вызовы специализируемых функций
  и пытается выполнить специализацию для него
*/
SpecTerm {
  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  (CallBrackets (Symbol Name e.Name) e.Expression)
    , e.Name : e._ '@' 0
    /*
      Аргументы вызовов аварийных функций специализатора специализировать
      нельзя, они должны оставаться неизменными.

      Вместо этого мы все ссылки на функции заменим ссылками на пустые функции —
      это необходимо, чтобы инструмент удаления неиспользуемых функций удалил
      те, по которым программа уже специализировалась.

      Например, для <Map {{ &F\1 … }} …> в аварийном предложении останется
      &F\1, которая сама может тянуть ненужные функции (и занимать собой
      сгенерированный код). Мы заменим её на пустую функцию.
    */
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      (CallBrackets (Symbol Name e.Name) <ReplaceToGuards e.Expression>);

  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  (CallBrackets (Symbol Name e.Name) e.Expression)
    = <SpecResult-Pass
        s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Expression
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Expression^

    = s.Pass
    : {
        Functions = &TrySpecCall;
        Closures = &SkipSpecCall;
      }
    : s.TrySpecCall

    = <s.TrySpecCall
        (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        (CallBrackets (Symbol Name e.Name) e.Expression)
      >;

  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  (CallBrackets e.Expression)
    = <SpecResult-Pass
        s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Expression
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Expression^
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      (CallBrackets e.Expression);

  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  (ClosureBrackets e.ClosureContent)
    = <SpecResult-Pass
        s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.ClosureContent
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^))
      e.ClosureContent^

    = s.Pass
    : {
        Functions = &SkipSpecCall;
        Closures = &TrySpecCall;
      }
    : s.TrySpecCall

    = <s.TrySpecCall
        (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        (CallBrackets e.ClosureContent (TkVariable 'e@' 0))
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^))
      (CallBrackets e.ClosureContent^ (TkVariable 'e@' 0))

    = e.ClosureContent
    : {
        (Symbol Name e.OptName) /* пусто */
          = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
            (Symbol Name e.OptName);

        e.ClosureContent^
          = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
            (ClosureBrackets e.ClosureContent);
      };


  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
    (Brackets e.Expression)
    = <SpecResult-Pass
        s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Expression
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Expression^
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      (Brackets e.Expression);

  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
    (ADT-Brackets (e.Name) e.Expression)
    = <SpecResult-Pass
        s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
        e.Expression
      >
    : (e.SpecInfo^ (e.Histories^) (e.History^) (e.NewFunctions^)) e.Expression^
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      (ADT-Brackets (e.Name) e.Expression);

  s.Pass (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) t.Other
   = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) t.Other;
}

ReplaceToGuards {
  e.Expression
    = <Map
        {
          (s.Brackets e.Nested)
            , Brackets CallBrackets ClosureBrackets : e._ s.Brackets e._
            = (s.Brackets <ReplaceToGuards e.Nested>);

          (ADT-Brackets (e.Name) e.Nested)
            = (ADT-Brackets (e.Name) <ReplaceToGuards e.Nested>);

          /* Уже пустая функция, ничего не делаем с ней */
          (Symbol Name e.Name '@' 0) = (Symbol Name e.Name '@' 0);

          (Symbol Name e.Name) = (Symbol Name <GuardEnumName e.Name>);

          t.Other = t.Other;
        }
        e.Expression
      >
}

TrySpecCall {
  (
    e.SpecInfo-B ((e.Name) e.Info) e.SpecInfo-E
    (e.Histories) (e.History) (e.NewFunctions)
  )
  (CallBrackets (Symbol Name e.Name) e.Expression)
    = <SpecCall (e.Name) e.Info (e.Expression) (e.History)>
    : (e.Info^) t.NewCall e.NewFunction (e.NewHistory)
    = (
        ((e.Name) e.Info) e.SpecInfo-B e.SpecInfo-E
        (e.Histories e.NewHistory)
        (e.History)
        (e.NewFunctions e.NewFunction)
      )
      t.NewCall;

  (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
  (CallBrackets (Symbol Name e.Name) e.Expression)
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions))
      (CallBrackets (Symbol Name e.Name) e.Expression);
}

SkipSpecCall {
  (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) t.CallTerm
    = (e.SpecInfo (e.Histories) (e.History) (e.NewFunctions)) t.CallTerm;
}

/**
  <SpecCall
    (e.Name) (e.SpecPattern) (e.Body)
    s.CurrentNumber e.Signatures (e.Argument) (e.History)
  >
    == ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures t.NewSignature)
        t.NewCall t.NewFunction (e.NewHistory)

  Функция пытается выполнить специализацию для заданного вызова:
  # ищет среди сигнатур готовых специализированных функций похожую
    * если сигнатура найдена, заменяем исходный вызов на вызов найденной функции
    * если сигнатура не найдена выполняем специализацию для аргументов вызова
      # формируем новый вызов
      # формируем определение новой специализированной функции
  # возвращает e.Info с новой сигнатурой,
    новый вызов
    определение новой специализированной функции
*/
SpecCall {
  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
  (e.Argument) (e.History)

    , <GenericMatch-Wrapper (e.Argument) (e.SpecPattern)>
    : Clear (e.StaticMatches) (e.DynamicMatches)

    = True : s.NeedRelationCheck

    = <SpecCall-Matches
        (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
        (e.Argument) (e.StaticMatches) (e.DynamicMatches) (e.History)
        s.NeedRelationCheck
      >;

  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
  (e.Argument) (e.History)
    = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
      (CallBrackets (Symbol Name e.Name) e.Argument)
      /* no new functions */
      (/* no new history */);
}

SpecCall-Matches {
  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
  (e.Argument) (e.StaticMatches) (e.DynamicMatches) (e.History)
  s.NeedRelationCheck

    , <ExtractCalls e.StaticMatches> : (e.Calls) e.StaticMatches^

    , <PrepareSignature e.StaticMatches (e.SpecPattern)> : e.Signature

    , <IsTrivialSubstitutions e.StaticMatches> : False

    = <SpecCall-Aux
        (e.Name) (e.SpecPattern) (e.Body)
        s.NextNumber e.Signatures (e.Argument)
        (e.Signature) (e.StaticMatches) (e.DynamicMatches)
        (e.Calls) (e.History) s.NeedRelationCheck
      >;

  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
  (e.Argument) (e.StaticMatches) (e.DynamicMatches) (e.History)
  s.NeedRelationCheck
    = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
      (CallBrackets (Symbol Name e.Name) e.Argument)
      /* no new functions */
      (/* no new history */);
}

SpecCall-Aux {
  (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures (e.Argument)
  (e.Signature) (e.StaticMatches) (e.DynamicMatches) (e.Calls) (e.History)
  s.NeedRelationCheck

    = <PrepareArgOrPattern (e.StaticMatches) (e.DynamicMatches) e.SpecPattern>
    : e.SpecializedFuncArgument

    = <ApplySubst-Expr (e.Calls) e.SpecializedFuncArgument>
    : e.SpecializedFuncArgument^

    = <Spec-FindInSignatures (e.Signature) e.Signatures>
    : {
        Found e.InstanceName (e.Signatures^)
          = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
            (CallBrackets
              (Symbol Name e.InstanceName) e.SpecializedFuncArgument
            )
            /* no new functions */
            (/* no new history */);

        NotFound e.Signatures^

          = s.NeedRelationCheck
          : {
              True
                = <HasHigmanKruskalRelation
                    (e.Name) (<CanonizeSignature e.Signature>)
                    e.History
                  >;

              False = False;
            }
          : e.RelationCheckResult

          = e.RelationCheckResult
          : {
              True e.HistorySignature

                = <MakeGeneralization
                    (e.Signature) (e.HistorySignature) (e.Argument)
                    (e.SpecPattern) (e.StaticMatches) (e.Name)
                    (e.Body) s.NextNumber (e.Signatures) (e.DynamicMatches)
                    (e.History) (e.Calls)
                  >;

              False
                = <PrepareSpecializedFuncBody
                    (e.SpecPattern) (e.StaticMatches) e.Body
                  >
                : e.SpecializedFuncBody

                , <IsSoundBody e.SpecializedFuncBody>
                : {
                    True
                      = <AddSuffix e.Name ('@' s.NextNumber)> : e.InstanceName
                      = (
                          (e.SpecPattern) (e.Body) <Inc s.NextNumber>
                          e.Signatures ((e.InstanceName) e.Signature)
                        )
                        (CallBrackets
                          (Symbol Name e.InstanceName)
                          e.SpecializedFuncArgument
                        )
                        (Function
                          GN-Local (e.InstanceName)
                          Sentences e.SpecializedFuncBody
                        )
                        (
                          (
                            (e.InstanceName) e.History
                            ((e.InstanceName) e.Signature)
                          )
                        );

                    False
                      = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
                        (CallBrackets (Symbol Name e.Name) e.Argument)
                        /* no new functions */
                        (/* no new history */);
                  };

              e.Other
                = ((e.SpecPattern) (e.Body) s.NextNumber e.Signatures)
                  (CallBrackets (Symbol Name e.Name) e.Argument)
                  /* no new functions */
                  (/* no new history */);
            };
      };
}

ExtractCalls {
  e.StaticMatches

    = <Map
        {
          (e.Expr ':' t.Var) = <ExtractVariables-Expr e.Expr>;
        }
        e.StaticMatches
      >
    : e.UsedVars

    = <MapAccum
        {
          (e.Calls (e.UsedVars^)) (e.Expr ':' t.Var)
            = <ExtractCalls-Expr (e.Calls (e.UsedVars)) e.Expr>
            : (e.Calls^ (e.UsedVars^)) e.Expr^
            = (e.Calls (e.UsedVars)) (e.Expr ':' t.Var);
        }
        (/* calls */ (e.UsedVars)) e.StaticMatches
      >
    : (e.Calls (e.UsedVars^)) e.StaticMatches^

    = (e.Calls) e.StaticMatches
}

ExtractCalls-Expr {
  (e.Calls (e.UsedVars)) e.Expr
    = <MapAccum &ExtractCalls-Term (e.Calls (e.UsedVars)) e.Expr>;
}

ExtractCalls-Term {
  (e.Calls (e.UsedVars)) (CallBrackets e.Expr)
    = <NewVarName (e.UsedVars) 'eCall' 0> : (e.UsedVars^) e.NewVar
    = (e.Calls ((CallBrackets e.Expr) ':' (e.NewVar)) (e.UsedVars))
      (TkVariable e.NewVar);

  (e.Calls (e.UsedVars)) (Brackets e.Expr)
    = <ExtractCalls-Expr (e.Calls (e.UsedVars)) e.Expr>
    : (e.Calls^ (e.UsedVars^)) e.Expr^
    = (e.Calls (e.UsedVars)) (Brackets e.Expr);

  (e.Calls (e.UsedVars)) (ADT-Brackets (e.Name) e.Expr)
    = <ExtractCalls-Expr (e.Calls (e.UsedVars)) e.Expr>
    : (e.Calls^ (e.UsedVars^)) e.Expr^
    = (e.Calls (e.UsedVars)) (ADT-Brackets (e.Name) e.Expr);

  (e.Calls (e.UsedVars)) t.OtherTerm = (e.Calls (e.UsedVars)) t.OtherTerm;
}

IsSoundBody {
  e.Body
    , <FindClosuresInPatterns-Body e.Body>
    : {
        /* пусто */ = True;
        e.FoundClosures = False;
      };
}

FindClosuresInPatterns-Body {
  e.Body
    = <Map
        {
          ((e.Pattern) e.Conditions (e.Result))
            = <FindClosuresInPatterns-Pattern
                e.Pattern
                <Map
                  {
                    (Condition (e.Name) (e.CondResult) (e.CondPattern))
                      = e.CondPattern;
                  }
                  e.Conditions
                >
              >;
        }
        e.Body
      >;
}

FindClosuresInPatterns-Pattern {
  e.Pattern = <Map &FindClosuresInPatterns-Term e.Pattern>;
}

FindClosuresInPatterns-Term {
  (Symbol s.Type e.Info) = /* пусто */;
  (TkVariable s.Type e.Index) = /* пусто */;

  (Brackets e.Pattern)
    = <FindClosuresInPatterns-Pattern e.Pattern>;
  (ADT-Brackets (e.Name) e.Pattern)
    = <FindClosuresInPatterns-Pattern e.Pattern>;

  (ClosureBrackets e.Context) = Found;
}

PrepareSignature {
  e.StaticMatches (e.SpecPattern)
    /* ExtractVariables-Expr сохраняет порядок переменных в выражении */
    = <ExtractVariables-Expr e.SpecPattern> : e.SpecVars
    = <PrepareSignature-SortVars e.StaticMatches (e.SpecVars)> : e.ExprList
    = <RenameSignatureVars e.ExprList>;
}

PrepareSignature-SortVars {
  e.StaticMatches (e.SpecPatternVars)
    = <MapAccum
        {
          (e.Vars-B (e.Val ':' (TkVariable e.Index)) e.Vars-E) (e.Index)
            = (e.Vars-B e.Vars-E) (e.Val);

          /*
            Если очередной переменной нет среди подстановок, значит
            она динамическая
          */
          (e.Variables) (e.Index) = (e.Variables) /* пропускаем */;
        }
        (e.StaticMatches) e.SpecPatternVars
      >
    : (/* должно быть пусто */) e.SigValues
    = e.SigValues;
}

RenameSignatureVars {
  e.Signature
    = /* пусто */ : e.KnownVars
    = 0 : s.NextId
    = <MapAccum
        {
          (e.KnownVars^ s.NextId^) (e.SignaturePart)
            = <RenameSignatureVars-Expr (e.KnownVars s.NextId) e.SignaturePart>
            : (e.KnownVars^ s.NextId^) e.SignaturePart^
            = (e.KnownVars s.NextId) (e.SignaturePart);
        }
        (e.KnownVars s.NextId)
        e.Signature
      >
    : (e.KnownVars^ s.NextId^) e.Signature^
    = e.Signature;
}

RenameSignatureVars-Expr {
  t.State e.Expr = <MapAccum &RenameSignatureVars-Term t.State e.Expr>;
}

RenameSignatureVars-Term {
  (e.KnownVariables s.NextId) (TkVariable s.Mode e.OldIndex)
    , e.KnownVariables : e._B (s.Mode e.OldIndex (e.NewIndex)) e._E
    = (e.KnownVariables s.NextId)
      (TkVariable s.Mode e.NewIndex);

  (e.KnownVariables s.NextId) (TkVariable s.Mode e.OldIndex)
    = <Symb s.NextId> 0 : e.NewIndex
    = (e.KnownVariables (s.Mode e.OldIndex (e.NewIndex)) <Inc s.NextId>)
      (TkVariable s.Mode e.NewIndex);

  t.State (s.BracketsTag e.Expr)
    , <OneOf s.BracketsTag CallBrackets ClosureBrackets Brackets> : True
    = <RenameSignatureVars-Expr t.State e.Expr> : t.State^ e.Expr^
    = t.State (s.BracketsTag e.Expr);

  t.State (ADT-Brackets (e.Name) e.Expr)
    = <RenameSignatureVars-Expr t.State e.Expr> : t.State^ e.Expr^
    = t.State (ADT-Brackets (e.Name) e.Expr);

  t.State t.OtherTerm = t.State t.OtherTerm;
}

/*
  Применяем левую подстановку к левым частям правой.
  Это не совсем композиция подстановок, поскольку для композиции нужно
  также объединять домены подстановок.
*/
ApplySubst-Subst {
  (e.FromSubstitution) e.ToSubstitution
    = <Map
        {
          (e.Expr ':' t.Var)
            = (<ApplySubst-Expr (e.FromSubstitution) e.Expr> ':' t.Var);
        }
        e.ToSubstitution
      >;
}

ApplySubst-Expr {
  (e.Substitution) e.Expression
    = <Map
        {
          (TkVariable e.ModeIndex)
            , e.Substitution : e.Subst-B (e.Value ':' (e.ModeIndex)) e.Subst-E
            = e.Value;

          (Brackets e.Nested)
            = (Brackets <ApplySubst-Expr (e.Substitution) e.Nested>);

          (ADT-Brackets (e.Name) e.Nested)
            = (ADT-Brackets
                (e.Name) <ApplySubst-Expr (e.Substitution) e.Nested>
              );

          (CallBrackets e.Nested)
            = (CallBrackets <ApplySubst-Expr (e.Substitution) e.Nested>);

          (ClosureBrackets e.ClosureContent)
            = (ClosureBrackets
                <ApplySubst-Expr (e.Substitution) e.ClosureContent>
              );

          t.OtherTerm = t.OtherTerm;
        }
        e.Expression
      >;
}

Spec-FindInSignatures {
  (e.Signature)
  e.Signatures-B ((e.InstanceName) e.Signature) e.Signatures-E
    = Found e.InstanceName
      (((e.InstanceName) e.Signature) e.Signatures-B e.Signatures-E);

  (e.Signature) e.Signatures = NotFound e.Signatures;
}

/**
  <IsTrivialSubstitutions e.StaticMatches>
*/
IsTrivialSubstitutions {
  e.StaticMatches
    = <Reduce
        {
          False t.Any = False;

          True ((TkVariable s.Mode e.Index1) ':' (TkVariable s.Mode e.Index2))
            = True;

          True ((TkVariable s.Mode e.Index1) ':' (s.Mode e.Index2))
            = True;

          True t.OtherSubstitution = False;
        }
        True
        e.StaticMatches
      >;
}

PrepareArgOrPattern {
  (e.StaticMatches) (e.DynamicMatches) e.SpecPattern

    /*
      ExtractVariables-Expr сохраняет относительный порядок переменных,
      однако оставляет дубликаты. Но в e.SpecPattern это не критично,
      поскольку все переменные в нём должны быть уникальны (иначе
      синтаксическая ошибка).
    */
    = <ExtractVariables-Expr e.SpecPattern> : e.SpecVars

    = <MapAccum
        {
          (e.KnownVarsFromStatic) (s.Mode e.Index)
            , e.StaticMatches
            : e._B (e.Expr ':' (TkVariable s.Mode e.Index)) e._E
            = <MapAccum
                {
                  (e.KnownVarsFromStatic^) (s.Mode^ e.Index^)
                    , e.KnownVarsFromStatic : e._B1 (s.Mode e.Index) e._E1
                    = (e.KnownVarsFromStatic)
                      /* пропускаем переменную */;

                  (e.KnownVarsFromStatic^) (s.Mode^ e.Index^)
                    = (e.KnownVarsFromStatic (s.Mode e.Index))
                      <WrapVar s.Mode (TkVariable s.Mode e.Index)>;
                }
                (e.KnownVarsFromStatic)
                <ExtractVariables-Expr e.Expr>
              >;

          (e.KnownVarsFromStatic) (s.Mode e.Index)
            , e.DynamicMatches
            : e._B (e.Expr ':' (TkVariable s.Mode e.Index)) e._E
            = (e.KnownVarsFromStatic) <WrapVar s.Mode e.Expr>;
        }
        (/* Known vars from static */)
        e.SpecVars
      >
    : (e.KnownVarsFromStatic) e.NewArgOrPattern

    = <RemoveLastGhostBracket e.NewArgOrPattern>;
}

WrapVar {
  'e' e.Expr = (GhostBrackets e.Expr);
  s.Mode e.Expr = e.Expr
}

RemoveLastGhostBracket {
  e.NewArgOrPattern (GhostBrackets e.LastEValue)
    = <Map
        {
          (GhostBrackets e.Expr) = (Brackets e.Expr);
          t.STValue = t.STValue;
        }
        e.NewArgOrPattern
      >
      e.LastEValue;

  e.NewArgOrPattern t.STValue
    = <RemoveLastGhostBracket e.NewArgOrPattern> t.STValue;

  /* пусто */ = /* пусто */;
}

RenameGenericMatch {
  (e.SpecPattern) (e.StaticMatches) e.VarsFromBody
    = <Map
        {
          (e.Val ':' t.Var) = <ExtractVariables-Expr e.Val>;
        }
        e.StaticMatches
      >
    : e.VarsFromMatch

    = <Unique e.VarsFromMatch> : e.VarsFromMatch^

    = <MapAccum
        {
          (e.VarsFromBody^) (e.CurrentVarName)
            = <NewVarName (e.VarsFromBody) e.CurrentVarName>
            : (e.VarsFromBody^) e.NewVarName
            = (e.VarsFromBody)
              ((TkVariable e.NewVarName) ':' (e.CurrentVarName))
        }
        (e.VarsFromBody)
        e.VarsFromMatch
      >
    : (e.VarsFromBody^) e.Renames

    = <ApplySubst-Subst (e.Renames) e.StaticMatches>;
}

PrepareSpecializedFuncBody {
  (e.SpecPattern) (e.StaticMatches) e.Body
    = <ExtractVariables e.Body> : e.BodyVariables

    = <RenameGenericMatch (e.SpecPattern) (e.StaticMatches) e.BodyVariables>
    : e.StaticMatches^

    = <Map (&PrepareSpecSentence (e.SpecPattern) (e.StaticMatches)) e.Body>;
}

PrepareSpecSentence {
  (e.SpecPattern) (e.CallStaticMatches)
  ((e.Pattern) e.Conditions (e.Result))
    = <GenericMatch-Wrapper (e.Pattern) (e.SpecPattern)>
    : Clear (e.PatternStaticMatches) (e.PatternDynamicMatches)

    = <MapGenericMatches (e.CallStaticMatches) (e.PatternStaticMatches)>
    : e.StaticSubstitutions

    = <ApplySubst-Subst (e.StaticSubstitutions) e.PatternDynamicMatches>
    : e.PatternDynamicMatches^

    = <PrepareArgOrPattern
        (e.CallStaticMatches) (e.PatternDynamicMatches) e.SpecPattern
      >
    : e.Pattern^

    = <PrepareSpecConditions (e.StaticSubstitutions) e.Conditions>
    : e.Conditions^

    = <ApplySubst-Expr (e.StaticSubstitutions) e.Result> : e.Result^

    = ((e.Pattern) e.Conditions (e.Result));
}

PrepareSpecConditions {
  (e.StaticSubstitutions) e.Conditions
    = <Map
        {
          (Condition (e.Name) (e.ConditionResult) (e.ConditionPattern))
            = (Condition
                (e.Name)
                (<ApplySubst-Expr (e.StaticSubstitutions) e.ConditionResult>)
                (<ApplySubst-Expr (e.StaticSubstitutions) e.ConditionPattern>)
              );
        }
        e.Conditions
      >
}

/*
  Вспомогательные функции модуля
*/

GenericMatch-Wrapper {
  (e.Expr) (e.HardExpr)
    = <GenericMatch (e.Expr) (e.HardExpr)>
    : {
        Clear e.VarsMatches
          = <MapAccum
              {
                (e.StaticMatches) (e.Val ':' (e.Var))
                  , e.Var : s.Mode e.Index
                  , <IsSpecStaticVar (e.Var)> : True
                  = (e.StaticMatches (e.Val ':' (TkVariable e.Var)))
                    /* пусто */;

                (e.StaticMatches) (e.Val ':' (e.Var))
                  = (e.StaticMatches)
                    (e.Val ':' (TkVariable e.Var));
              }
              (/* for statics */)
              e.VarsMatches
            >
          : (e.StaticMatches) e.DynamicMatches
          = Clear (e.StaticMatches) (e.DynamicMatches);

        s.OtherResult e.ResultInfo
          = s.OtherResult e.ResultInfo;
      };
}

IsSpecStaticVar {
  (s.Mode s.FirstSymbol e.Index)
    , <Type s.FirstSymbol>
    : {
        'Lu' s._ = True;
        e._ = False;
      };
}

MapGenericMatches {
  (e.ArgStaticMatches) (e.PatternStaticMatches)
    = <Reduce
        {
          (
            (e.ArgStaticMatches-B (e.ArgVal ':' t.SpecVar) e.ArgStaticMatches-E)
            (e.MappedMatches)
          )
          ((TkVariable s.Mode e.Index) ':' t.SpecVar)
            = (
                (
                  e.ArgStaticMatches-B (e.ArgVal ':' t.SpecVar)
                  e.ArgStaticMatches-E
                )
                (e.MappedMatches (e.ArgVal ':' (s.Mode e.Index)))
              );
        }
        ((e.ArgStaticMatches) (/* for result */))
        e.PatternStaticMatches
      >
    : ((e._) (e.ResultMatches))
    = e.ResultMatches;
}

/*
  Функции, относящиеся к проверке отношения Хигмана-Крускала
*/

/**
  <HasHigmanKruskalRelation (e.Name) (e.Signature) e.History>
    == True e.HistorySignature
    == False

  Функция проверяет, выполняется ли отношение Хигмана-Крускала
  для одной из сигнатур в e.History и сигнатуры e.Signature,
  то есть проверяется, можно ли вложить одну сигнатуру в другую,
  удалив некоторые элементы.
  В случае, если в истории сигнатур удаётся найти сигнатуру,
  для которой выполняется указанное отношение,
  функция возвращает True и соответствующий e.HistorySignature.
  В ином случае возвращается False.
*/
HasHigmanKruskalRelation {
  (e.Name) (e.Signature) e.History ((e.InstanceName) e.HistorySignature)
    , <SourceNameOfInstance e.InstanceName> : e.Name
    , <CheckSignaturesPairForRelation
        (e.Signature) <CanonizeSignature e.HistorySignature>
      >
    : True
    = True e.HistorySignature;

  (e.Name) (e.Signature) e.History ((e.InstanceName) e.HistorySignature)
    = <HasHigmanKruskalRelation (e.Name) (e.Signature) e.History>;

  (e.Name) (e.Signature) /* пустая история */ = False;
}

SourceNameOfInstance {
  e.Name SUF '@' s._ = e.Name;
  e.Name '@' s._ = e.Name;
}

/**
  <CheckSignaturesPairForRelation (e.CurrentSignature) e.HistorySignature>
    == True
    == False

  Проверяет выполнение отношения Хигмана-Крускала для двух сигнатур.
  Возвращает True, если отношение выполняется, и False в ином случае.

  e.CurrentSignature, e.HistorySignature ::= t.StaticVarVals*
  t.StaticVarVals ::= (t.Term*)
  t.Term ::=
      (Symbol s.SymType e.SymInfo)
    | (TkVariable 't' e.Index)
    | (TkVariable 's' e.Index)
    | (TkVariable 'e' e.Index)
    | (ADT-Brackets t.Name t.Term*)
    | (Brackets t.Term*)
    | (ClosureBrackets t.Term*)
    | (CallBrackets t.Name t.Term*)
*/
CheckSignaturesPairForRelation {
  (/* пусто */) /* пусто */ = True;

  (e.CurrentSignature) e.HistorySignature

    /* Берём часть сигнатур для одной статической переменной */
    , e.CurrentSignature
    : (e.CurrentSignature-CurVar) e.CurrentSignature-Rest

    , e.HistorySignature
    : (e.HistorySignature-CurVar) e.HistorySignature-Rest

    , <CheckSignaturesPairForRelation-OneVar
        (e.CurrentSignature-CurVar) e.HistorySignature-CurVar
      >
    : {
        True
          = <CheckSignaturesPairForRelation
              (e.CurrentSignature-Rest) e.HistorySignature-Rest
            >;

        False = False;
    };
}

CheckSignaturesPairForRelation-OneVar {
  (e.CurrentSignature-CurVar) e.HistorySignature-CurVar
    /* Разделяем текущую сигнатуру на две части  */
    , e.CurrentSignature-CurVar : t.Term e.OtherPart

    = <DoCheckSignaturesPairForRelation
        (t.Term) (e.OtherPart) e.HistorySignature-CurVar
      >;

  (e.CurrentSignature-CurVar) e.HistorySignature-CurVar
    , e.CurrentSignature-CurVar : /* пусто */
    = e.HistorySignature-CurVar
    : {
        /* пусто */ = True;
        e._ = False;
      };
}

/**
  <DoCheckSignaturesPairForRelation
    (e.CurSig1) (e.CurSig2) e.HistorySignature
  >
    == True
    == False

  Одна итерация функции CheckSignaturesPairForRelation.

  e.CurSig1 ::= t.Term*
  e.CurSig2 ::= t.Term*
  e.HistorySignature ::= t.Term*
*/
DoCheckSignaturesPairForRelation {
  (e.CurSig1) (e.CurSig2) e.HistorySignature

    /* Проверяем, содержится ли полностью в e.CurSig1 */
    , <ContainsSignature (e.CurSig1) e.HistorySignature> : True

    = True;

  (e.CurSig1) (e.CurSig2) e.HistorySignature

    /* Проверяем, содержится ли полностью в e.CurSig2 */
    , <ContainsSignature (e.CurSig2) e.HistorySignature> : True

    = True;

  (e.CurSig1) (e.CurSig2) e.HistorySignature

    /* Проверяем, что часть e.HistorySignature содержится в e.CurSig1 */
    , <PartiallyContainsSignature (e.CurSig1) e.HistorySignature>
    : True e.HistorySignature-Rest

    /* Проверяем, что оставшаяся часть содержится в e.CurSig2 */
    , <ContainsSignature (e.CurSig2) e.HistorySignature-Rest>
    : True

    = True;

  (e.CurSig1) (e.CurSig2) e.HistorySignature = False;
}

/**
  <ContainsSignature (e.Expr) e.Signature>
    == True
    == False

  Проверяет, что выражение содержит сигнатуру.

  e.Expr ::= t.Term*
  e.Signature ::= t.Term*
*/
ContainsSignature {
  (e.Expr-B e.Signature e.Expr-E) e.Signature
    = True;

  /*
    Если выражение и сигнатура из истории начинаются на одинаковый терм,
    то выражение вкладывается в сигнатуру тогда и только тогда, когда
    вкладываются их хвосты.
  */
  (t.Common e.Expr) t.Common e.Signature
    = <ContainsSignature (e.Expr) e.Signature>;

  /*
    Оптимизация частнoго случая: аналогично можно поступить и с последним
    общим термом.
  */
  (e.Expr t.Common) e.Signature t.Common
    = <ContainsSignature (e.Expr) e.Signature>;

  /*
    Если первый токен у обеих сигнатур - скобки,
    пытаемся их убрать у обеих сигнатур и посмотреть,
    есть ли вложение без них
  */
  ((s.TermType e.Inner) e.RestExpr) (s.TermType e.OtherInner) e.OtherRestExpr
    , e.Inner : t.Inner-FirstTerm e.Inner-Rest
    , e.OtherInner : t.OtherInner-FirstTerm e.OtherInner-Rest

    /*
      Проверяем, что первый элемент - скобки, и
      в зависимости от типа скобок определяем
      её внутреннее выражение
    */
    , s.TermType :
      {
        Brackets
          = True e.Inner;

        ClosureBrackets
          = True e.Inner;

        ADT-Brackets
          , e.Inner
          : (e.Name) e.ADT-Brackets-Inner-Rest
          = True e.ADT-Brackets-Inner-Rest;

        CallBrackets
          , e.Inner
          : (e.SymbolName) e.Argument
          = True e.Argument;

        e.OtherTermType
          = False;
      }
    : True e.Inner^

    , e.Inner :
      {
        t.Inner-FirstTerm^ e.Inner-Rest^
          = <DoCheckSignaturesPairForRelation
              (t.Inner-FirstTerm) (e.Inner-Rest) e.OtherInner
            >;

        e.Expr
          = <DoCheckSignaturesPairForRelation
              (e.Expr) (/* пусто */) e.OtherInner
            >;
      }
    : s.InnerCheckResult

    , s.InnerCheckResult
    : True

    , e.RestExpr :
      {
        t.RestExpr-Term e.RestExpr-Rest
          = <DoCheckSignaturesPairForRelation
              (t.RestExpr-Term) (e.RestExpr-Rest) e.OtherRestExpr
            >;

        e.Expr
          = <DoCheckSignaturesPairForRelation
              (e.Expr) (/* пусто */) e.OtherRestExpr
            >;
      }
    : s.RestExprCheckResult

    , s.RestExprCheckResult
    : True

    = True;

  ((s.TermType e.Inner) e.RestExpr) e.Signature
    , e.Inner : t.Inner-FirstTerm e.Inner-Rest
    = s.TermType
    :  {
        Brackets
          = <DoCheckSignaturesPairForRelation
              (t.Inner-FirstTerm) (e.Inner-Rest e.RestExpr) e.Signature
            >;

        ADT-Brackets
          , e.Inner
          : (e.Name) t.ADT-Brackets-Inner-FirstTerm e.ADT-Brackets-Inner-Rest
          = <DoCheckSignaturesPairForRelation
              (t.ADT-Brackets-Inner-FirstTerm)
              (e.ADT-Brackets-Inner-Rest e.RestExpr) e.Signature
            >;

        CallBrackets
          , e.Inner : (e.SymbolName) e.Argument
          , e.Argument : t.Argument-FirstTerm e.Argument-RestExpr
          = <DoCheckSignaturesPairForRelation
              (t.Argument-FirstTerm) (e.Argument-RestExpr e.RestExpr)
              e.Signature
            >;

        ClosureBrackets
          = <DoCheckSignaturesPairForRelation
              (t.Inner-FirstTerm) (e.Inner-Rest e.RestExpr) e.Signature
            >;

        TkVariable
          = <DoCheckSignaturesPairForRelation
              (/* пусто */) (e.RestExpr) e.Signature
            >;

        Symbol
          = <DoCheckSignaturesPairForRelation
              (/* пусто */) (e.RestExpr) e.Signature
            >;

        s.OtherTermType
          = False;
      };

  (e.Expr) e.Signature = False;
}

/**
  <PartiallyContainsSignature (e.Expr) e.Signature>
    == True e.SignaturePart
    == False

  Проверяет, что выражение частично содержит сигнатуру.
  Если была обнаружена часть сигнатуры,
  содержащаяся в выражении, возвращает True, за которым
  следует остальная часть сигнатуры.
  Иначе возвращает False.

  e.Expr ::= t.Term*
  e.Signature ::= t.Term*
*/
PartiallyContainsSignature {
  (e.Expr) e.Signature
    /* Если выражение из истории пусто, возвращаем False */
    , e.Signature : /*пусто*/
    = False;

  (e.Expr) e.Signature

    /* Разделяем сигнатуру из истории на две части */
    , e.Signature : e.Signature-Part t.LastTerm

    /* Проверяем, что e.Signature-Part не пусто */
    , e.Signature-Part : t.FirstTerm e.OtherPart

    /*
      Если текущая сигнатура содержит часть сигнатуры из истории,
      возвращаем True и остальную часть, которую она не содержит.
    */
    , <ContainsSignature (e.Expr) e.Signature-Part>
    : True

    = True t.LastTerm;

  /*
    Отщепляем последний терм от сигнатуры из истории и вызываем рекурсию,
    в конце добавляем последний терм, который отщепили.
   */
  (e.Expr) e.Signature-Part t.LastTerm
    = <PartiallyContainsSignature
        (e.Expr) e.Signature-Part
      >
      t.LastTerm;
}

/**
  <CanonizeSignature e.Signature> == e.Signature^

  * Убирает имена переменных в сигнатуре, оставляет их типы данных.
*/
CanonizeSignature {
  e.Signature
    = <Map
        {
          (e.SignaturePart)
            = <CanonizeSignature-Expr e.SignaturePart>
            : e.SignaturePart^
            = (e.SignaturePart);
        }
        e.Signature
      >
    : e.Signature^
    = e.Signature;
}

CanonizeSignature-Expr {
  e.Expr = <Map &CanonizeSignature-Term e.Expr>;
}

CanonizeSignature-Term {
  (TkVariable s.Mode e.Index)
    = (TkVariable s.Mode);

  (s.BracketsTag e.Expr)
    , <OneOf s.BracketsTag CallBrackets ClosureBrackets Brackets> : True
    = <CanonizeSignature-Expr e.Expr> : e.Expr^
    = (s.BracketsTag e.Expr);

  (ADT-Brackets (e.Name) e.Expr)
    = <CanonizeSignature-Expr e.Expr> : e.Expr^
    = (ADT-Brackets (e.Name) e.Expr);

  (Symbol Number s._) = (Symbol Number);

  t.OtherTerm = t.OtherTerm;
}

/* Выполняет обобщение */
MakeGeneralization {
  (e.Signature) (e.HistorySignature) (e.Argument)
  (e.SpecPattern) (e.StaticMatches) (e.Name)
  (e.Body) s.NextNumber (e.Signatures) (e.DynamicMatches)
  (e.History) (e.Calls)

    /* Получаем обобщение двух сигнатур */
    = <GetSignaturesGeneralization
        (e.Signature) e.HistorySignature
      >
    : e.GenSignature

    /* Находим имеющиеся в аргументе переменные */
    = <ExtractVariables-Expr e.Argument> : e.ArgumentVars

    /*
      Присваиваем переменным в сигнатуре имена,
      отличные от имён переменных в аргументе e.Argument
    */
    = <NameSignatureVars (e.ArgumentVars) e.GenSignature> : e.GenStaticMatches

    /* Получаем переменные из e.SpecPattern */
    = <ExtractVariables-Expr e.SpecPattern> : e.SpecPatternVars

    /*
      Частям обобщённой сигнатуры приписываем имена статических переменных
    */
    = <GetSignaturesGeneralizationMatches
        (e.SpecPatternVars) e.GenStaticMatches
      >
    : e.GenStaticMatches^

    /* Формируем e.RealSubst через GenericMatch */
    = <GetRealSubst (e.StaticMatches) (e.GenStaticMatches)> : e.RealSubst

    = <IsTrivialSubstitutions e.RealSubst>
    : {
        /*
          Если подстановка e.RealSubst является тривиальной,
          проверку отношения Хигмана-Крускала
          в рекурсивном вызове не выполняем
        */
        True = False;

        False = True;
      }
    : s.NeedRelationCheck

    /* Для e.GenStaticMatches вызываем SpecCall-Matches */
    = <SpecCall-Matches
        (e.Name) (e.SpecPattern) (e.Body) s.NextNumber e.Signatures
        (e.Argument) (e.GenStaticMatches)
        (e.DynamicMatches) (e.History) s.NeedRelationCheck
      >
    : t.Info
      t.NewCall
      e.NewFunc
      (e.NewHistory)

    /* К новому вызову применяем подстановку*/
    = <ApplySubst-Expr (e.RealSubst) t.NewCall> : t.NewCall^
    = <ApplySubst-Expr (e.Calls) t.NewCall> : t.NewCall^

    = t.Info
      t.NewCall
      e.NewFunc
      (e.NewHistory);
}

/*
  Назначает имена переменным в сигнатуре,
  отличные от тех, что есть в e.KnownVars.
*/
NameSignatureVars {
  (e.KnownVars) e.Signature
    = <MapAccum
        {
          (e.KnownVars^) (e.SignaturePart)
            = <NameSignatureVars-Expr (e.KnownVars) e.SignaturePart>
            : (e.KnownVars^) e.SignaturePart^
            = (e.KnownVars) (e.SignaturePart);
        }
        (e.KnownVars)
        e.Signature
      >
    : (e.KnownVars^) e.Signature^
    = e.Signature;
}

NameSignatureVars-Expr {
  t.State e.Expr = <MapAccum &NameSignatureVars-Term t.State e.Expr>;
}

NameSignatureVars-Term {
  (e.KnownVars) (TkVariable s.Mode)
    = <NewVarName (e.KnownVars) s.Mode 'X' 0> : (e.KnownVars^) e.Index
    = (e.KnownVars)
      (TkVariable e.Index);

  t.State (s.BracketsTag e.Expr)
    , <OneOf s.BracketsTag CallBrackets ClosureBrackets Brackets> : True
    = <NameSignatureVars-Expr t.State e.Expr> : t.State^ e.Expr^
    = t.State (s.BracketsTag e.Expr);

  t.State (ADT-Brackets (e.Name) e.Expr)
    = <NameSignatureVars-Expr t.State e.Expr> : t.State^ e.Expr^
    = t.State (ADT-Brackets (e.Name) e.Expr);

  t.State t.OtherTerm = t.State t.OtherTerm;
}

/*
  Получает обобщённую сигнатуру для двух сигнатур.
  Перебирает статические переменные сигнатур по очереди.
*/
GetSignaturesGeneralization {
  (t.Sig1-StaticVarPart e.Sig1-Rest) t.Sig2-StaticVarPart e.Sig2-Rest
    = (<GlobalGen t.Sig1-StaticVarPart t.Sig2-StaticVarPart>)
      <GetSignaturesGeneralization (e.Sig1-Rest) e.Sig2-Rest>;

  (/* пусто */) /* пусто */
    = /* пусто */;
}

/*
  Возвращает соответствия между статическими переменными и
  частями обобщённой сигнатуры
*/
GetSignaturesGeneralizationMatches {
  (t.Var e.Vars) (e.GenSignature-First) e.GenSignature-E
    = <IsSpecStaticVar t.Var>
    : {
        True
          , t.Var : (e.VarInner)
          = (e.GenSignature-First ':' (TkVariable e.VarInner))
            <GetSignaturesGeneralizationMatches
              (e.Vars) e.GenSignature-E
            >;

        False
          = <GetSignaturesGeneralizationMatches
              (e.Vars) (e.GenSignature-First) e.GenSignature-E
            >;
      };

  e.OtherExpr
    = /* пусто */;
}

GetRealSubst {
  (e.StaticMatches-B (e.Val1 ':' (TkVariable e.Var)) e.StaticMatches-E)
  (e.GenStaticMatches-B (e.Val2 ':' (TkVariable e.Var)) e.GenStaticMatches-E)
    = <GenericMatch (e.Val1) (e.Val2)>
    : {
        Clear e.Expr
          = e.Expr
            <GetRealSubst
              (e.StaticMatches-B e.StaticMatches-E)
              (e.GenStaticMatches-B e.GenStaticMatches-E)
            >;

        e.Other
          = <GetRealSubst
              (e.StaticMatches-B e.StaticMatches-E)
              (e.GenStaticMatches-B e.GenStaticMatches-E)
            >;
      };

  e.OtherExpr
    = /* пусто */;
}
