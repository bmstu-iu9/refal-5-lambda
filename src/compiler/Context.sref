//FROM LibraryEx
$EXTERN Fetch, Inc, Dec;


/**
  В данном модуле описывается контекст -- обобщение понятия таблицы
  переменных. Контекст позволяет отслеживать как правильность использования
  переменных (объявленность переменных, используемых в результатном выражении,
  уникальность переменной с данным именем и режимом (s, t или e)), так и
  отслеживать свободные и связанные переменные в данной функции -- собственно
  контекст, передаваемый в замыкания.

  ВНИМАНИЕ! Здесь используется терминология лямбда-исчисления:
  * Переменная называется СВЯЗАННОЙ, если она является аргументом данной
    лямбда-абстракции, т.е. первый раз связывается в данном образце.
  * Переменная называется СВОБОДНОЙ, если она не объявлена внутри данной
    лямбда-абстракции, т.е. она связана где-то вовне.
  Пример: \ac.abcd, переменные a и c — связанные, b и d — свободные.
*/

$ENUM Context;
/*
  Внутренняя структура контекста:
  [Context
    s.StackDepth
    e.Variables1 (#FreeVarsSent e.FreeSent1) (#FreeVarsFunc e.FreeFunc1)
    e.Variables2 (#FreeVarsSent e.FreeSent2) (#FreeVarsFunc e.FreeFunc2)
    ...
    e.VariablesN (#FreeVarsSent) (#FreeVarsFunc)
  ]
  e.VariablesK, e.FreeSentK, e.FreeFuncK ::= (s.Mode e.Index s.VarDepth)*

  s.StackDepth — глубина вложенности вложенных функций.
  s.VarDepth — уровень стека, на котором появилась данная переменная. Для
  связанных переменных всегда равен текущему s.StackDepth, для свободных —
  глубине стека на момент связывания.

  e.VariablesK представляет собой набор связанных переменных -- переменных,
  упоминаемых в образце данного предложения K-го по вложенности тела функции.

  e.Free***K представляет собой набор свободных переменных K-го по вложенности
  тела функции (эти переменные являются повторными для образцового выражения,
  присутсвуют во внешних функциях).

  e.FreeSentK представляет собой список свободных переменных, обнаруженных
  во время анализа данного предложения. Список пополняется при появлении
  в образце либо в результате переменной, имеющейся в окружающем контексте.

  e.FreeFuncK представляет собой список свободных переменных, обнаруженных
  во всех предыдущих предложениях включительно. По завершении анализа предло-
  жения в e.FreeFuncK должны быть добавлены e.FreeSentK.

  e.Variables1 и e.Free***1 соответствуют самой вложенной функции,
  e.VariablesN -- глобальной функции (для глобальной функции отсутствует
  понятие свободных переменных).
*/

/**
  <Cntx-Create> == t.Context
*/
$ENTRY Cntx-Create {
  = [Context 0];
}

/**
  <Cntx-Destroy t.Context> == пусто
*/
$ENTRY Cntx-Destroy {
  [Context 0] = ;
}

/**
  <Cntx-AddVariable t.Context s.Mode e.Index>
    == t.Context # Success s.Depth
    == t.Context # InvalidMode s.Depth s.OldMode
*/
$ENTRY Cntx-AddVariable {
  [Context
    s.StackDepth e.Variables-B (s.Mode e.Index s.VarDepth) e.Variables-E
  ]
  s.Mode e.Index =
    /*
      Идея тут в том, что если в e.Variables-B имеется хотя бы один
      (Free e.Free), то данная переменная является свободной для текущего
      функционального блока и её надо сохранить в список свободных переменных
      (из-за того, что переменные добавляются слева направо, этот список
      будет самым левым), что, собственно и делает функция ShiftVariable.

      На этот комментарий ссылаются из функции Cntx-CheckVariable.
    */
    [Context
      s.StackDepth
      <ShiftVariable (s.Mode e.Index s.VarDepth) e.Variables-B>
      (s.Mode e.Index s.VarDepth)
      e.Variables-E
    ]
    # Success s.VarDepth;

  [Context
    s.StackDepth e.Variables-B (s.OldMode e.Index s.VarDepth) e.Variables-E
  ]
  s.NewMode e.Index =
    [Context
      s.StackDepth e.Variables-B (s.OldMode e.Index s.VarDepth) e.Variables-E
    ]
    # InvalidMode s.VarDepth s.OldMode;

  [Context s.StackDepth e.Variables] s.Mode e.Index =
    [Context s.StackDepth (s.Mode e.Index s.StackDepth) e.Variables]
    # Success s.StackDepth;
}

ShiftVariable {
  (s.Mode e.Index s.VarDepth)
  e.Variables-B
  (#FreeVarsSent e.Free) (#FreeVarsFunc e.FreeFunc)
  e.Variables-E =
    e.Variables-B (s.Mode e.Index s.VarDepth)
    (#FreeVarsSent <ShiftVariable-AddToFree (s.Mode e.Index s.VarDepth) e.Free>)
    (#FreeVarsFunc e.FreeFunc)
    <ShiftVariable (s.Mode e.Index s.VarDepth) e.Variables-E>;

  (s.Mode e.Index s.VarDepth) e.Variables = e.Variables;
}

ShiftVariable-AddToFree {
  (s.Mode e.Index s.VarDepth)
  e.Variables-B (s.Mode e.Index s.VarDepth) e.Variables-E =
    e.Variables-B (s.Mode e.Index s.VarDepth) e.Variables-E;

  (s.Mode e.Index s.VarDepth) e.Variables =
    e.Variables (s.Mode e.Index s.VarDepth);
}

/**
  <Cntx-AddNewVariable t.Context s.Mode e.Index>
    == t.Context # Success s.Depth
    == t.Context # InvalidMode s.Depth s.OldMode
    == t.Context # AlreadyBounded s.Depth

  Эта функция в отличие от Cntx-AddVariable добавляет переменную как
  имеющую область видимости начиная с текущей функции: если в области
  видимости имеется переменная с тем же именем, что и в данной функции,
  то она сокрывается.
  Если переменная уже упоминалась ранее в текущем образце, функция возвращает
  # AlreadyBounded, что является ошибкой.
*/
$ENTRY Cntx-AddNewVariable {
  [Context
    s.StackDepth
    e.LocalVars (#FreeVarsSent e.FreeSent) (#FreeVarsFunc e.FreeFunc) e.Stack
  ]
  s.Mode e.Index =
    <Fetch
      e.LocalVars
      {
        e.LocalVars-B (s.Mode e.Index s.Depth) e.LocalVars-E =
          [Context
            s.StackDepth
            e.LocalVars-B (s.Mode e.Index s.Depth) e.LocalVars-E
            (#FreeVarsSent e.FreeSent) (#FreeVarsFunc e.FreeFunc)
            e.Stack
          ]
          # AlreadyBounded s.Depth;

        e.LocalVars-B (s.OldMode e.Index s.VarDepth) e.LocalVars-E =
          [Context
            s.StackDepth
            e.LocalVars-B (s.OldMode e.Index s.VarDepth) e.LocalVars-E
            (#FreeVarsSent e.FreeSent) (#FreeVarsFunc e.FreeFunc)
            e.Stack
          ]
          # InvalidMode s.VarDepth s.OldMode;

        e.LocalVars^ =
          [Context
            s.StackDepth
            (s.Mode e.Index s.StackDepth) e.LocalVars
            (#FreeVarsSent e.FreeSent) (#FreeVarsFunc e.FreeFunc)
            e.Stack
          ]
          # Success s.StackDepth;
      }
    >;
}

/**
  <Cntx-CheckVariable t.Context s.Mode e.Index>
    == t.Context # ExistVariable s.Depth
    == t.Context # InvalidMode s.Depth s.OldMode
    == t.Context # NotFound
*/
$ENTRY Cntx-CheckVariable {
  [Context
    s.StackDepth e.Variables-B (s.Mode e.Index s.VarDepth) e.Variables-E
  ]
  s.Mode e.Index =
    [Context
      s.StackDepth
      // См. комментарий в Cntx-AddVariable
      <ShiftVariable (s.Mode e.Index s.VarDepth) e.Variables-B>
      (s.Mode e.Index s.VarDepth)
      e.Variables-E
    ]
    # ExistVariable s.VarDepth;

  [Context
    s.StackDepth e.Variables-B (s.OldMode e.Index s.VarDepth) e.Variables-E
  ]
  s.NewMode e.Index =
    [Context
      s.StackDepth e.Variables-B (s.OldMode e.Index s.VarDepth) e.Variables-E
    ]
    # InvalidMode 00 s.OldMode;

  [Context s.StackDepth e.Variables] s.Mode e.Index =
    [Context s.StackDepth e.Variables] # NotFound;
}

/**
  <Cntx-ResetAfterSentence t.Context> == t.Context
*/
$ENTRY Cntx-ResetAfterSentence {
  [Context
    s.StackDepth
    e.Locals (#FreeVarsSent e.FreeSent) (#FreeVarsFunc e.FreeFunc)
    e.Outers
  ] =
    [Context
      s.StackDepth
      (#FreeVarsSent) (#FreeVarsFunc <Unique e.FreeSent e.FreeFunc>)
      e.Outers
    ];
}

Unique {
  e.Begin t.Copy e.Middle t.Copy e.End =
    e.Begin <Unique t.Copy e.Middle e.End>;

  e.Uniques = e.Uniques;
}

/**
  <Cntx-PushScope t.Context> == t.Context
*/
$ENTRY Cntx-PushScope {
  [Context s.StackDepth e.Variables] =
    [Context
      <Inc s.StackDepth>
      (#FreeVarsSent) (#FreeVarsFunc) e.Variables
    ];
}

/**
  <Cntx-PopScope t.Context>
    == t.Context
*/
$ENTRY Cntx-PopScope {
  [Context
    s.StackDepth
    (#FreeVarsSent) (#FreeVarsFunc e.ClosureContext)
    e.Outers
  ] =
    [Context <Dec s.StackDepth> e.Outers];
}
