$INCLUDE "LibraryEx";


*$FROM Log
$EXTERN Log-PutLine;

*$FROM DisplayName
$EXTERN DisplayName;

*$FROM TreeUtils
$EXTERN HashName, ExtractVariables, IsLExpr, MarkAllVarsAsWhole,
  ApplyContractions, UnmarkWholeVars;

*$FROM OptTree-Drive-Expr
$EXTERN OptTree-Drive-Expr;


/*
  В дерево добавляется узел (DriveInfo e.DriveInfo).

  e.DriveInfo ::= (e.OptFuncNames) e.OptFunctions
  e.OptFuncNames ::= e.HashSet
  e.HashSet ::= s.BucketSize (e.Bucket)*
  e.Bucket ::= (s.Hash (s.Label e.Name)*)
  e.OptFunctions ::= s.ContractMode (Metatables s.Metatable*) t.OptFunction*

  s.ContractMode ::= Contractions-Enabled | Contractions-Disabled
  t.OptFunction ::= ((e.Name) Sentences e.Sentences)
  t.Metatable ::= ((e.Name) e.Metatable)
*/


/**
  <OptTree-Drive-Prepare (s.OptDrive s.OptIntrinsic) e.AST> == e.AST

  s.OptDrive ::= OptDrive | OptInline | NoOpt
  s.OptIntrinsic ::= OptIntrinsic | NoOpt
*/
$ENTRY OptTree-Drive-Prepare {
  (NoOpt NoOpt) e.AST = e.AST;

  (s.OptDrive s.OptIntrinsic) e.AST
    = <UpdateDriveInfo s.OptDrive s.OptIntrinsic e.AST>;
}

/* Функция генерирует имена остаточных прогоняемых функций */

GenRemainderFuncNames {
  s.Label e.Name s.End s.End = /* пусто — пустую функцию прогнать нельзя */;

  s.Label e.Name s.Cur s.End
    = (s.Label <AddStarSuffix e.Name s.Cur>)
      <GenRemainderFuncNames s.Label e.Name <+ 1 s.Cur> s.End>;
}

AddStarSuffix {
  e.Name 0 = e.Name;
  e.Name SUF e.Suffix s.Count = e.Name SUF e.Suffix '*' s.Count;
  e.Name s.Count = e.Name SUF '*' s.Count;
}

BaseName {
  e.Name SUF '*' s.Count = e.Name s.Count;
  e.Name '*' s.Count = e.Name s.Count;
  e.Name /* нет суффикса */ = e.Name 0;
}

UpdateDriveInfo {
  s.OptDrive s.OptIntrinsic e.AST

*     Игнорируем старую разметку
    = e.AST
    : {
        e.AST-B (DriveInfo e._) e.AST-E = e.AST-B e.AST-E;
        e.AST^ = e.AST;
      }
    : e.AST^

    = <ExtractLabels Drives e.AST> : (e.Drives) e.AST^
    = <ExtractLabels Intrinsics e.AST> : (e.Intrinsics) e.AST^

    = e.AST
    : {
        e.AST-B (NoDrives e.Names) e.AST-E
          = (e.Names) e.AST-B (NoDrives e.Names) e.AST-E;

        e.AST^ = (/* пусто */) e.AST;
      }
    : (e.NoDrives) e.AST^

    = <SetNames-Reject (e.Drives) (e.NoDrives)> : e.Drives^

    = <Map
        {
          ((e.Label) e.Set)
            = <Map
                {
                  (e.Name)
                    = <DisplayName e.Name> : e.Name^
                    = <Log-PutLine 'New $' e.Label ' function: ' e.Name>
                }
                e.Set
              >
        }
        (('DRIVE') e.Drives) (('INTRINSIC') e.Intrinsics)
      >
    : /* пусто */

    = s.OptDrive
    : {
        NoOpt = /* пусто */;
        OptInline = <Map { (e.Name) = (Inline e.Name) } e.Drives>;
        OptDrive = <Map { (e.Name) = (Drive e.Name) } e.Drives>;
      }
    : e.Drives^

    = <ExtractBaseNames e.Drives> : e.DrivesBaseNames
    = <ExtractDriveFunctions (e.DrivesBaseNames) e.AST> : (e.DriveFuncs) e.AST^

    = <ExtractMetatables  e.AST> : (e.Metatables) e.AST^

    = <ExtractFuncLengths e.AST> : (e.Lengths) e.AST^
    = <MultiplyRemainderNames (e.Lengths) e.Drives> : e.Drives^

    = s.OptIntrinsic
    : {
        NoOpt = /* пусто */;
        OptIntrinsic = e.Intrinsics;
      }
    : e.Intrinsics^

    = <Map
        {
          (e.Name) = ((e.Name) Intrinsic e.Name);
        }
        e.Intrinsics
      >
    : e.OptIntrinsicFuncs

    = <HashSet e.Drives e.Intrinsics> : e.HashSetNames

    = s.OptDrive
    : {
        NoOpt = Contractions-Disabled;
        OptInline = Contractions-Disabled;
        OptDrive = Contractions-Enabled;
      }
    : s.ContractionsMode

    = (DriveInfo
        (e.HashSetNames)
        s.ContractionsMode (e.Metatables)
        e.DriveFuncs e.OptIntrinsicFuncs
      )
      e.AST;
}

ExtractLabels {
  s.Node e.AST-B (s.Node e.Names) e.AST-E = (e.Names) e.AST-B e.AST-E;

  s.Node e.AST = (/* пусто */) e.AST;
}

ExtractMetatableNames {
  e.AST
    = <MapAccum
        {
          (e.Metatables) (Function (e.Name) Metatable e.Body)
            = (e.Metatables (Metatable e.Name))
              (Function (e.Name) Metatable e.Body);

          (e.Metatables) t.Other = (e.Metatables) t.Other;
        }
        (/* metatables */) e.AST
      >;
}

SetNames-Reject {
  (e.Minuent-B (e.Name) e.Minuent-E) (e.Subtr-B (e.Name) e.Subtr-E)
    = e.Minuent-B
      <SetNames-Reject (e.Minuent-E) (e.Subtr-B (e.Name) e.Subtr-E)>;

  (e.Minuent) (e.Subtrahend) = e.Minuent;
}

ExtractBaseNames {
  e.OptNames
    = <Map
        {
          (s.Label e.Name)
            = <BaseName e.Name> : e.BaseName s.Num
            = (s.Label e.BaseName);
        }
        e.OptNames
      >
    : e.BaseOptNames
    = <Unique e.BaseOptNames>;
}

ExtractDriveFunctions {
  (e.Names) e.AST
    = <MapAccum
        {
          ((e.Names-B (s._ e.Name) e.Names-E) e.Extracted)
          (Function (e.Name) e.Body)
            = (
                (e.Names-B e.Names-E)
                e.Extracted ((e.Name) e.Body)
              )
              (Function (e.Name) e.Body);

          ((e.Names^) e.Extracted) t.Other = ((e.Names) e.Extracted) t.Other;
        }
        ((e.Names) /* extracted */) e.AST
      >
    : ((/* должно быть пусто */) e.Extracted) e.AST^
    = (e.Extracted) e.AST;
}

ExtractFuncLengths {
  e.AST
    = <MapAccum
        {
          (e.Lengths) (Function (e.Name) Sentences e.Sentences)
            = <Lenw e.Sentences> : s.SentencesCount e.Sentences^
            = (e.Lengths (e.Name s.SentencesCount))
              (Function (e.Name) Sentences e.Sentences);

          (e.Lengths) t.Other = (e.Lengths) t.Other;
        }
        (/* длины */) e.AST
      >;
}

MultiplyRemainderNames {
  (e.Lengths) e.FuncNames
    = <MapAccum
        {
          (e.Lengths^) (s.Label e.OptName)
            = <BaseName e.OptName> : e.BaseName s.StartNum
            = e.Lengths : e.Lengths-B (e.BaseName s.SentencesCount) e.Lengths-E
            = (e.Lengths-B (e.BaseName s.SentencesCount) e.Lengths-E)
              <GenRemainderFuncNames
                s.Label e.BaseName s.StartNum s.SentencesCount
              >;
        }
        (e.Lengths) e.FuncNames
      >
    : (e._) e.RemainderNames
    = e.RemainderNames;
}

HashSet {
  e.Names
    = <BUCKET-SIZE>
      <DoHashSet
        <Map
          {
            (s.Label e.Name)
              = (<HashName e.Name <BUCKET-SIZE>> s.Label e.Name)
          }
          e.Names
        >
      >;
}

BUCKET-SIZE { = 101 }

DoHashSet {
  (s.Hash e.Name) e.Names
    = <DoHashSet-DoFillBucket e.Names (s.Hash (e.Name))> : e.Names^ (e.Bucket)
    = (e.Bucket) <DoHashSet e.Names>;

  /* нет имён */ = /* нет корзин */;
}

DoHashSet-DoFillBucket {
  e.Names-OtherHash (s.Hash e.Name) e.UnscannedNames (s.Hash e.Bucket)
    = e.Names-OtherHash
      <DoHashSet-DoFillBucket e.UnscannedNames (s.Hash e.Bucket (e.Name))>;

  e.Names-OtherHash (s.Hash e.Bucket) = e.Names-OtherHash (s.Hash e.Bucket);
}


/**
  <OptTree-Drive e.AST> == e.AST^
*/
$ENTRY OptTree-Drive {
  e.AST-B (DriveInfo e.DriveInfo) e.AST-E
    = <DriveInlineOptimizerTick (e.DriveInfo) e.AST-B e.AST-E>
}

/* Осуществляет прогонку или оптимизацию в зависимости от ключа */

DriveInlineOptimizerTick {
  t.OptInfo e.AST
    = <MapAccum
        {
          t.OptInfo^ (Function (e.Name) Sentences e.Sentences)
            = <OptFunction
                (Function (e.Name) Sentences e.Sentences)
                t.OptInfo
              >;

          t.OptInfo^ t.Other = t.OptInfo t.Other
        }
        t.OptInfo
        e.AST
      >
    : ((e.OptNames) e.OptFunctions) e.AST^

    = <MapAccum
        {
          (e.News-B (Function (e.Name) e.Body) e.News-E)
          (NewFunction (e.Name) e._)
            = (e.News-B (Function (e.Name) e.Body) e.News-E)
              /* пропускаем */;

          (e.NewFunctions) (NewFunction (e.Name) e.Body)
            = (e.NewFunctions (Function (e.Name) e.Body));

          (e.NewFunctions) t.Other = (e.NewFunctions) t.Other;
        }
        (/* new functions */) e.AST
      >
    : (e.NewFunctions) e.AST^

    = <MapAccum
        {
          (e.News-B (Function (e.Name) e._) e.News-E)
          (Function (e.Name) e.Body)
            = (e.News-B e.News-E)
              (Function (e.Name) e.Body);

          (e.News-B (Function (e.Name) e._) e.News-E)
          (ColdFunction s.ColdBy (e.Name) e.Body)
            = (e.News-B e.News-E)
              (ColdFunction s.ColdBy (e.Name) e.Body);

          (e.NewFunctions^) t.Other = (e.NewFunctions) t.Other;
        }
        (e.NewFunctions) e.AST
      >
    : (e.NewFunctions^) e.AST^

    = (DriveInfo (e.OptNames) e.OptFunctions) e.AST e.NewFunctions;
}

/*
  Осуществляет попытку прогонки или встраивания в функции
  <OptFunction t.Function t.DriveInfo>
    == t.DriveInfo t.OptimizedFunction t.Function*

  Возвращает модифицированную функцию
  и порожденные из прогонки или встраивания
*/

OptFunction {
  (Function (e.Name) Sentences e.Sentences) t.OptInfo
    = <Reduce
        {
          (t.OptInfo^ (e.SntAcc) (e.FunAcc)) t.Sentence
            = <OptSentence t.Sentence t.OptInfo>
            : t.OptInfo^ (e.NewFunctions) e.NewSentences
            = (t.OptInfo (e.SntAcc e.NewSentences) (e.FunAcc e.NewFunctions));
        }
        (t.OptInfo (/*sentences*/) (/*functions*/))
        e.Sentences
      >
    : {
        (t.OptInfo^ (e.Sentences /* SAME */) (/* пусто */))
          = t.OptInfo
            (ColdFunction DRIVE
              (e.Name) Sentences <CleanupCold-Body e.Sentences>
            );

        (t.OptInfo^ (e.Sentences^) (e.NewFunctions))
          = t.OptInfo
            (Function (e.Name) Sentences e.Sentences)
            e.NewFunctions;
      }
}

/*
   <OptSentence t.Sentence t.OptInfo>
   == t.OptInfo (t.Func?) t.Sentence*
*/

OptSentence {
  /* Оптимизируем только предложения вида Pat = Res */
  ((e.Left) (e.Right)) t.OptInfo

    = <ExtractVariables ((e.Left) (e.Right))> : e.SentenceVars

    /* Если левая часть не L-выражение, сужения запрещаем */
    = <IsLExpr e.Left>
    : {
        True = e.Right;
        False = <MarkAllVarsAsWhole e.Right>;
      }
    : e.Right^

     = <OptTree-Drive-Expr (e.SentenceVars) t.OptInfo e.Right>
     : t.OptInfo^ e.Branches (e.NewFunctions)

     = <Map
         {
           (e.Contractions (e.DrivenRight))
             = <ApplyContractions e.Left (e.Contractions)> : e.Left^
             = <UnmarkWholeVars e.Left> : e.Left^
             = <UnmarkWholeVars e.DrivenRight> : e.DrivenRight^
             = ((e.Left) (e.DrivenRight));
         }
         e.Branches
       >
     : e.NewSentences

     = t.OptInfo (e.NewFunctions) e.NewSentences;

  t.Sentence t.OptInfo = t.OptInfo () t.Sentence
}

ExtractMetatables {
  e.OptFuncs
    = <MapAccum
        {
          (Metatables e.Result) (Function (e.Name) Metatable e.Body)
             = (Metatables e.Result ((e.Name) Metatable e.Body))
               (Function (e.Name) Metatable e.Body);

          (Metatables e.Result) t.Other = (Metatables e.Result) t.Other;
        }
        (Metatables) e.OptFuncs
      >
}

/**
  <OptTree-Drive-CleanupColdCalls e.AST> == e.AST^
*/
$ENTRY OptTree-Drive-CleanupColdCalls {
  e.AST
    = <Map
        {
          (Function (e.Name) Sentences e.Body)
            = (Function
                (e.Name) Sentences <CleanupCold-Body e.Body>
              );

          t.OtherItem = t.OtherItem;
        }
        e.AST
      >;
}

CleanupCold-Body {
  e.Sentences = <Map &CleanupCold-Sentence e.Sentences>;
}

CleanupCold-Sentence {
  ((e.Pattern) e.Conditions (e.Result))
    = (
        (e.Pattern)
        <Map
          {
            (Condition (e.Name) (e.Result^) (e.Pattern^))
              = (Condition
                  (e.Name) (<CleanupCold-Result e.Result>) (e.Pattern)
                );
          }
          e.Conditions
        >
        (<CleanupCold-Result e.Result>)
      );
}

CleanupCold-Result {
  e.Result = <Map &CleanupCold-Term e.Result>;
}

CleanupCold-Term {
  (Brackets e.Expr) = (Brackets <CleanupCold-Result e.Expr>);

  (ADT-Brackets (e.Name) e.Expr)
    = (ADT-Brackets (e.Name) <CleanupCold-Result e.Expr>);

  (CallBrackets e.Expr) = (CallBrackets <CleanupCold-Result e.Expr>);
  (ColdCallBrackets e.Expr) = (CallBrackets <CleanupCold-Result e.Expr>);

  t.OtherTerm = t.OtherTerm;
}
