$INCLUDE "LibraryEx";

*$FROM Hash
$EXTERN HashLittle2-Chars;


/**
  <ExtractVariables e.Sentences> == e.Variables

  e.Variables ::= (s.Mode e.Index)*
*/
$ENTRY ExtractVariables {
  e.Sentences = <Unique <ExtractVariables-Sentences e.Sentences>>;
}

ExtractVariables-Sentences {
  ((e.Pattern) e.Tail) e.Sentences
    = <ExtractVariables-Expr e.Pattern>
      <ExtractVariables-Tail e.Tail>
      <ExtractVariables-Sentences e.Sentences>;

  /* пусто */ = /* пусто */;
}

ExtractVariables-Tail {
  (Condition (e.ConditionName) (e.Result) (e.Pattern)) e.Tail
    = <ExtractVariables-Expr e.Result>
      <ExtractVariables-Expr e.Pattern>
      <ExtractVariables-Tail e.Tail>;

  (e.Result) = <ExtractVariables-Expr e.Result>;
}

$ENTRY ExtractVariables-Expr {
  (Var s.VarType e.Index) e.Terms
    = (s.VarType e.Index) <ExtractVariables-Expr e.Terms>;

  (Brackets e.Inner) e.Terms = <ExtractVariables-Expr e.Inner e.Terms>;
  (ADT-Brackets (e.Name) e.Inner) e.Terms
    = <ExtractVariables-Expr e.Inner e.Terms>;

  (CallBrackets e.Inner) e.Terms = <ExtractVariables-Expr e.Inner e.Terms>;
  (ColdCallBrackets e.Inner) e.Terms = <ExtractVariables-Expr e.Inner e.Terms>;
  (ClosureBrackets e.Inner) e.Terms = <ExtractVariables-Expr e.Inner e.Terms>;

  t.Other e.Terms = <ExtractVariables-Expr e.Terms>;

  /* пусто */ = /* пусто */;
}

/**
  <NewVarName (e.Variables) e.Variable> == (e.Variables^) e.Variable^

  e.Variable ::= s.Mode e.Index
*/
$ENTRY NewVarName {
  (e.Vars) s.Mode /* нет индекса */ = <NewVarName (e.Vars) s.Mode '0'>;

  (e.Vars-B (e.Variable) e.Vars-E) e.Variable
    = <DoNewVarName ((e.Variable) e.Vars-B e.Vars-E) e.Variable>;

  (e.Vars) e.Variable = ((e.Variable) e.Vars) e.Variable;
}

DoNewVarName {
  (e.Vars) e.Variable
    = e.Variable : s.Mode e.Index
    = <IncName e.Index> : e.NewIndex
    = s.Mode e.NewIndex : e.NewVar
    , e.Vars
    : {
        e.Vars-B (e.NewVar) e.Vars-E
          = <DoNewVarName ((e.NewVar) e.Vars-B e.Vars-E) e.NewVar>;

        e.Vars^ = ((e.NewVar) e.Vars) e.NewVar;
      };
}

IncName {
  e.Name s.Digit, '0123456789' : e._B s.Digit s.Next e._E = e.Name s.Next;
  e.Name '9' = <IncName e.Name> '0';
  e.Name = e.Name '0';
}


/**
  <CreateContext s.MarkupContext t.Variable> == t.ContextVariable*

  t.ContextVariable ::=
      (Var s.ModeTS e.Index)
    | (Brackets (Var 'e' e.Index))
    | (Symbol Name e.Name)
*/
$ENTRY CreateContext {
  MarkupContext e.Context =
    <Map
      {
        ('e' e.Index) =
          (Symbol Identifier VAR 'e' e.Index)
          (Brackets (Var 'e' e.Index));

        (s.Mode e.Index) =
          (Symbol Identifier VAR s.Mode e.Index)
          (Var s.Mode e.Index);
      }
      e.Context
    >;

  NoMarkupContext e.Context =
    <Map
      {
        ('e' e.Index) = (Brackets (Var 'e' e.Index));
        (s.Mode e.Index) = (Var s.Mode e.Index);
      }
      e.Context
    >;
}


/**
  <AddSuffix e.Name (e.NewSuffix)> == e.Name
*/
$ENTRY AddSuffix {
  e.Name SUF e.Suffix (e.NewSuffix) = e.Name SUF e.Suffix e.NewSuffix;
  e.Name (e.NewSuffix) = e.Name SUF e.NewSuffix;
}


/**
  <HashName e.Name s.Buckets> == s.Hash

  s.Hash, s.Buckets ::= s.NUMBER
*/
$ENTRY HashName {
  e.Name s.Buckets
    = e.Name
    : {
        e.Base SUF e.Suffix = e.Base <HashName-Suffix e.Suffix>;
        e.Name^ = e.Name;
      }
    : e.NameAsStr
*    base64 -w 8 /dev/urandom | \
*      awk '/^[0-9a-fA-F]*$/ { print strtonum("0x" $1) }' | \
*      head -2 | clip.exe
    = <HashLittle2-Chars 3161351997 4067679699 e.NameAsStr> : s.Hash1 s.Hash2
    = <Mod s.Hash1 s.Buckets>
}

HashName-Suffix {
  s.SufChar s.SufNo e.Suffix
    = s.SufChar <Symb s.SufNo> <HashName-Suffix e.Suffix>;

  /* empty */ = /* empty */;
}

/**
  <ExprType e.Expr> == HardPattern | LPattern | Pattern | Result | ActiveResut
*/
$ENTRY ExprType {
  e.Expr
    = <ExprType-Rec e.Expr>
    : {
        e._ CallBrackets e._ = ActiveResut;
        e._ ClosureBrackets e._ = Result;
        e._ OpenE e._ = Pattern;
        e._ ('e' e.Index) e._ ('e' e.Index) e._ = Pattern;
        e._ ('t' e.Index) e._ ('t' e.Index) e._ = Pattern;
        e._ ('s' e.Index) e._ ('s' e.Index) e._ = LPattern;
        e._ = HardPattern;
      }
}

/*
  <ExprType-Rec e.Expr> == t.ExprType*
  t.ExprType ::= OpenE | (s.Mode e.Index) | Forbidden
*/
ExprType-Rec {
  e.Begin (Var 'e' e._) e.Middle (Var 'e' e._) e.End
    = OpenE <ExprType-Rec e.Begin e.Middle e.End>;

  e.Expr
    = <Map
        {
          (Var s.Mode e.Index) = (s.Mode e.Index);

          (Brackets e.InBrackets) = <ExprType-Rec e.InBrackets>;
          (ADT-Brackets (e._) e.InBrackets) = <ExprType-Rec e.InBrackets>;

          (ClosureBrackets e._) = ClosureBrackets;

          (CallBrackets e._) = CallBrackets;
          (ColdCallBrackets e._) = CallBrackets;

          t.Other = /* пропускаем */;
        }
        e.Expr
      >;
}

/*
  <IsLExpr e.Expr> == True | False
  <IsHardExpr e.Expr> == True | False
  <IsPassiveExpr e.Expr> == True | False
*/
$ENTRY IsLExpr {
  e.Expr
    = <ExprType e.Expr>
    : {
        HardPattern = True;
        LPattern = True;
        s._ = False;
      }
}

$ENTRY IsHardExpr {
  e.Expr
    = <ExprType e.Expr>
    : {
        HardPattern = True;
        s._ = False;
      }
}

$ENTRY IsPassiveExpr {
  e.Expr
    = <ExprType e.Expr>
    : {
        ActiveResut = False;
        s._ = True;
      }
}

/**
  <ExpandClosures-Result e.Expr> == e.Expr
*/
$ENTRY ExpandClosures-Result {
  e.Result = <Map &ExpandClosures-ResultTerm e.Result>;
}

ExpandClosures-ResultTerm {
  (Brackets e.Expr) = (Brackets <ExpandClosures-Result e.Expr>);

  (ADT-Brackets (e.Name) e.Expr)
    = (ADT-Brackets (e.Name) <ExpandClosures-Result e.Expr>);

  (CallBrackets (ClosureBrackets e.Content) e.Expr)
    = (CallBrackets <ExpandClosures-Result e.Content e.Expr>);

  (CallBrackets e.Expr) = (CallBrackets <ExpandClosures-Result e.Expr>);

  /*
    Анализировать холодные вызовы (ColdCallBrackets …) не нужно,
    поскольку они были проанализированы на предыдущих проходах
    и с тех пор не менялись.
  */

  t.OtherTerm = t.OtherTerm;
}

/**
  <ApplyContractions e.Expr (e.Contrs) == e.Expr^
*/
$ENTRY ApplyContractions {
  e.Expr (e.Contrs)
    = <ApplyContractions-Expr (e.Contrs) e.Expr> : (e._) e.Expr^
    = e.Expr;
}

ApplyContractions-Expr {
  (e.Contrs) e.Expr = <MapAccum &ApplyContractions-Term (e.Contrs) e.Expr>;
}

ApplyContractions-Term {
  (e.Contrs) (Brackets e.Expr)
    = <ApplyContractions-Expr (e.Contrs) e.Expr> : (e.Contrs^) e.Expr^
    = (e.Contrs) (Brackets e.Expr);

  (e.Contrs) (CallBrackets e.Expr)
    = <ApplyContractions-Expr (e.Contrs) e.Expr> : (e.Contrs^) e.Expr^
    = (e.Contrs) (CallBrackets e.Expr);

  (e.Contrs) (ColdCallBrackets e.OriginArgs)
    = <ApplyContractions-Expr (e.Contrs) e.OriginArgs>
    : {
*       Содержимое холодных скобок не изменилось, оставляем их холодными
        (e.Contrs^) e.OriginArgs = (e.Contrs) (ColdCallBrackets e.OriginArgs);

*       Содержимое обновилось, оттаиваем скобки
        (e.Contrs^) e.ChangedArgs = (e.Contrs) (CallBrackets e.ChangedArgs);
      };

  (e.Contrs) (ClosureBrackets e.Expr)
    = <ApplyContractions-Expr (e.Contrs) e.Expr> : (e.Contrs^) e.Expr^
    = (e.Contrs) (ClosureBrackets e.Expr);

  (e.Contrs) (ADT-Brackets (e.Name) e.Expr)
    = <ApplyContractions-Expr (e.Contrs) e.Expr> : (e.Contrs^) e.Expr^
    = (e.Contrs) (ADT-Brackets (e.Name) e.Expr);

  (e.B (t.Term ':' e.Contr) e.E) t.Term
    = <ApplyContractions-Expr (e.B (t.Term ':' e.Contr) e.E) e.Contr>;

  (e.Contrs) t.T = (e.Contrs) t.T;
}

/**
  <ApplyAssigns e.Expr (e.Assigns)> == e.Expr^
*/
$ENTRY ApplyAssigns {
  e.Expr (e.Assigns)
    = <Map
        {
          t.T = <ApplyAssigns-Term t.T (e.Assigns)>
        }
        e.Expr
      >
}

ApplyAssigns-Term {
  (Brackets e.Expr) (e.Assigns) = (Brackets <ApplyAssigns e.Expr (e.Assigns)>);

  (CallBrackets e.Args) (e.Assigns)
    = (CallBrackets <ApplyAssigns e.Args (e.Assigns)>);

  (ColdCallBrackets e.Args) (e.Assigns)
    = (ColdCallBrackets <ApplyAssigns e.Args (e.Assigns)>);

  (ClosureBrackets e.Args) (e.Assigns)
    = (ClosureBrackets <ApplyAssigns e.Args (e.Assigns)>);

  (ADT-Brackets (e.Name) e.Expr) (e.Assigns)
    = (ADT-Brackets (e.Name) <ApplyAssigns e.Expr (e.Assigns)>);

  t.T (e.B (e.Expr ':' t.T) e.E) =  e.Expr;

  t.T (e.Assigns) = t.T;
}
