$INCLUDE "LibraryEx";


*$FROM OptTree-StopRelation
$EXTERN OptTree-CanonizeExpr, OptTree-CheckExprStopRelation;

*$FROM OptTree-Drive-Intrinsic
$EXTERN OptTree-Drive-Intrinsic;

*$FROM GenericMatch
$EXTERN GenericMatch, Solve-Drive;

*$FROM TreeUtils
$EXTERN ExpandClosures-Result, ApplyContractions, ExtractVariables-Expr,
  CreateContext, IsPassiveExpr, MarkAllVarsAsWhole, ApplyAssigns, HashName;


/**
  <OptTree-Drive-Expr (e.UsedVars) t.OptInfo e.Expr>
    == t.OptInfo^ e.FlatBranches (e.NewFunctions)

  e.FlatBranches ::= (e.Contractions (e.DrivenExpr))*
  e.UsedVars, e.WholeVars ::= (s.Mode e.Index)*
*/
$ENTRY OptTree-Drive-Expr {
  (e.UsedVars) t.OptInfo e.Expr
    = <ExpandClosures-Result e.Expr> : e.Expr^
    = <MakeDriveTree (0) (e.UsedVars) t.OptInfo e.Expr (0)>
    : ((s._CntNodes) t.OptInfo^ (e.NewFunctions)) e.DriveTree
    = t.OptInfo <FlatDriveTree e.DriveTree> (e.NewFunctions);
}

ColdAll {
  CallBrackets e.Expr
    = ColdCallBrackets e.Expr;
  ColdCallBrackets e.Expr
    = ColdCallBrackets e.Expr;
  e.B (e.Expr) e.E
    = <ColdAll e.B> (<ColdAll e.Expr>) <ColdAll e.E>;
  e.X = e.X;
}

MaxCntNodes { = 100 }

$DRIVE MaxCntNodes;

MaxTreeDepth { = 20 }

$DRIVE MaxTreeDepth;

IncWithMax {
  s.Cnt s.Max, <Compare s.Max s.Cnt> : '+' = <Add s.Cnt 1>;

  s.Cnt s.Max = s.Max;
}

/*
  <MakeDriveTree ...> == t.DriveTreeState t.TreeBranch*
  <GrowDriveTree ...> == t.DriveTreeState t.TreeBranch*

  t.DriveTreeState ::= ((s.CntNodes) t.OptInfo (e.NewFunctions))
  t.TreeBranch ::= (e.Contractions (e.DrivenRight) (t.TreeBranch*))
*/
MakeDriveTree {
  (s.CntNodes) (e.UsedVars) t.OptInfo e.Expr
  (s.TreeDepth e.canoninzedExprs)
    = (<OptTree-CanonizeExpr e.Expr>) e.canoninzedExprs : e.canoninzedExprs^
    = <IncWithMax s.CntNodes <MaxCntNodes>>
      <IncWithMax s.TreeDepth <MaxTreeDepth>>
    : s.CntNodes^ s.TreeDepth^
    = <CheckExprsStopRelation e.canoninzedExprs>
    : {
        True s.Cnt = Generalize t.OptInfo s.Cnt;

        s._ s._, <MaxCntNodes> : s.CntNodes
          = <DriveStateWithLeaf s.CntNodes t.OptInfo <ColdAll e.Expr>>;

        s._ s._, <MaxTreeDepth> : s.TreeDepth
          = <DriveStateWithLeaf s.CntNodes t.OptInfo <ColdAll e.Expr>>;

        False s._Cnt
          = <GrowDriveTree
              (s.CntNodes) (e.UsedVars) t.OptInfo e.Expr
              (s.TreeDepth e.canoninzedExprs)
            >;
    };
}

/*
  <DriveStateWithLeaf s.CntNodes t.OptInfo e.Expr>
    == t.DriveTreeState t.TreeBranch    -- one branch
*/
DriveStateWithLeaf {
  s.CntNodes t.OptInfo e.Expr
    = ((s.CntNodes) t.OptInfo (/* нет функций */))
      (/* нет сужений */ (e.Expr) (/* пустое дерево */));
}

gen_e__ { e.arg = e.arg }

GrowDriveTree {
  (s.CntNodes) (e.UsedVars) t.OptInfo e.Expr
  (s.TreeDepth e.canoninzedExprs)
    = t.OptInfo : ((e.OptFuncNames) e.OptFuncs)
    = <FindOptimizedCall (e.OptFuncNames) e.Expr>
    : {
        (e.OptFuncNames^ None) e.Expr^
          = ((e.OptFuncNames) e.OptFuncs) : t.OptInfo^
          = <DriveStateWithLeaf s.CntNodes t.OptInfo e.Expr>;

        (e.OptFuncNames^ t.Call) e.Expr^
          = <OptOneCall
              (e.UsedVars) (e.Expr) <gen_e__> t.Call e.OptFuncs
            >
          : (e.OptFuncs^) (e.NewFunctions) e.Branches

          = ((e.OptFuncNames) e.OptFuncs) : t.OptInfo^

          = <GrowDriveTree-DriveBranches
              (s.CntNodes) (e.UsedVars) t.OptInfo
              (s.TreeDepth e.canoninzedExprs) (e.NewFunctions) e.Branches
            >
          : {
              Generalize t.OptInfo^ 1
                = <GrowDriveTree
                    (s.CntNodes) (e.UsedVars) t.OptInfo
                    <RestoreDrivenCall t.Call e.Expr>
                    (s.TreeDepth e.canoninzedExprs)
                  >;

              Generalize t.OptInfo^ s.Cnt = Generalize t.OptInfo <Dec s.Cnt>;

              Tree t.DriveTreeState e.Branches^ = t.DriveTreeState e.Branches;
            };
      };
}

GrowDriveTree-DriveBranches {
  (s.CntNodes) (e.UsedVars) t.OptInfo
  (s.TreeDepth e.canoninzedExprs) (e.NewFunctions) e.Branches
    = <MapAccum
        {
          ((s.CntNodes^) t.OptInfo^ (e.NewFunctionsAcc))
          ((e.UsedVars^) e.Contractions (e.DrivenRight))
            = <MakeDriveTree
                (s.CntNodes) (e.UsedVars) t.OptInfo e.DrivenRight
                (s.TreeDepth e.canoninzedExprs)
              >
            : {
                ((s.CntNodes^) t.OptInfo^ (e.NewFunctions^)) e.Branches^
                  = ((s.CntNodes) t.OptInfo (e.NewFunctionsAcc e.NewFunctions))
                    (e.Contractions (e.DrivenRight) (e.Branches));

                Generalize t.OptInfo^ s.Cnt = (Generalize t.OptInfo s.Cnt);
              };

          (Generalize t.OptInfo^ s.Cnt) (e.Contractions (e.DrivenRight))
            = (Generalize t.OptInfo s.Cnt);
        }
        ((s.CntNodes) t.OptInfo (e.NewFunctions))
        e.Branches
      >
    : {
        (Generalize t.OptInfo^ s.Cnt) e._tree = Generalize t.OptInfo s.Cnt;

        t.DriveTreeState e.Tree = Tree t.DriveTreeState e.Tree;
      };
}

RestoreDrivenCall {
  t.Call e.Expr
    = <ApplyContractions e.Expr ((<eDRIVEN> ':' <ColdAll t.Call>))>
}

CheckExprsStopRelation {
  (e.currentExpr) e.historyExprs-B (e.historyExpr) e.historyExprs-E
    , <OptTree-CheckExprStopRelation (e.currentExpr) e.historyExpr> : True
    = <Lenw e.historyExprs-B> : s.Len e._
    = True <Inc s.Len>;

  (e.currentExpr) e.historyExprs = False 0;
}

FlatDriveTree {
  e.Branches
    = <Map
        {
          /* лист */
          (e.Contractions (e.DrivenRight) (/* нет детей */))
            = (e.Contractions (e.DrivenRight));

          /* внутренний узел */
          (e.Contractions (e._SkippedDrivenRight) (e.ChildBranches))
            = <FlatDriveTree e.ChildBranches> : e.FlatBranches
            = <Map
                {
                  (e.BranchContractions (e.DrivenRight))
                    = (e.Contractions e.BranchContractions (e.DrivenRight))
                }
                e.FlatBranches
              >;
        }
        e.Branches
      >;
}

OptOneCall {
  (e.UsedVars) (e.Expr)
  (CallBrackets (Symbol Name e.Name) e.Args)
  s.Contractions-Mode t.Metatables e.OptFuncs

    /* Поиск информации для прогонки */
    = <FindOptInfo e.OptFuncs (e.Name)> : e.OptFuncs^ t.FunctionForDrive
    = <OptExpr-MakeSubstitutions
        s.Contractions-Mode (e.UsedVars) (e.Expr) (e.Args)
        t.FunctionForDrive t.Metatables
      >
    : t.Metatables^ e.SubstitutionPacks

    = <Unique <ExtractVariables-Expr e.Args>> : e.Domain
    = <CreateContext NoMarkupContext e.Domain> : e.PseudoPattern

    = <MapAccum
        {
          (e.NewFunctions) ((e.UsedVars^) e.Contractions (e.NewFunction))
            = <ApplyContractions e.Expr (e.Contractions)> : e.DrivenRight
            = <ExpandClosures-Result e.DrivenRight> : e.DrivenRight^
            = (e.NewFunctions e.NewFunction)
              ((e.UsedVars) e.Contractions (e.DrivenRight));
        }
        (/* new functions */)
        e.SubstitutionPacks
      >
    : (e.NewFunctions) e.Branches

    = <FilterScreenedBranches (e.PseudoPattern) e.Branches> : e.Branches^

    = (s.Contractions-Mode t.Metatables e.OptFuncs)
      (e.NewFunctions) e.Branches
}

FilterScreenedBranches {
  (e.PatTemplate) e.Branches
    = <Map
        {
          ((e.UsedVars) e.Contractions (e.Result))
            = <ApplyContractions e.PatTemplate (e.Contractions)> : e.Pattern
            = ((e.Pattern) (e.UsedVars) (e.Result));
        }
        e.Branches
      >
    : e.PseudoSentenences

    = <DoFilterScreenedBranches e.PseudoSentenences> : e.PseudoSentenences^

    = <Map
        {
          ((e.Pattern) (e.UsedVars) (e.Result))
            = <RestoreContractions (e.Pattern) (e.PatTemplate)> : e.Contractions
            = ((e.UsedVars) e.Contractions (e.Result));
        }
        e.PseudoSentenences
      >
}

DoFilterScreenedBranches {
  ((e.FirstPattern) (e.FirstUsedVars) (e.FirstResult)) e.PseudoSentenences
    = ((e.FirstPattern) (e.FirstUsedVars) (e.FirstResult))
      <DoFilterScreenedBranches
        <Map
          {
            ((e.Pattern) (e.UsedVars) (e.Result))
              , <GenericMatch (e.Pattern) (e.FirstPattern)> : Clear e._
              = /* ветвь экранируется, стираем */;

            ((e.Pattern) (e.UsedVars) (e.Result))
              = ((e.Pattern) (e.UsedVars) (e.Result));
          }
          e.PseudoSentenences
        >
      >;

  /* пусто */ = /* пусто */;
}

RestoreContractions {
  (e.Pattern) (e.PatTemplate)
    = <GenericMatch (e.Pattern) (e.PatTemplate)> : Clear e.Assigns
    = <Map
        {
          ((Var s.Mode e.Index) ':' (s.Mode e.Index))
            = /* тривиальные пропускаем */;

          (e.Expr ':' (s.Mode e.Index)) = ((Var s.Mode e.Index) ':' e.Expr)
        }
        e.Assigns
      >
}

eDRIVEN {
  = (Var 'e' DRIVEN);
}

/*
  <OptExpr-MakeSubstitutions
    s.Contractions-Mode
    (e.UsedVars) (e.Expr) (e.CallArgs) t.OptFunction t.Metatables
  >
    == t.Metatables (e.Substitutions)*
  e.Substitutions ::= e.Contractions (e.NewFunctions)

  e.Contractions включают в себя сужение e.DRIVEN для подстановки
  правой части.
*/
OptExpr-MakeSubstitutions {
  s.Contractions-Mode
  (e.UsedVars) (e.Expr) (e.Args) t.IntrinsicFunction t.Metatables
    , t.IntrinsicFunction : ((e._) Intrinsic e.BehaviorName)
    = <OptTree-Drive-Intrinsic t.Metatables (e.Args) e.BehaviorName>
    : {
        t.Metatables^ Ok e.Result
          = t.Metatables
            ((e.UsedVars) (<eDRIVEN> ':' e.Result) (/* нет новых функций */));

        t.Metatables^ MakeColdCall
          = t.Metatables
            <MakeColdSolution (e.UsedVars) t.IntrinsicFunction e.Args>;
      };

  s.Contractions-Mode (e.UsedVars) (e.Expr) (e.Args)
  t.Function t.Metatables
    /* Активные вызовы игнорируем */
    , <IsPassiveExpr e.Args> : False

    = t.Metatables <MakeColdSolution (e.UsedVars) t.Function e.Args>;

  s.Contractions-Mode (e.UsedVars) (e.Expr) (e.Args)
  ((e.Name) Sentences e.Body) t.Metatables

    = s.Contractions-Mode
    : {
        Contractions-Enabled = e.Args;
        Contractions-Disabled = <MarkAllVarsAsWhole e.Args>;
      }
    : e.Args^

    = t.Metatables
      <DoOptExpr-MakeSubstitutions
        (e.UsedVars) (e.Args) (/* substitutions */)
        ((e.Name) Sentences e.Body)
      >;

  t.Contractions-Mode (e.UsedVars) (e.Expr) (e.Args)
  t.Function t.Metatables
    = t.Metatables <MakeColdSolution (e.UsedVars) t.Function e.Args>;
}

MakeColdSolution {
  (e.UsedVars) ((e.Name) Sentences e.Body) e.Args
    , e.Name : e.Prefix '*' s.Num
    = (
        (e.UsedVars)
        (<eDRIVEN> ':' (ColdCallBrackets (Symbol Name e.Name) e.Args))
        ((NewFunction (e.Name) Sentences e.Body))
      );

  (e.UsedVars) ((e.Name) s._ e.Body) e.Args
    = (
        (e.UsedVars)
        (<eDRIVEN> ':' (ColdCallBrackets (Symbol Name e.Name) e.Args))
        (/* нет новых функций */)
      );
}

DoOptExpr-MakeSubstitutions {
  (e.SentenceVars) (e.Args) (e.Substitutions)
  ((e.Name) Sentences ((e.LS) (e.RS)) e.Rest)
    = <Cleanup-Step-Drop e.RS> : e.RS^
    = <Solve-Drive (e.SentenceVars) ((e.Args) ':' (e.LS))>
    : {
        /*
          В случае решения без сужений просто применяем замены.
        */
        Success (e.UsedVars () (e.Assigns))
          = <ApplyAssigns e.RS (e.Assigns)> : e.CallReplacer
          = e.Substitutions
            (
              (e.UsedVars)
              (<eDRIVEN> ':' e.CallReplacer)
              (/* нет новых функций */)
            );

        /*
          «Грязное» решение допускаем только в случае прогонки.
        */
        Success e.Solutions
          = <Map
              {
                (e.UsedVars (e.Contrs) (e.Assigns))
                  = <ApplyAssigns e.RS (e.Assigns)> : e.CallReplacer
                  = e.Contrs (<eDRIVEN> ':' e.CallReplacer) : e.Contrs^
                  = ((e.UsedVars) e.Contrs (/* нет новых функций */));
              }
              e.Solutions
            >
          : e.NewSubstitutions
          = e.Substitutions e.NewSubstitutions : e.Substitutions^
          = <DoOptExpr-MakeSubstitutions
              (e.SentenceVars) (e.Args) (e.Substitutions)
              ((<RemainderFuncIncName e.Name>) Sentences e.Rest)
            >;

        /*
          Здесь либо Undefined, либо грязное решение в режиме встраивания,
          в обоих случаях добавляем холодный вызов остаточной функции.
        */
        e.Other
          = e.Substitutions
            <MakeColdSolution
              (e.SentenceVars)
              ((e.Name) Sentences ((e.LS) (e.RS)) e.Rest)
              e.Args
            >;
      };

  (e.SentenceVars) (e.Args) (e.Substitutions) t.RestFunction
    = e.Substitutions <MakeColdSolution (e.SentenceVars) t.RestFunction e.Args>;
}

Cleanup-Step-Drop {
  /*
    Считаем, что правильный <__Step-Drop> должен располагаться в начале
    правой части. Так генерируется для метафункций. Если пользователь зачем-то
    пишет __Step-Drop вручную и в другом месте — сам себе злобный буратино.
  */
  (CallBrackets (Symbol Name '__Step-Drop') /* пусто */) e.RS = e.RS;

  e.RS = e.RS;
}

DropLeft {
  e.List 0 =  e.List;
  t.Head e.Tail s.N = <DropLeft e.Tail <Sub s.N 1>>
}

/*
  <FindOptInfo e.OptFuncs (e.Name)> == e.OptFuncs t.Function
  t.Function ::= (s.Mode (e.Name) e.Body)
*/
FindOptInfo {
  e.OptFuncs (e.Name)
    = e.Name
    : {
        e.Prefix '*' s.N = <CutSUF e.Prefix> s.N;
        e.Name^ = e.Name 0;
      }
    : e.LookupName s.Drop
    = <FindOptInfo-Aux e.OptFuncs (e.Name) (e.LookupName) s.Drop>;
}

FindOptInfo-Aux {
  e.OptFuncs-B ((e.LookupName) Intrinsic e.Body) e.OptFuncs-E
  (e.Name) (e.LookupName) 0
  = e.OptFuncs-B ((e.LookupName) Intrinsic e.Body) e.OptFuncs-E
    ((e.Name) Intrinsic e.Body);

  e.OptFuncs-B ((e.LookupName) e.Body) e.OptFuncs-E
  (e.Name) (e.LookupName) s.Drop
    = e.Body : Sentences e.Sentences
    = e.OptFuncs-B ((e.LookupName) e.Body) e.OptFuncs-E
      ((e.Name) Sentences <DropLeft e.Sentences s.Drop>);
}

$DRIVE CutSUF;

CutSUF {
  e.Prefix SUF = e.Prefix;
  e.Prefix = e.Prefix;
}

/*
  <FindOptimizedCall (e.OptFuncNames) e.Expr>
    == (e.OptFuncNames t.Found) e.Expr

  t.Found ::= None | (CallBrackets e.Arg)
*/

FindOptimizedCall {
  (e.OptFuncNames) e.Expr
    = <MapAccum &FindOptimizedCall-Term (e.OptFuncNames None) e.Expr>;
}

FindOptimizedCall-Term {
  (e.OptFuncNames None) (Brackets e.Expr)
    = <FindOptimizedCall (e.OptFuncNames) e.Expr>
    : (e.OptFuncNames^ t.Found) e.Expr^
    = (e.OptFuncNames t.Found) (Brackets e.Expr);

  (e.OptFuncNames None) (ADT-Brackets (e.Name) e.Expr)
    = <FindOptimizedCall (e.OptFuncNames) e.Expr>
    : (e.OptFuncNames^ t.Found) e.Expr^
    = (e.OptFuncNames t.Found)
      (ADT-Brackets (e.Name) e.Expr);

  (e.OptFuncNames None) (CallBrackets (Symbol Name e.Name) e.Arg)
    = <FindOptimizedCall (e.OptFuncNames) e.Arg>
    : {
        (e.OptFuncNames^ None) e.Arg^
          = e.OptFuncNames : s.BucketSize e.Buckets
          = <HashName e.Name s.BucketSize> : s.Hash
          = e.Buckets
          : {
*             Вызов оптимизируемой функции, извлекаем его наружу
              e.Buckets-B
              (s.Hash e.OptFuncNames-B (s.Label e.Name) e.OptFuncNames-E)
              e.Buckets-E
                = (
                    s.BucketSize
                    e.Buckets-B
                    (s.Hash (s.Label e.Name) e.OptFuncNames-B e.OptFuncNames-E)
                    e.Buckets-E

                    (CallBrackets (Symbol Name e.Name) e.Arg)
                  )
                  <eDRIVEN>;

*               Функция, не подлежащая оптимизации. Остужаем вызов.
                e.Buckets^
                  = (s.BucketSize e.Buckets None)
                    (ColdCallBrackets (Symbol Name e.Name) e.Arg);
            };

*       Внутри аргумента найден оптимизируемый вызов
        (e.OptFuncNames^ t.Found) e.Arg^
          = (e.OptFuncNames t.Found)
            (CallBrackets (Symbol Name e.Name) e.Arg);
      };

  (e.OptFuncNames None) (CallBrackets e.Expr)
    = <FindOptimizedCall (e.OptFuncNames) e.Expr>
    : (e.OptFuncNames^ t.Found) e.Expr^
    = (e.OptFuncNames t.Found) (CallBrackets e.Expr);

  (e.OptFuncNames t.Found) t.AnyTerm
    = (e.OptFuncNames t.Found) t.AnyTerm;
}

/*
  <RemainderFuncIncName e.Name> == e.Name
*/

RemainderFuncIncName {
  e.Name SUF e.Suffixes '*' s.N = e.Name SUF e.Suffixes '*' <Add s.N 1>;

  e.Name SUF e.Suffixes = e.Name SUF e.Suffixes '*' 1;

  e.Name = e.Name SUF '*' 1;
}
