$INCLUDE "LibraryEx";


/**
  <OptTree-Drive-Intrinsic t.Metatables (e.Args) e.Behavior>
    == t.Metatables Ok e.Result
    == t.Metatables MakeColdCall

  t.Metatables ::= (t.Metatable*)
  e.Args, e.Result ::= e.ReducedExpression
*/
$ENTRY OptTree-Drive-Intrinsic {
  t.Metatables (e.Args) '__Meta_Mu'
    = <Intrinsic-Mu e.Args t.Metatables>;

  t.Metatables (e.Args) e.BehaviorName
    = e.BehaviorName
    : {
        'Add' = &Intrinsic-Add;
        'Sub' = &Intrinsic-Sub;
        'Mul' = &Intrinsic-Mul;
        'Div' = &Intrinsic-Div;
        'Mod' = &Intrinsic-Mod;
        'Divmod' = &Intrinsic-Divmod;
        'Compare' = &Intrinsic-Compare;
        'Chr' = &Intrinsic-Chr;
        'Ord' = &Intrinsic-Ord;
        'Upper' = &Intrinsic-Upper;
        'Lower' = &Intrinsic-Lower;
        'Numb' = &Intrinsic-Numb;
        'Symb' = &Intrinsic-Symb;
        'Implode' = &Intrinsic-Implode;
        'Implode_Ext' = &Intrinsic-Implode_Ext;
        'Explode' = &Intrinsic-Explode;
        'Explode_Ext' = &Intrinsic-Explode;
        'Type' = &Intrinsic-Type;
        'Lenw' = &Intrinsic-Lenw;
        'First' = &Intrinsic-First;
        'Last' = &Intrinsic-Last;

        e._ = { e._ = MakeColdCall };
      }
    : s.TransformFunction
    = t.Metatables <s.TransformFunction e.Args>;
}

Intrinsic-Mu {
  e.Args t.Metatables
    , e.Args : t.Function e.MuArg (Symbol Name e.MetatableName)
    = t.Function
    : {
        (Symbol Name e.Name)
          = t.Metatables Ok (CallBrackets (Symbol Name e.Name) e.MuArg);

        (ClosureBrackets e.Body)
          = t.Metatables Ok (CallBrackets (ClosureBrackets e.Body) e.MuArg);

        (Symbol Identifier s.Name)
          , <ArithmeticSymbolToFunction s.Name> : True e.FunctionName
          = t.Metatables Ok (CallBrackets (Symbol Name e.FunctionName) e.MuArg);

        (Symbol Char s.Name)
          , <ArithmeticSymbolToFunction s.Name> : True e.FunctionName
          = t.Metatables Ok (CallBrackets (Symbol Name e.FunctionName) e.MuArg);

        (Symbol Identifier e.Name)
          = <MakeSubstitution-FromMetatables
              t.Metatables (e.MetatableName) (e.MuArg) e.Name
            >;

        (Brackets e.Chars)
          , <AllChars e.Chars> : Ok e.Name
          = <MakeSubstitution-FromMetatables
              t.Metatables (e.MetatableName) (e.MuArg) e.Name
            >;

        t._ = t.Metatables MakeColdCall;
      };

  e._ t.Metatables = t.Metatables MakeColdCall;
}

ArithmeticSymbolToFunction {
  '+' = True 'Add';
  '-' = True 'Sub';
  '/' = True 'Div';
  '*' = True 'Mul';
  '%' = True 'Mod';
  '?' = True 'Residue';

  s._ = False;
}

AllChars {
  e.Terms = <DoAllChars () e.Terms>;
}

DoAllChars {
  (e.Chars) (Symbol Char s.Char) e.Rest = <DoAllChars (e.Chars s.Char) e.Rest>;
  (e.Chars) /* empty */ = Ok e.Chars;
  (e.Chars) e.Rest = Fails;
}

MakeSubstitution-FromMetatables {
  t.Metatables (e.MetatableName) (e.MuArg) e.Name
    = t.Metatables
    : {
        (Metatables
          e.Tables-B ((e.MetatableName) Metatable e.Map) e.Tables-E
        )
          = e.Map
          : {
              e._ ((Symbol Identifier e.Name) t.Pointer) e._
                = Ok (CallBrackets t.Pointer e.MuArg);

              e.Other = MakeColdCall;
            }
          : e.Result
          = (Metatables
              e.Tables-B
              ((e.MetatableName) Metatable e.Map)
              e.Tables-E
            )
            e.Result;

        t.Metatables^ = t.Metatables MakeColdCall;
      }
}

Intrinsic-Add {
  e.Args
    = <ArithmArgs e.Args>
    : {
        Ok (Const e.Left) (Const e.Right)
          = Ok <NumberToSymbols <Add (e.Left) e.Right>>;

        Ok (Const 0) (ArithmResult t.ArithmCall) = Ok t.ArithmCall;
        Ok (ArithmResult t.ArithmCall) (Const 0) = Ok t.ArithmCall;

        e._ = MakeColdCall;
      };
}

ArithmArgs {
  (Brackets e.Left) e.Right
    , <ArithmOneArg e.Left> : Ok e.Left^
    , <ArithmOneArg e.Right> : Ok e.Right^
    = Ok (e.Left) (e.Right);

  (Symbol Char s.Sign) (Symbol Number s.Left) e.Right
    , <ArithmOneArg e.Right> : Ok e.Right^
    = Ok (Const s.Sign s.Left) (e.Right);

  (Symbol Number s.Left) e.Right
    , <ArithmOneArg e.Right> : Ok e.Right^
    = Ok (Const s.Left) (e.Right);

  e._ = Fails;
}

ArithmOneArg {
  (ColdCallBrackets (Symbol Name e.Name) e.Arg)
    , <ArithmeticFunctions> : e._ (e.Name) e._
    = Ok ArithmResult (ColdCallBrackets (Symbol Name e.Name) e.Arg);

  e.Number, <Number-Check e.Number> : True
    = Ok Const <Add 0 <SymbolsToNumber e.Number>>;

  e._ = Fails;
}

Number-Check {
  (Symbol Char '+') e.Rest = <Number-Check-AllNumbers e.Rest>;
  (Symbol Char '-') e.Rest = <Number-Check-AllNumbers e.Rest>;

  e.Rest = <Number-Check-AllNumbers e.Rest>;
}

Number-Check-AllNumbers {
  (Symbol Number s._) = True;
  (Symbol Number s._) e.Rest = <Number-Check-AllNumbers e.Rest>;
  e._ = False;
}

SymbolsToNumber {
  e.Symbols
    = <Map
        {
          (Symbol Char '-') = '-';
          (Symbol Char '+') = '+';
          (Symbol Number s.n) = s.n
        }
        e.Symbols
      >
}

NumberToSymbols {
  e.Number
    = <Map
        {
          '-' = (Symbol Char '-');
          '+' = (Symbol Char '+');
          s.n = (Symbol Number s.n)
        }
        e.Number
      >
}

ArithmeticFunctions {
  = ('Add') ('Div') ('Divmod') ('Mod') ('Mul') ('Sub') ('Numb');
}

Intrinsic-Sub {
  e.Args
    = <ArithmArgs e.Args>
    : {
        Ok (Const e.Left) (Const e.Right)
          = Ok <NumberToSymbols <Sub (e.Left) e.Right>>;

        Ok (ArithmResult t.ArithmCall) (Const 0) = Ok t.ArithmCall;

        e._ = MakeColdCall;
      };
}

Intrinsic-Mul {
  e.Args
    = <ArithmArgs e.Args>
    : {
        Ok (Const e.Left) (Const e.Right)
          = Ok <NumberToSymbols <Mul (e.Left) e.Right>>;

        Ok (Const 1) (ArithmResult t.ArithmCall) = Ok t.ArithmCall;
        Ok (ArithmResult t.ArithmCall) (Const 1) = Ok t.ArithmCall;

        e._ = MakeColdCall;
      };
}

Intrinsic-Div {
  e.Args
    = <ArithmArgs e.Args>
    : {
        Ok (e._) (Const 0) = MakeColdCall;

        Ok (Const e.Left) (Const e.Right)
          = Ok <NumberToSymbols <Div (e.Left) e.Right>>;

        Ok (ArithmResult t.ArithmCall) (Const 1) = Ok t.ArithmCall;

        e._ = MakeColdCall;
      };
}

Intrinsic-Mod {
  e.Args
    = <ArithmArgs e.Args>
    : {
        Ok (e._) (Const 0) = MakeColdCall;

        Ok (Const e.Left) (Const e.Right)
          = Ok <NumberToSymbols <Mod (e.Left) e.Right>>;

        e._ = MakeColdCall;
      };
}

Intrinsic-Divmod {
  e.Args
    = <ArithmArgs e.Args>
    : {
        Ok (e._) (Const 0) = MakeColdCall;

        Ok (Const e.Left) (Const e.Right)
          = <Divmod (e.Left) e.Right> : (e.Q) e.R
          = Ok (Brackets <NumberToSymbols e.Q>) <NumberToSymbols e.R>;

        Ok (ArithmResult t.ArithmCall) (Const 1)
          = Ok (Brackets t.ArithmCall) (Symbol Number 0);

        e._ = MakeColdCall;
      };
}

Intrinsic-Compare {
  e.Args
    , <ArithmArgs e.Args> : Ok (Const e.Left) (Const e.Right)
    = Ok (Symbol Char <Compare (e.Left) e.Right>);

  e._ = MakeColdCall;
}

/*
  TODO: уточнить семантику функций Chr, Ord, Upper, Lower.

  Функции не должны увеличивать число шагов рефал-машины.

  Сейчас:
  <Chr 48 e.X 48 <F> 48> → '@' <Chr e.X> '@' <Chr <F>> '@'
  А должно быть:
  <Chr 48 e.X 48 <F> 48> → '@' <Chr e.X 48 <F>> '@'

  Кроме того, нужно поддерживать спуск внутрь структурных скобок
  (сейчас не поддерживается).
*/
Intrinsic-Chr {
  e.Args
    , <CheckArgs-Intrinsic-StaticSubstitution (e.Args) Number> : True
    = <StaticSubstitution (e.Args) ('Chr') &Chr Number Char> : e.Substitution
    = Ok e.Substitution;

  e.Args = MakeColdCall;
}

CheckArgs-Intrinsic-StaticSubstitution {
  (e.Args) s.SymbolName
    = e.Args
    : {
        (Symbol s.SymbolName e.Name) e.Rest
          = <CheckArgs-Intrinsic-StaticSubstitution (e.Rest) s.SymbolName>;

        (Var e.Var) e.Rest
          = <CheckArgs-Intrinsic-StaticSubstitution (e.Rest) s.SymbolName>;

        (ColdCallBrackets e.Body) e.Rest
          = <CheckArgs-Intrinsic-StaticSubstitution (e.Rest) s.SymbolName>;

        t.Other e.Rest = False;

        /* пусто */ = True;
      }
}

StaticSubstitution {
  (e.Args) (e.FuncName) s.Func s.SymbolFrom s.SymbolTo
    = <Map
        {
          (Symbol s.SymbolFrom s.n)
            = (Symbol s.SymbolTo <s.Func s.n>);

          (Var e.Var)
            = (ColdCallBrackets (Symbol Name e.FuncName) (Var e.Var));

          (ColdCallBrackets e.Body)
            = (ColdCallBrackets
                (Symbol Name e.FuncName) (ColdCallBrackets e.Body)
              );
        }
        e.Args
      >
}

Intrinsic-Ord {
  e.Args
    , <CheckArgs-Intrinsic-StaticSubstitution (e.Args) Char> : True
    = <StaticSubstitution (e.Args) ('Ord') &Ord Char Number> : e.Substitution
    = Ok e.Substitution;

  e.Args = MakeColdCall;
}

Intrinsic-Upper {
  e.Args
    , <CheckArgs-Intrinsic-StaticSubstitution (e.Args) Char> : True
    = <StaticSubstitution (e.Args) ('Upper') &Upper Char Char> : e.Substitution
    = Ok e.Substitution;

  e.Args = MakeColdCall;
}

Intrinsic-Lower {
  e.Args
    , <CheckArgs-Intrinsic-StaticSubstitution (e.Args) Char> : True
    = <StaticSubstitution (e.Args) ('Lower') &Lower Char Char> : e.Substitution
    = Ok e.Substitution;

  e.Args = MakeColdCall;
}

Intrinsic-Numb {
  e.Args
    , <AllChars e.Args> : Ok e.Chars
    = <NumberToSymbols <Numb e.Chars>> : e.Result
    = Ok e.Result;

  e.Args = MakeColdCall;
}

Intrinsic-Symb {
  e.Args
    , <ArithmOneArg e.Args> : Ok Const e._
    = <Symb <SymbolsToNumber e.Args>> : e.Numbers
    = <CharToNode e.Numbers> : e.Result
    = Ok e.Result;

  e.Args = MakeColdCall;
}

CharToNode {
  e.Char = <Map { s.a = (Symbol Char s.a) } e.Char>
}

Intrinsic-Implode {
  e.Args
    , <AllChars e.Args> : Ok e.Chars
    = <Implode e.Chars> : s.Ident e.NonIdent
    = s.Ident
    : {
        0 = (Symbol Number 0);
        e._ = (Symbol Identifier <Explode s.Ident>)
      }
    : e.Result
    = Ok e.Result <CharToNode e.NonIdent>;

  e.Args = MakeColdCall;
}

Intrinsic-Implode_Ext {
  e.Args, <AllChars e.Args> : Ok e.Chars = Ok (Symbol Identifier e.Chars);

  e.Args = MakeColdCall;
}

Intrinsic-Explode {
  (Symbol Identifier e.Name) = Ok <CharToNode e.Name>;

  e._ = MakeColdCall;
}

Intrinsic-Type {
  (CallBrackets e._) e._ = MakeColdCall;
  (ColdCallBrackets e._) e._ = MakeColdCall;
  (Var e._) e._ = MakeColdCall;
  (WhVar e._) e._ = MakeColdCall;

  t.Term e.Rest
    = t.Term
    : {
        (Symbol Number s._) = 'N0';
        (Symbol Char s.Char) = <Type s.Char>;
        (Symbol Identifier e.Name) = <Type <Implode_Ext e.Name>>;
        (Symbol Name e._) = 'Fg';
        (ClosureBrackets e._) = 'Fc';
        (Brackets e._) = 'B0';
        (ADT-Brackets (e._) e._) = 'Ba';
      }
    : s.Type s.SubType e._
    = Ok (Symbol Char s.Type) (Symbol Char s.SubType) t.Term e.Rest;

  /* empty */ = Ok (Symbol Char '*') (Symbol Char '0');
}

Intrinsic-Lenw {
  e.Args
    , <FixedLength e.Args> : True
    = <Lenw e.Args> : s.Len e.Args^
    = Ok (Symbol Number s.Len) e.Args;

  e._ = MakeColdCall;
}

FixedLength {
  e._ (Var 'e' e._) e._ = False;
  e._ (CallBrackets e._) e._ = False;
  e._ (ColdCallBrackets e._) e._ = False;

  e._ = True;
}

Intrinsic-First {
  (Symbol Number s.N) e.Expr
    , <First s.N e.Expr> : (e.Prefix) e.Suffix
    , <FixedLength e.Prefix> : True
    = Ok (Brackets e.Prefix) e.Suffix;

  e._ = MakeColdCall;
}

Intrinsic-Last {
  (Symbol Number s.N) e.Expr
    , <Last s.N e.Expr> : (e.Prefix) e.Suffix
    , <FixedLength e.Suffix> : True
    = Ok (Brackets e.Prefix) e.Suffix;

  e._ = MakeColdCall;
}
