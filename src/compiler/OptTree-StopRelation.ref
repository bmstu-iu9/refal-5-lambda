$INCLUDE "LibraryEx";

/**
  Функции, относящиеся к проверке отношения Хигмана-Крускала
*/

/**
  <OptTree-CheckExprStopRelation (e.CurrentExpr) e.HistoryExpr>
    == True
    == False

  Проверяет выполнение отношения Хигмана-Крускала для двух выражений.
  Возвращает True, если отношение выполняется, и False в ином случае.

  Предполагается, что оба выражения в канонической форме.

  e.CurrentExpr, e.HistoryExpr ::= e.CanonizedExpr
  e.CanonizedExpr ::= t.CanonizedTerm*
  t.CanonizedTerm ::=
      (Symbol s.SymType e.SymInfo)
    | (Var 't')
    | (Var 's')
    | (Var 'e')
    | (ADT-Brackets t.Name t.CanonizedTerm*)
    | (Brackets t.CanonizedTerm*)
    | (ClosureBrackets t.CanonizedTerm*)
    | (CallBrackets t.Name t.CanonizedTerm*)
*/
$ENTRY OptTree-CheckExprStopRelation {
  (e.CurrentExpr) e.HistoryExpr
    , <CheckSubsequenceRelation
        <Tokenize e.CurrentExpr> (<Tokenize e.HistoryExpr>)
      >
    : True
    = <Trace True <CheckHKRelation e.CurrentExpr (e.HistoryExpr)>>;

  (e.CurrentExpr) e.HistoryExpr = <Trace False False>;
}

*$DRIVE Trace

Trace {
*/*
  s.SubseqRes e.HKRes = e.HKRes;
/*/
  s.SubseqRes e.HKRes = <Putout 21 s.SubseqRes e.HKRes> e.HKRes;
*/
}

CheckSubsequenceRelation {
  e._ t.Common e.CurrentExpr (t.Common e.HistoryExpr)
    = <CheckSubsequenceRelation e.CurrentExpr (e.HistoryExpr)>;

  e.CurrentExpr (/* пусто */) = True;
  e.CurrentExpr (e.HistoryExpr) = False;
}

Tokenize {
  e.Expression
    = <Map
        {
          (Brackets e.Inner) = ('(') <Tokenize e.Inner> (')');
          (ADT-Brackets (e.Name) e.Inner) = ('[' e.Name) <Tokenize e.Inner> (']');
          (CallBrackets e.Inner) = ('<') <Tokenize e.Inner> ('>');
          (ClosureBrackets e.Inner) = ('{{') <Tokenize e.Inner> ('}}');

          t.Other = t.Other;
        }
        e.Expression
      >
}

CheckHKRelation {
  e.CurrentExpr (/* пусто */) = True;
  /* пусто */ (e.HistoryExpr) = False;

  t.Common e.CurrentExpr (t.Common e.HistoryExpr)
    = <CheckHKRelation e.CurrentExpr (e.HistoryExpr)>;

  t.CurrentTerm e.CurrentExpr (t.HistoryTerm e.HistoryExpr)
    , <CheckHKRelation-Term t.CurrentTerm t.HistoryTerm> : True
    = <CheckHKRelation e.CurrentExpr (e.HistoryExpr)>;

  (s.Brackets e.Inner) e.CurrentExpr (e.HistoryExpr)
    , <AllBrackets> : e._ s.Brackets e._
    = <CheckHKRelation e.Inner e.CurrentExpr (e.HistoryExpr)>;

  (ADT-Brackets (e.Name) e.Inner) e.CurrentExpr (e.HistoryExpr)
    = <CheckHKRelation e.Inner e.CurrentExpr (e.HistoryExpr)>;

  t.Skip e.CurrentExpr (e.HistoryExpr)
    = <CheckHKRelation e.CurrentExpr (e.HistoryExpr)>;
}

AllBrackets {
  = Brackets CallBrackets ClosureBrackets;
}

CheckHKRelation-Term {
  (s.Brackets e.CurrentExpr) (s.Brackets e.HistoryExpr)
    , <AllBrackets> : e._ s.Brackets e._
    = <CheckHKRelation e.CurrentExpr (e.HistoryExpr)>;

  (ADT-Brackets (e.Name) e.CurrentExpr) (ADT-Brackets (e.Name) e.HistoryExpr)
    = <CheckHKRelation e.CurrentExpr (e.HistoryExpr)>;

  t.CurrentTerm t.HistoryTerm = False;
}

/**
  <OptTree-CanonizeExpr e.Expr> == e.CanonizedExpr
*/
$ENTRY OptTree-CanonizeExpr {
  e.Expr = <Map &CanonizeExpr-Term e.Expr>;
}

CanonizeExpr-Term {
  (Var s.Mode e.Index) = (Var s.Mode);
  (WhVar s.Mode e.Index) = (Var s.Mode);

  /* Не различаем замороженные и обычные скобки */
  (ColdCallBrackets e.Expr)
    = <OptTree-CanonizeExpr e.Expr> : e.Expr^
    = (CallBrackets e.Expr);

  (s.BracketsTag e.Expr)
    , <AllBrackets> : e._ s.BracketsTag e._
    = <OptTree-CanonizeExpr e.Expr> : e.Expr^
    = (s.BracketsTag e.Expr);

  (ADT-Brackets (e.Name) e.Expr)
    = <OptTree-CanonizeExpr e.Expr> : e.Expr^
    = (ADT-Brackets (e.Name) e.Expr);

  (Symbol Number s._) = (Symbol Number);

  t.OtherTerm = t.OtherTerm;
}
