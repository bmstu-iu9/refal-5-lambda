%%
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <float.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <time.h>
#include <vector>

#include "refalrts-platform-specific.h"

%%

*===============================================================================
*  Функции стандартной библиотеки Library Простого Рефала
*  и встроенные функции Рефала-5λ
*===============================================================================


*-------------------------------------------------------------------------------
*  Встроенные функции Рефала-5λ
*-------------------------------------------------------------------------------


/**
  <__Meta_Mu t.MuFunc e.Arg $table> == e.Res

  t.MuFunc ::= s.WORD | (s.CHAR+) | s.FUNCTION | s.CLOSURE | s.Op
  s.Op ::=
      '+' | '/' | '%' | '*' | '?' | '-'
    | "+" | "/" | "%" | "*" | "?" | "-"
*/
%%
namespace cookie_ns {

refalrts::RefalFunction *function_for_name(
  refalrts::VM *vm, refalrts::RefalFunction *metatable, const char *name
) {
  if (name[0] != '\0' && name[1] == '\0') {
    switch (name[0]) {
      case '+': name = "Add"; break;
      case '/': name = "Div"; break;
      case '%': name = "Mod"; break;
      case '*': name = "Mul"; break;
      case '?': name = "Residue"; break;
      case '-': name = "Sub"; break;

      default:
        return 0;
    }
  }

  refalrts::RefalFunction *func =
    refalrts::function_for_name(vm, metatable, name);

  if (func == 0) {
    const refalrts::RefalFuncName func_name(name, 0, 0);
    refalrts::Module *current = refalrts::current_module(vm);

    func = refalrts::lookup_function_in_module(vm, current, func_name);
    if (func == 0) {
      func = refalrts::lookup_function_in_domain(vm, func_name);
    }
  }

  return func;
}

}  // namespace cookie_ns
%%

$ENTRY __Meta_Mu {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter tMuFunc = 0;
  if (! refalrts::tvar_left(tMuFunc, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter sTable = 0;
  if (
    ! refalrts::svar_right(sTable, content_b, content_e)
    || refalrts::cDataFunction != sTable->tag
    || ! refalrts::is_metatable(vm, sTable->function_info)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  if (
    refalrts::cDataFunction == tMuFunc->tag
    || refalrts::cDataClosure == tMuFunc->tag
  ) {
    refalrts::splice_to_freelist(vm, pfunc_name, pfunc_name);
    refalrts::splice_to_freelist(vm, sTable, sTable);
    refalrts::push_stack(vm, arg_end);
    refalrts::push_stack(vm, arg_begin);
    return refalrts::cSuccess;
  }

  refalrts::RefalFunction *metatable = sTable->function_info;

  refalrts::RefalFunction *func;
  refalrts::Iter inner_b = 0, inner_e = 0;
  refalrts::Iter tMuFunc_end = tMuFunc;

  if (refalrts::cDataIdentifier == tMuFunc->tag) {
    func = refalrts::function_for_ident(vm, metatable, tMuFunc->ident_info);

    if (func == 0) {
      const char *name = tMuFunc->ident_info->name();
      func = cookie_ns::function_for_name(vm, metatable, name);
    }
  } else if (refalrts::brackets_term(inner_b, inner_e, tMuFunc)) {
    char name[300] = "";
    unsigned read = read_chars(name, sizeof(name) - 1, inner_b, inner_e);
    name[read] = '\0';

    // Слишком длинное имя функции или нашлись не литеры
    if (! refalrts::empty_seq(inner_b, inner_e)) {
      return refalrts::cRecognitionImpossible;
    }

    func = cookie_ns::function_for_name(vm, metatable, name);
    tMuFunc_end = tMuFunc->link_info;
  } else if (refalrts::cDataChar == tMuFunc->tag) {
    char name[2] = { tMuFunc->char_info, '\0' };
    func = cookie_ns::function_for_name(vm, metatable, name);
  } else {
    return refalrts::cRecognitionImpossible;
  }

  if (func == 0) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::update_name(pfunc_name, func);
  refalrts::splice_to_freelist(vm, tMuFunc, tMuFunc_end);
  refalrts::splice_to_freelist(vm, sTable, sTable);
  refalrts::push_stack(vm, arg_end);
  refalrts::push_stack(vm, arg_begin);
  return refalrts::cSuccess;
%%
}


/**
  2. <Add t.FirstNumber e.SecondNumber> == e.NormedNumber

  t.FirstNumber ::= s.NUMBER | ({'+'|'-'}? s.NUMBER+)
  e.SecondNumber ::= {'+'|'-'}? s.NUMBER+
  e.NormedNumber ::= '-'? s.NUMBER+
*/
$ENTRY Add {
  /* optimization for two digits */
  s.First s.Second = <__Step-Drop> <Add-Digits s.First s.Second>;

  e.ArithmArg
    , <__Step-Start> <NormArithmArg e.ArithmArg> : (e.First) e.Second
    = <Add-Normed (e.First) e.Second> <__Step-End>;
}

NormArithmArg {
  0 e.Second
    , <NormNumber e.Second> : s.SecondSign e.Second^
    = (0) s.SecondSign e.Second;

  s.First e.Second
    , <Type s.First> : 'N' s.SubType s.First^
    , <NormNumber e.Second> : s.SecondSign e.Second^
    = ('+' s.First) s.SecondSign e.Second;

  '+' s.First e.Second
    , <Type s.First> : 'N' s.SubType s.First^
    , <NormNumber e.Second> : s.SecondSign e.Second^
    = ('+' s.First) s.SecondSign e.Second;

  '-' s.First e.Second
    , <Type s.First> : 'N' s.SubType s.First^
    , <NormNumber e.Second> : s.SecondSign e.Second^
    = ('-' s.First) s.SecondSign e.Second;

  (e.First) e.Second
    , <NormNumber e.First> : s.FirstSign e.First^
    , <NormNumber e.Second> : s.SecondSign e.Second^
    = (s.FirstSign e.First) s.SecondSign e.Second;

  e.OtherArg = /* empty */;
}

NormNumber {
  '+' 0 = 0;
  '+' 0 e.Digits = <NormNumber '+' e.Digits>;

  '-' 0 = 0;
  '-' 0 e.Digits = <NormNumber '-' e.Digits>;

  0 = 0;
  0 e.Digits = <NormNumber '+' e.Digits>;

  '+' e.Digits, <AllDigits e.Digits> : True = '+' e.Digits;

  '-' e.Digits, <AllDigits e.Digits> : True = '-' e.Digits;

  e.Digits, <Type e.Digits> : 'N' s.SubType e.Digits^
    = <NormNumber '+' e.Digits>;

  e.Digits = /* empty */;
}

AllDigits {
  e.Items = <AllDigits-SwFirst <Type e.Items>>;
}

AllDigits-SwFirst {
  'N' s.SubType s.Digit /* empty */ = True;
  'N' s.SubType s.Digit e.Items = <AllDigits e.Items>;
  s.Type s.SubType e.Expr = False;
}

Add-Normed {
  ('+' e.First) '+' e.Second = <Add-Nat (e.First) e.Second>;
  ('+' e.First) '-' e.Second = <Sub-Nat (e.First) e.Second>;
  ('+' e.First) 0            = e.First;
  ('-' e.First) '+' e.Second = <Sub-Nat (e.Second) e.First>;
  ('-' e.First) '-' e.Second = '-' <Add-Nat (e.First) e.Second>;
  ('-' e.First) 0            = '-' e.First;
  (0)           '+' e.Second = e.Second;
  (0)           e.NegOrZero  = e.NegOrZero;
}

Add-Nat {
  (e.First s.FirstLast) e.Second s.SecondLast
    = <Add-Digits s.FirstLast s.SecondLast>
    : {
        s.LastSum = <Add-Nat (e.First) e.Second> s.LastSum;
        1 s.LastSum = <Add-Nat (e.First) <Add-Nat (e.Second) 1>> s.LastSum;
      };

  /* one of brackets is empty */
  (e.First) e.Second = e.First e.Second;
}

%%

#define ARITHM_PRELUDE \
  refalrts::Iter pFirst = 0, pSecond = 0; \
  refalrts::Iter pFunc \
    = refalrts::call_left(pFirst, pSecond, arg_begin, arg_end); \
  \
  if (pFirst->next != pSecond) { \
    return refalrts::cRecognitionImpossible; \
  } \
  \
  if ( \
    refalrts::cDataNumber != pFirst->tag \
    || refalrts::cDataNumber != pSecond->tag \
  ) { \
    return refalrts::cRecognitionImpossible; \
  } \
  \
  refalrts::RefalNumber first = pFirst->number_info; \
  refalrts::RefalNumber second = pSecond->number_info;

%%

Add-Digits {
%%
  ARITHM_PRELUDE

  refalrts::RefalNumber sum = first + second;

  if (sum >= first) {
    pFirst->number_info = sum;
    refalrts::splice_to_freelist(vm, arg_begin, pFunc);
    refalrts::splice_to_freelist(vm, pSecond, arg_end);
  } else {
    pFirst->number_info = 1;
    pSecond->number_info = sum;
    refalrts::splice_to_freelist(vm, arg_begin, pFunc);
    refalrts::splice_to_freelist(vm, arg_end, arg_end);
  }

  return refalrts::cSuccess;
%%
}


/**
  3. <Arg s.NUMBER> == e.Arg
  e.Arg ::= s.CHAR*
*/
$ENTRY Arg {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pparam_no = 0;
  if (
    ! refalrts::svar_left(pparam_no, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
    || refalrts::cDataNumber != pparam_no->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  unsigned int param_no = static_cast<unsigned int>(pparam_no->number_info);

  refalrts::Iter param_begin = 0;
  refalrts::Iter param_end = 0;
  const char *param = refalrts::arg(vm, param_no);
  param = param ? param : "";
  refalrts::alloc_string(vm, param_begin, param_end, param);
  refalrts::splice_evar(arg_begin, param_begin, param_end);
  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  4. <Br e.Key '=' e.Value> == []
*/
$ENTRY Br {
  e.Key '=' e.Value
    = <__Step-Start> <Buried (e.Key '=' e.Value) <Buried>> <__Step-End>;
}

$SWAP Buried;


/**
  5. <Card> == s.CHAR* 0?
*/
$ENTRY Card {
  = <__Step-Drop> <Get-Aux stdin>;
}


/**
  6. <Chr e.Expr> == e.Expr’
*/
%%
namespace {

template <typename Conv>
refalrts::FnResult convert(
  refalrts::VM *vm, refalrts::Iter arg_begin, refalrts::Iter arg_end, Conv conv
) {
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  while (! refalrts::empty_seq(content_b, content_e)) {
    if (conv.for_convert(content_b)) {
      conv.convert(content_b);
    }

    if (content_b->tag != refalrts::cDataOpenADT) {
      refalrts::move_left(content_b, content_e);
    } else {
      refalrts::Iter dummy;
      refalrts::tvar_left(dummy, content_b, content_e);
    }
  }

  refalrts::splice_to_freelist(vm, arg_begin, pfunc);
  refalrts::splice_to_freelist(vm, arg_end, arg_end);

  return refalrts::cSuccess;
}

struct ChrConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataNumber == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->tag = refalrts::cDataChar;
    item->char_info = static_cast<char>(item->number_info);
  }
};

}  // unnamed namespace
%%

$ENTRY Chr {
%%
  return convert(vm, arg_begin, arg_end, ChrConv());
%%
}


/**
  7. <Cp e.Key> == e.Value | []
*/
$ENTRY Cp {
  e.Key
    = <__Step-Start> <Buried>
    : {
        e.Values-B (e.Key '=' e.Value) e.Values-E
          = e.Value
            <Buried e.Values-B (e.Key '=' e.Value) e.Values-E>
            <__Step-End>;

        e.Values = <Buried e.Values> <__Step-End>;
      };
}


/**
  8. <Dg e.Key> == e.Value | []
*/
$ENTRY Dg {
  e.Key
    = <__Step-Start> <Buried>
    : {
        e.Values-B (e.Key '=' e.Value) e.Values-E
          = e.Value
            <Buried e.Values-B e.Values-E>
            <__Step-End>;

        e.Values = <Buried e.Values> <__Step-End>;
      };
}


/**
  9. <Dgall> == (e.Key '=' e.Value)*
*/
$ENTRY Dgall {
  = <__Step-Drop> <Buried>;
}


/**
  10. <Div t.FirstNumber e.SecondNumber> == e.NormedNumber
*/
$ENTRY Div {
  /* optimization for two digits */
  s.First s.Second
    = <__Step-Start> <Divmod-Digits s.First s.Second> : (s.Div) s.Rem
    = s.Div <__Step-End>;

  e.ArithmArg
    , <__Step-Start> <NormArithmArg e.ArithmArg> : (e.First) e.Second
    , <Divmod-Normed (e.First) e.Second> : (e.Div) e.Mod
    = e.Div <__Step-End>;
}


/**
  11. <Divmod (e.FirstNumber) e.SecondNumber> == (e.Quotient) e.Remainder
  e.Quotient, e.Remainder ::= e.NormedNumber
*/
$ENTRY Divmod {
  /* optimization for two digits */
  s.First s.Second = <__Step-Drop> <Divmod-Digits s.First s.Second>;

  e.ArithmArg
    , <__Step-Start> <NormArithmArg e.ArithmArg> : (e.First) s.Sign e.Second
    , '+-' : e.Signs-B s.Sign e.Signs-E
    = <Divmod-Normed (e.First) s.Sign e.Second> <__Step-End>;
}

Divmod-Digits {
%%
  ARITHM_PRELUDE

  if (0 == second) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter pleft_bracket = arg_begin;
  refalrts::Iter pdiv = pFunc;
  refalrts::Iter pright_bracket = pFirst;
  refalrts::Iter pmod = pSecond;
  refalrts::link_brackets(pleft_bracket, pright_bracket);

  refalrts::reinit_open_bracket(pleft_bracket);
  refalrts::reinit_number(pdiv, first / second);
  refalrts::reinit_close_bracket(pright_bracket);
  refalrts::update_number(pmod, first % second);
  refalrts::splice_to_freelist(vm, arg_end, arg_end);

  return refalrts::cSuccess;
%%
}

Divmod-Normed {
  ('+' e.First) '+' e.Second = <Divmod-Nat (e.First) e.Second (   ) (   )>;
  ('+' e.First) '-' e.Second = <Divmod-Nat (e.First) e.Second ('-') (   )>;
  ('-' e.First) '+' e.Second = <Divmod-Nat (e.First) e.Second ('-') ('-')>;
  ('-' e.First) '-' e.Second = <Divmod-Nat (e.First) e.Second (   ) ('-')>;
  (0)           e.AnySecond  = (0) 0;
}

Divmod-Nat {
  (s.Numerator) s.Denominator (e.QuotSign) (e.RemSing)
    = <Divmod-Digits s.Numerator s.Denominator> : (s.Quot) s.Rem
    = (e.QuotSign s.Quot) e.RemSing s.Rem;

  (e.Numerator) s.DenomFirst e.Denominator (e.QuotSign) (e.RemSing)
    = s.DenomFirst
    : {
%%
        refalrts::Iter pfunc = arg_begin->next;
        assert(refalrts::cDataFunction == pfunc->tag);

        refalrts::Iter pvalue = pfunc->next;
        assert(refalrts::cDataNumber == pvalue->tag);

        refalrts::RefalNumber value = pvalue->number_info;
        assert(value != 0);

        int shift = 0;
        while ((value & (1 << 31)) == 0) {
          ++shift;
          value <<= 1;
        }

        refalrts::reinit_number(arg_begin, shift);
        refalrts::reinit_number(pfunc, 32 - shift);
        refalrts::splice_to_freelist(vm, pvalue, arg_end);
        return refalrts::cSuccess;
%%
      }
    : s.NormShift s.RestoreShift
    = <Divmod-Shl s.NormShift e.Numerator> : e.Numerator^
    = <Divmod-Shl s.NormShift s.DenomFirst e.Denominator> : e.Denominator^
    = <Divmod-Nat-Normed (e.Numerator) e.Denominator> : (e.Quot) e.Rem
    = <Divmod-Shl s.RestoreShift e.Rem>
    : {
        0 = 0;
        e.Rem^ 0 = e.Rem;
      }
    : e.Rem^
    = (e.QuotSign e.Quot) e.RemSing e.Rem;
}

Divmod-Shl {
%%
  refalrts::Iter digits_b = 0, digits_e = 0;
  refalrts::call_left(digits_b, digits_e, arg_begin, arg_end);

  refalrts::Iter pshift;
  if (
    ! refalrts::svar_left(pshift, digits_b, digits_e)
    && refalrts::cDataNumber != pshift->tag
    && refalrts::empty_seq(digits_b, digits_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber shift = pshift->number_info;
  if (shift > 32) {
    return refalrts::cRecognitionImpossible;
  }

  if (0 == shift) {
    refalrts::splice_to_freelist(vm, arg_begin, pshift);
    refalrts::splice_to_freelist(vm, arg_end, arg_end);
    return refalrts::cSuccess;
  }

  refalrts::Iter garbage_end = pshift;
  refalrts::reinit_number(arg_end, 0);
  if (shift < 32) {
    refalrts::Iter current = digits_e;
    while (current != pshift) {
      current->next->number_info |= current->number_info << shift;
      current->number_info >>= 32 - shift;
      current = current->prev;
    }

    if (0 == digits_b->number_info) {
      garbage_end = digits_b;
    }
  }

  refalrts::splice_to_freelist(vm, arg_begin, garbage_end);
  return refalrts::cSuccess;
%%
}

Divmod-Nat-Normed {
  (e.Numerator) e.Denominator
    = <Divmod-Align (0) (e.Numerator) () e.Denominator>;
}

Divmod-Align {
  (e.Numerator) (s.N e.NumerRest) (e.Denominator) s.D e.DenominRest
    = <Divmod-Align
        (e.Numerator s.N) (e.NumerRest) (e.Denominator s.D) e.DenominRest
      >;

  (e.Numerator) (e.NumerRest) (e.Denominator) /* empty */
    = <Divmod-CalcDigits (e.Numerator) (e.NumerRest) e.Denominator>
    : e.Quot (e.Rest)
    = (<LeadingZeros e.Quot>) e.Rest;

  (0 e.Numerator) () (e.Denominator) e.DenominRest = (0) e.Numerator;
}

Divmod-CalcDigits {
  (e.Numerator) (e.NumerRest) e.Denominator
    = <Divmod-GetNextDigit (e.Numerator) e.Denominator> : s.QuotDigit e.Rem
    = e.NumerRest
    : {
        s.NextDigit e.NumerRest^
          = s.QuotDigit
            <Divmod-CalcDigits
              (e.Rem s.NextDigit) (e.NumerRest) e.Denominator
            >;

        /* empty */ = s.QuotDigit (e.Rem);
      };
}

Divmod-GetNextDigit {
  (s.N1 s.N2) s.D = <Divmod-GuessDigit s.N1 s.N2 s.D>;

  (s.N1 s.N2 e.Numerator) s.D e.Denominator
    = <Divmod-GuessDigit s.N1 s.N2 s.D> : s.QuotDigit s.RemDigit
    = <Divmod-AdjustDigit
        s.QuotDigit
        <Sub-Normed
          ('+' <LeadingZeros s.N1 s.N2 e.Numerator>)
          '+' <Mul-Nat-Line s.D e.Denominator s.QuotDigit>
        >
        (s.D e.Denominator)
      >;
}

Divmod-AdjustDigit {
  s.QuotDigit '-' e.Rem (e.Denominator)
    = <Divmod-AdjustDigit
        <Sub-Digits s.QuotDigit 1> <Sub-Nat (e.Denominator) e.Rem>
        (e.Denominator)
      >;

  s.QuotDigit e.Rem (e.Denominator) = s.QuotDigit e.Rem;
}

%%
namespace cookie_ns {

void long_mul(
  refalrts::UInt32& res_high, refalrts::UInt32& res_low,
  refalrts::UInt32 first, refalrts::UInt32 second
);

}  // namespace cookie_ns
%%

Divmod-GuessDigit {
%%
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pN1 = 0, pN2 = 0, pD = 0;
  if (
    ! refalrts::svar_left(pN1, content_b, content_e)
    || refalrts::cDataNumber != pN1->tag
    || ! refalrts::svar_left(pN2, content_b, content_e)
    || refalrts::cDataNumber != pN2->tag
    || ! refalrts::svar_left(pD, content_b, content_e)
    || refalrts::cDataNumber != pD->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }


  using refalrts::UInt32;
  UInt32 num_hi = pN1->number_info;
  UInt32 num_lo = pN2->number_info;
  UInt32 denom = pD->number_info;

  if (num_hi >= denom) {
    refalrts::reinit_number(arg_begin, 4294967295U);
    refalrts::reinit_char(pfunc, '*');
    refalrts::splice_to_freelist(vm, pN1, arg_end);
    return refalrts::cSuccess;
  }

  if (num_hi >= denom || (denom & (1 << 31)) == 0) {
    return refalrts::cRecognitionImpossible;
  }

  UInt32 denom_half_hi = denom >> 16;
  UInt32 quot_hi = num_hi / denom_half_hi;
  if (quot_hi >= 65536) {
    quot_hi = 65535;
  }

  UInt32 subst_hi, subst_lo;
  while (true) {
    cookie_ns::long_mul(subst_hi, subst_lo, quot_hi << 16, denom);

    if (subst_hi < num_hi || (subst_hi == num_hi && subst_lo <= num_lo)) {
      break;
    }
    --quot_hi;
  }

  if (subst_lo > num_lo) {
    --num_hi;
  }
  num_lo -= subst_lo;
  num_hi -= subst_hi;

  assert(num_hi < 65536);

  UInt32 num_major = (num_hi << 16) | (num_lo >> 16);
  assert(num_major < denom);
  UInt32 quot_lo = (num_major) / denom_half_hi;

  while (true) {
    cookie_ns::long_mul(subst_hi, subst_lo, quot_lo, denom);

    if (subst_hi < num_hi || (subst_hi == num_hi && subst_lo <= num_lo)) {
      break;
    }
    --quot_lo;
  }

  if (subst_lo > num_lo) {
    --num_hi;
  }
  num_lo -= subst_lo;
  num_hi -= subst_hi;

  assert(num_hi == 0);

  UInt32 quot = (quot_hi << 16) + quot_lo;
  UInt32 rem = num_lo;

  refalrts::reinit_number(arg_begin, quot);
  refalrts::reinit_number(pfunc, rem);
  refalrts::splice_to_freelist(vm, pN1, arg_end);

  return refalrts::cSuccess;
%%
}



/**
  12. <Explode s.COMPOUND> == s.CHAR*
*/
$ENTRY Explode {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pident = 0;
  if (
    ! refalrts::svar_right(pident, content_b, content_e)
    || refalrts::cDataIdentifier != pident->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator(vm);
  refalrts::alloc_string(vm, content_b, content_e, pident->ident_info->name());
  refalrts::splice_evar(arg_begin, content_b, content_e);
  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  13. <First s.N e.Prefix e.Suffix> == (e.Prefix) e.Suffix, |e.Prefix| == s.N
      <First s.N e.Expr> == (e.Expr), |e.Expr| < s.N
      s.N ::= s.NUMBER
*/
$ENTRY First {
%%
  refalrts::Iter pfunc_name = arg_begin->next;
  refalrts::Iter pcount = pfunc_name->next;

  if (refalrts::cDataNumber != pcount->tag) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber count = pcount->number_info;
  refalrts::Iter term = pcount->next;

  while(term != arg_end && count > 0) {
    if (
      refalrts::cDataOpenBracket == term->tag
      || refalrts::cDataOpenADT == term->tag
    ) {
      term = term->link_info;
    }

    term = term->next;
    --count;
  }

  refalrts::Iter open_bracket = pcount;
  refalrts::Iter close_bracket = arg_begin;
  refalrts::splice_stvar(term, close_bracket);
  refalrts::reinit_open_bracket(open_bracket);
  refalrts::reinit_close_bracket(close_bracket);
  refalrts::link_brackets(open_bracket, close_bracket);
  refalrts::splice_to_freelist(vm, pfunc_name, pfunc_name);
  refalrts::splice_to_freelist(vm, arg_end, arg_end);

  return refalrts::cSuccess;
%%
}


/**
  14. <Get s.FileNo> == s.CHAR* 0?
*/
$ENTRY Get {
  s.FileNo
    = <__Step-Start>
      <Autoopen 'r' s.FileNo> <Get-Aux <ZeroHandle s.FileNo stdin>>
      <__Step-End>;
}

ZeroHandle {
  0 s.Default = s.Default;
  s.FileNo s.Default = s.FileNo;
}

*$IDENT stdin, stdout, stderr, stout

%%
namespace {

#define USE_IDENT(ident_name) (identifiers[ident_ ## ident_name])

enum { cMaxFileHandles = 40 };
refalrts::GlobalRef<FILE*> g_file_handles(cMaxFileHandles);

bool file_handle_left(
  const refalrts::RefalIdentifier *identifiers,
  refalrts::Iter& pfile_handle, refalrts::Iter& first, refalrts::Iter& last
) {
  return refalrts::svar_left(pfile_handle, first, last)
    && (
      refalrts::cDataNumber == pfile_handle->tag
      || (
        refalrts::cDataIdentifier == pfile_handle->tag
        && (
          USE_IDENT(stdin) == pfile_handle->ident_info
          || USE_IDENT(stdout) == pfile_handle->ident_info
          || USE_IDENT(stderr) == pfile_handle->ident_info
          || USE_IDENT(stout) == pfile_handle->ident_info
        )
      )
    );
}

FILE *extract_file_handle(
  refalrts::VM *vm, const refalrts::RefalIdentifier *identifiers,
  refalrts::Iter pfile_handle
) {
  assert(
    refalrts::cDataNumber == pfile_handle->tag
    || refalrts::cDataIdentifier == pfile_handle->tag
  );

  if (refalrts::cDataNumber == pfile_handle->tag) {
    refalrts::RefalNumber file_no = pfile_handle->number_info % cMaxFileHandles;

    if (file_no == 0) {
      return 0;
    }

    return g_file_handles.ref(vm, file_no);
  } else if (refalrts::cDataIdentifier == pfile_handle->tag) {
    return
      USE_IDENT(stdin) == pfile_handle->ident_info ? stdin :
      USE_IDENT(stdout) == pfile_handle->ident_info ? stdout :
      USE_IDENT(stderr) == pfile_handle->ident_info ? stderr : stdout;
  } else {
    refalrts_switch_default_violation(pfile_handle->tag);
    return 0;   // предупреждение компилятора
  }
}

bool release_file_handle(refalrts::VM *vm, refalrts::Iter pfile_handle) {
  if (refalrts::cDataIdentifier == pfile_handle->tag) {
    return true;
  }

  assert(refalrts::cDataNumber == pfile_handle->tag);

  refalrts::RefalNumber file_no = pfile_handle->number_info % cMaxFileHandles;

  assert(g_file_handles.ref(vm, file_no) != 0);

  bool successful_closed = EOF != fclose(g_file_handles.ref(vm, file_no));
  g_file_handles.ref(vm, file_no) = 0;
  return successful_closed;
}

bool open_handle(
  refalrts::VM *vm,
  refalrts::RefalNumber file_no, const char *filename, const char *mode
) {
  if (0 != g_file_handles.ref(vm, file_no)) {
    return false;
  }

  char default_name[sizeof("REFAL4294967296.DAT")];
  if ((filename == 0 || strlen(filename) == 0)) {
    sprintf(default_name, "REFAL%d.DAT", file_no);
    filename = default_name;
  }

  return (g_file_handles.ref(vm, file_no) = fopen(filename, mode)) != 0;
}

bool reopen_handle(
  refalrts::VM *vm,
  refalrts::Iter pfile_handle, const char *filename, const char *mode
) {
  assert(refalrts::cDataNumber == pfile_handle->tag);

  refalrts::RefalNumber file_no = pfile_handle->number_info % cMaxFileHandles;

  if (g_file_handles.ref(vm, file_no) != 0) {
    if (! release_file_handle(vm, pfile_handle)) {
      return false;
    }
  }

  return open_handle(vm, file_no, filename, mode);
}

}  // unnamed namespace
%%

Autoopen {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pmode = 0;
  refalrts::Iter pfile_handle = 0;
  if (
    ! refalrts::svar_left(pmode, content_b, content_e)
    || refalrts::cDataChar != pmode->tag
    || ('r' != pmode->char_info && 'w' != pmode->char_info)
    || ! file_handle_left(identifiers, pfile_handle, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  bool success = true;
  if (refalrts::cDataNumber == pfile_handle->tag) {
    refalrts::RefalNumber file_no = pfile_handle->number_info % cMaxFileHandles;

    if (0 != file_no && 0 == g_file_handles.ref(vm, file_no)) {
      char default_mode[] = { pmode->char_info, '\0' };
      success = open_handle(vm, file_no, 0, default_mode);
    }
  }

  if (! success) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

Get-Aux {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;

  if (
    ! file_handle_left(identifiers, pfile_handle, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator(vm);

  FILE *handle = extract_file_handle(vm, identifiers, pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter dummy = 0;
  int cur_char;
  while ((cur_char = getc(handle)) != EOF && cur_char != '\n') {
    /*
      Пользуемся тем фактом, что в данной реализации размещёные в свободной
      памяти узлы располагаются в последовательных адресах.
    */
    refalrts::alloc_char(vm, dummy, static_cast<char>(cur_char));
  }

  if (cur_char == EOF) {
    refalrts::alloc_number(vm, dummy, 0UL);
  }

  refalrts::splice_from_freelist(vm, arg_begin);
  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  15. <Implode e.NameChars e.NotNameTerms> == s.COMPOUND e.NotNameTerms
      <Implode e.NotNameTerms> == 0 e.NotNameTerms
*/
$ENTRY Implode {
  s.Init e.Tail
    /* Тут нельзя записать через условия, потому что __Step-Start */
    = <__Step-Start> <Type s.Init>
    : {
        'L' s.SubType s.Init^ = <DoImplode (s.Init) e.Tail> <__Step-End>;

        s.Type s.SubType s.Init^ = 0 s.Init e.Tail <__Step-End>;
      };

  e.InvalidExpr = 0 e.InvalidExpr;
}

DoImplode {
  (e.Scanned) '-' e.Tail = <DoImplode (e.Scanned '-') e.Tail>;
  (e.Scanned) '_' e.Tail = <DoImplode (e.Scanned '_') e.Tail>;
  (e.Scanned) '$' e.Tail = <DoImplode (e.Scanned '$') e.Tail>;

  (e.Scanned) s.Next e.Tail, <Type s.Next> : 'L' s.SubType s.Lettern
    = <DoImplode (e.Scanned s.Lettern) e.Tail>;

  (e.Scanned) s.Next e.Tail, <Type s.Next> : 'D' s.SubType s.Digit
    = <DoImplode (e.Scanned s.Digit) e.Tail>;

  (e.Scanned) e.Other = <Implode_Ext e.Scanned> e.Other;
}


/**
  16. <Last s.N e.Prefix e.Suffix> == (e.Prefix) e.Suffix, |e.Suffix| == s.N
      <Last s.N e.Expr> == () e.Expr, |e.Expr| < s.N
*/
$ENTRY Last {
%%
  refalrts::Iter pfunc_name = arg_begin->next;
  refalrts::Iter pcount = pfunc_name->next;

  if (refalrts::cDataNumber != pcount->tag) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber count = pcount->number_info;
  refalrts::Iter term_end = arg_end->prev;

  while (term_end != pcount && count > 0) {
    if (
      refalrts::cDataCloseBracket == term_end->tag
      || refalrts::cDataCloseADT == term_end->tag
    ) {
      term_end = term_end->link_info;
    }

    term_end = term_end->prev;
    --count;
  }

  refalrts::Iter open_bracket = pcount;
  refalrts::Iter close_bracket = arg_begin;
  refalrts::splice_stvar(term_end->next, close_bracket);
  refalrts::reinit_open_bracket(open_bracket);
  refalrts::reinit_close_bracket(close_bracket);
  refalrts::link_brackets(open_bracket, close_bracket);
  refalrts::splice_to_freelist(vm, pfunc_name, pfunc_name);
  refalrts::splice_to_freelist(vm, arg_end, arg_end);

  return refalrts::cSuccess;
%%
}


/**
  17. <Lenw e.Expr> == s.N e.Expr, where s.N == |e.Expr|
*/
$ENTRY Lenw {
%%
  refalrts::Iter pfunc_name = arg_begin->next;
  refalrts::RefalNumber count = 0;

  refalrts::Iter term = pfunc_name->next;

  while (term != arg_end) {
    if (
      refalrts::cDataOpenBracket == term->tag
      || refalrts::cDataOpenADT == term->tag
    ) {
      term = term->link_info;
    }

    ++count;
    term = term->next;
  }

  refalrts::Iter pcount = pfunc_name;
  refalrts::reinit_number(pcount, count);
  refalrts::splice_to_freelist(vm, arg_begin, arg_begin);
  refalrts::splice_to_freelist(vm, arg_end, arg_end);

  return refalrts::cSuccess;
%%
}


/**
  18. <Lower e.Expr> == e.Expr’
*/
%%
namespace {

struct LowerConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataChar == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->char_info = static_cast<char>(tolower(item->char_info));
  }
};

}  // unnamed namespace
%%

$ENTRY Lower {
%%
  return convert(vm, arg_begin, arg_end, LowerConv());
%%
}


/**
  19. <Mod t.FirstNumber e.SecondNumber> == e.NormedNumber
*/
$ENTRY Mod {
  /* optimization for two digits */
  s.First s.Second
    = <__Step-Start> <Divmod-Digits s.First s.Second> : (s.Div) s.Mod
    = s.Mod <__Step-End>;

  e.ArithmArg
    , <__Step-Start> <NormArithmArg e.ArithmArg> : (e.First) e.Second
    , <Divmod-Normed (e.First) e.Second> : (e.Div) e.Mod
    = e.Mod <__Step-End>;
}



/**
  20. <Mul t.FirstNumber e.SecondNumber> == e.NormedNumber
*/
$ENTRY Mul {
  /* optimization for two digits */
  s.First s.Second = <__Step-Drop> <Mul-Digits s.First s.Second>;

  e.ArithmArg
    , <__Step-Start> <NormArithmArg e.ArithmArg> : (e.First) e.Second
    = <Mul-Normed (e.First) e.Second> <__Step-End>;
}

%%
void cookie_ns::long_mul(
  refalrts::UInt32& res_high, refalrts::UInt32& res_low,
  refalrts::UInt32 first, refalrts::UInt32 second
) {
  /*
    Double-word multiplication scheme:

    (x,y,z,t) = (F,i)*(S,e)     -- first * second

       S   e        (A,a) = F * S
     ---------      (B,b) = i * S
     |\ b|\ d|      (C,c) = F * e
    i| \ | \ |t     (D,d) = i * e
     |B \|D \|
     ---------      t = d
     |\ a|\ c|      (Z,z) = b + D + c
    F| \ | \ |z     (Y,y) = B + a + C + Z
     |A \|C \|      x = A + Y
     ---------
       x   y        (x,y) = (A, a) + B + C + Z
  */

  using refalrts::UInt32;

  UInt32 F = first >> 16;
  UInt32 i = first & 0xFFFFU;
  UInt32 S = second >> 16;
  UInt32 e = second & 0xFFFFU;

  UInt32 Aa = F * S;
  UInt32 Bb = i * S;
  UInt32 Cc = F * e;
  UInt32 Dd = i * e;

  UInt32 Zz = (Bb & 0xFFFFU) + (Dd >> 16) + (Cc & 0xFFFFU);
  res_low = (Zz << 16) + (Dd & 0xFFFFU);
  res_high = Aa + (Bb >> 16) + (Cc >> 16) + (Zz >> 16);
}
%%

Mul-Digits {
%%
  ARITHM_PRELUDE

  refalrts::UInt32 res_high, res_low;
  cookie_ns::long_mul(res_high, res_low, first, second);

  if (res_high > 0) {
    refalrts::reinit_number(arg_begin, res_high);
    refalrts::reinit_number(pFunc, res_low);
    refalrts::splice_to_freelist(vm, pFirst, arg_end);
  } else {
    refalrts::reinit_number(arg_begin, res_low);
    refalrts::splice_to_freelist(vm, pFunc, arg_end);
  }

  return refalrts::cSuccess;
%%
}

Mul-Normed {
  ('+' e.First) '+' e.Second = <Mul-Nat (e.First) e.Second>;
  ('+' e.First) '-' e.Second = '-' <Mul-Nat (e.First) e.Second>;
  ('+' e.First) 0            = 0;
  ('-' e.First) '+' e.Second = '-' <Mul-Nat (e.First) e.Second>;
  ('-' e.First) '-' e.Second = <Mul-Nat (e.First) e.Second>;
  ('-' e.First) 0            = 0;
  (0)           e.AnySecond  = 0;
}

Mul-Nat {
  (e.First) s.SecondLast = <Mul-Nat-Line e.First s.SecondLast>;

  (e.First) e.Second s.SecondLast
    = <Add-Nat
        (<Mul-Nat (e.First) e.Second> 0) <Mul-Nat-Line e.First s.SecondLast>
      >;
}

Mul-Nat-Line {
  s.FirstLast s.Second = <Mul-Digits s.FirstLast s.Second>;

  e.First s.FirstLast s.Second
    = <Mul-Digits s.FirstLast s.Second>
    : {
        s.MulHigh s.MulLow
          = <Add-Nat (<Mul-Nat-Line e.First s.Second>) s.MulHigh> s.MulLow;

        s.MulLow = <Mul-Nat-Line e.First s.Second> s.MulLow;
      };
}


/**
  21. <Numb {'+'|'-'}? s.DIGIT-CHAR* e.NotDigitChars> == '-'? s.MACRODIGIT+
*/
$ENTRY Numb {
  '-' e.String = <__Step-Start> <Neg <Numb-Aux e.String>> <__Step-End>;

  '+' e.String = <__Step-Start> <Numb-Aux e.String> <__Step-End>;

  e.String = <__Step-Start> <Numb-Aux e.String> <__Step-End>;
}

Numb-Aux {
  e.String = <DoNumb (0) e.String>;
}

DoNumb {
  (e.Value) '0' e.Rest = <DoNumb <DoNumb-AddDigit e.Value 0> e.Rest>;
  (e.Value) '1' e.Rest = <DoNumb <DoNumb-AddDigit e.Value 1> e.Rest>;
  (e.Value) '2' e.Rest = <DoNumb <DoNumb-AddDigit e.Value 2> e.Rest>;
  (e.Value) '3' e.Rest = <DoNumb <DoNumb-AddDigit e.Value 3> e.Rest>;
  (e.Value) '4' e.Rest = <DoNumb <DoNumb-AddDigit e.Value 4> e.Rest>;
  (e.Value) '5' e.Rest = <DoNumb <DoNumb-AddDigit e.Value 5> e.Rest>;
  (e.Value) '6' e.Rest = <DoNumb <DoNumb-AddDigit e.Value 6> e.Rest>;
  (e.Value) '7' e.Rest = <DoNumb <DoNumb-AddDigit e.Value 7> e.Rest>;
  (e.Value) '8' e.Rest = <DoNumb <DoNumb-AddDigit e.Value 8> e.Rest>;
  (e.Value) '9' e.Rest = <DoNumb <DoNumb-AddDigit e.Value 9> e.Rest>;

  (e.Value) e.Rest = e.Value;
}

DoNumb-AddDigit {
  e.Value s.Digit = (<Add-Nat (<Mul-Nat-Line e.Value 10>) s.Digit>);
}


/**
  22. <Open s.Mode s.FileNo e.FileName> == []
  s.Mode ::=
      'r' | 'w' | 'a'
    | 'R' | 'W' | 'A'
    | s.COMPOUND | (s.CHAR*)
*/
$ENTRY Open {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  std::string mode;

  refalrts::Iter mode_b = 0;
  refalrts::Iter mode_e = 0;
  refalrts::Iter pmode = 0;

  if (! refalrts::tvar_left(pmode, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  if (refalrts::char_term('r', pmode) || refalrts::char_term('R', pmode)) {
    mode = "r";
  } else if (
    refalrts::char_term('w', pmode) || refalrts::char_term('W', pmode)
  ) {
    mode = "w";
  } else if (
    refalrts::char_term('a', pmode) || refalrts::char_term('A', pmode)
  ) {
    mode = "a";
  } else if (refalrts::brackets_term(mode_b, mode_e, pmode)) {
    char mode_str[100] = { '\0' };  // должно хватить
    unsigned len =
      refalrts::read_chars(mode_str, sizeof(mode_str) - 1, mode_b, mode_e);

    if (! refalrts::empty_seq(mode_b, mode_e) || len == 0) {
      return refalrts::cRecognitionImpossible;
    }

    mode = mode_str;
  } else if (refalrts::cDataIdentifier == pmode->tag) {
    mode = pmode->ident_info->name();
  } else {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter pfile_handle = 0;
  if (
    ! file_handle_left(identifiers, pfile_handle, content_b, content_e)
    || refalrts::cDataNumber != pfile_handle->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  char filename[FILENAME_MAX + 1] = { '\0' };
  refalrts::read_chars(filename, FILENAME_MAX, content_b, content_e);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  if (! reopen_handle(vm, pfile_handle, filename, mode.c_str())) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  23. <Ord e.Expr> == e.Expr’
*/
%%
namespace {

struct OrdConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataChar == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->tag = refalrts::cDataNumber;
    item->number_info = static_cast<unsigned char>(item->char_info);
  }
};

}  // unnamed namespace
%%

$ENTRY Ord {
%%
  return convert(vm, arg_begin, arg_end, OrdConv());
%%
}


/**
  24. <Print e.AnyExpression> == e.AnyExpression
*/
$ENTRY Print {
  e.AnyExpression = <__Step-Drop> <Put-Aux stdout e.AnyExpression>;
}


/**
  25. <Prout e.AnyExpression> == []
*/
$ENTRY Prout {
  e.AnyExpression = <__Step-Drop> <Putout-Aux stdout e.AnyExpression>;
}

/**
  Proud and Trout are synonyms for Prout :-)
*/
$ENTRY Proud { e.AnyExpression = <Prout e.AnyExpression>; }
$ENTRY Trout { e.AnyExpression = <Prout e.AnyExpression>; }


/**
  26. <Put s.FileNo e.AnyExpression> == e.AnyExpression
*/
$ENTRY Put {
  s.FileNo e.AnyExpression
    = <__Step-Start>
      <Autoopen 'w' s.FileNo>
      <Put-Aux <ZeroHandle s.FileNo stderr> e.AnyExpression>
      <__Step-End>;
}

%%
namespace cookie_ns {

enum {
  cFlags_Transparent    = 1 << 5,
  cFlags_NoEOL          = 1 << 8,
};

extern refalrts::FnResult fwrite_line(
  refalrts::VM *vm, const refalrts::RefalIdentifier *identifiers,
  refalrts::Iter arg_begin, refalrts::Iter arg_end, unsigned flags
);

}  // namespace cookie_ns
%%

Put-Aux {
%%
  return cookie_ns::fwrite_line(
    vm, identifiers, arg_begin, arg_end, cookie_ns::cFlags_Transparent
  );
%%
}

%%
refalrts::FnResult cookie_ns::fwrite_line(
  refalrts::VM *vm, const refalrts::RefalIdentifier *identifiers,
  refalrts::Iter arg_begin, refalrts::Iter arg_end, unsigned flags
) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;

  if (! file_handle_left(identifiers, pfile_handle, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(vm, identifiers, pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  if (ferror(handle)) {
    return refalrts::cRecognitionImpossible;
  }

  if (stderr == handle) {
    fflush(stdout);
  }

  int printf_res = 0;

  for (
    refalrts::Iter p = content_b, end = content_e;
    printf_res >= 0 && ! refalrts::empty_seq(p, end);
    refalrts::move_left(p, end)
  ) {
    switch(p->tag) {
      case refalrts::cDataChar:
        printf_res = fprintf(handle, "%c", p->char_info);
        break;

      case refalrts::cDataNumber:
        printf_res = fprintf(handle, "%u ", p->number_info);
        break;

      case refalrts::cDataFunction:
        printf_res = fprintf(
          handle, "%s ", refalrts::function_name(p->function_info)->name
        );
        break;

      case refalrts::cDataIdentifier:
        printf_res = fprintf(handle, "%s ", p->ident_info->name());
        break;

      case refalrts::cDataOpenADT:
        printf_res = fprintf(handle, "[");
        break;

      case refalrts::cDataCloseADT:
        printf_res = fprintf(handle, "]");
        break;

      case refalrts::cDataOpenBracket:
        printf_res = fprintf(handle, "(");
        break;

      case refalrts::cDataCloseBracket:
        printf_res = fprintf(handle, ")");
        break;

      case refalrts::cDataFile:
        printf_res = fprintf(handle, "*%p", p->file_info);
        break;

      case refalrts::cDataClosure:
        printf_res = fprintf(handle, "{ ");
        p = refalrts::unwrap_closure(p);
        break;

      case refalrts::cDataClosureHead:
        printf_res = fprintf(handle, "[%u] ", p->number_info);
        break;

      case refalrts::cDataUnwrappedClosure:
        printf_res = fprintf(handle, "} ");
        refalrts::wrap_closure(p);
        break;

      default:
        refalrts_switch_default_violation(p->tag);
    }
  }

  if (printf_res >= 0 && ! (flags & cFlags_NoEOL)) {
    printf_res = fprintf(handle, "\n");
  }

  if (printf_res < 0) {
    return refalrts::cRecognitionImpossible;
  }

  if (flags & cFlags_Transparent) {
    refalrts::splice_evar(arg_begin, content_b, content_e);
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
}
%%


/**
  27. <Putout s.FileNo e.AnyExpression> == []
*/
$ENTRY Putout {
  s.FileNo e.AnyExpression
    = <__Step-Start>
      <Autoopen 'w' s.FileNo>
      <Putout-Aux <ZeroHandle s.FileNo stderr> e.AnyExpression>
      <__Step-End>;
}

Putout-Aux {
%%
  return cookie_ns::fwrite_line(vm, identifiers, arg_begin, arg_end, 0);
%%
}


/**
  28. <Rp e.Key '=' e.Value> == []
*/
$ENTRY Rp {
  e.Key '=' e.NewValue
    = <__Step-Start> <Buried>
    : {
        e.Values-B (e.Key '=' e.OldValue) e.Values-E
          = <Buried e.Values-B (e.Key '=' e.NewValue) e.Values-E>
            <__Step-End>;

        e.Values
          = <Buried (e.Key '=' e.NewValue) e.Values> <__Step-End>;
      };
}


/**
  29. <Step> == s.NUMBER
*/
%%
namespace cookie_ns {

extern unsigned long raw_step(refalrts::VM *vm);
refalrts::GlobalRef<unsigned long> g_correction;

}  // namespace cookie_ns
%%

$ENTRY Step {
%%
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber step =
    static_cast<refalrts::RefalNumber>(
      cookie_ns::raw_step(vm) - cookie_ns::g_correction.ref(vm)
    );

  refalrts::reinit_number(arg_begin, step);
  refalrts::splice_to_freelist(vm, pfunc, arg_end);

  return refalrts::cSuccess;
%%
}

%%
unsigned long cookie_ns::raw_step(refalrts::VM *vm) {
  double perfomance_counters[
    refalrts::cPerformanceCounter_COUNTERS_NUMBER
  ];

  refalrts::read_performance_counters(vm, perfomance_counters);
  return static_cast<unsigned long>(
    perfomance_counters[refalrts::cPerformanceCounter_TotalSteps]
  );
}

namespace cookie_ns {

refalrts::GlobalRef<unsigned long> g_start_step;

}  // namespace cookie_ns
%%

/*
  <__Step-Start e.Any> == []
  <__Step-End e.Any> == []
  <__Step-Drop e.Any> == []
*/
$ENTRY __Step-Start {
%%
  if (0 != cookie_ns::g_start_step.ref(vm)) {
    return refalrts::cRecognitionImpossible;
  }
  cookie_ns::g_start_step.ref(vm) = cookie_ns::raw_step(vm);

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

$ENTRY __Step-End {
%%
  if (0 == cookie_ns::g_start_step.ref(vm)) {
    return refalrts::cRecognitionImpossible;
  }
  cookie_ns::g_correction.ref(vm) +=
    (cookie_ns::raw_step(vm) - cookie_ns::g_start_step.ref(vm)) + 1;
  cookie_ns::g_start_step.ref(vm) = 0;

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

$ENTRY __Step-Drop {
%%
  /* Шаг вызова себя и шаг предыдущей функции */
  cookie_ns::g_correction.ref(vm) += 2;

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  30. <Sub t.FirstNumber e.SecondNumber> == e.NormedNumber
*/
$ENTRY Sub {
  /* optimization for two digits */
  s.First s.Second = <__Step-Drop> <Sub-Digits s.First s.Second>;

  e.ArithmArg
    , <__Step-Start> <NormArithmArg e.ArithmArg> : (e.First) e.Second
    = <Sub-Normed (e.First) e.Second> <__Step-End>;
}

Sub-Digits {
%%
  ARITHM_PRELUDE

  if (first >= second) {
    refalrts::reinit_number(arg_begin, first - second);
    refalrts::splice_to_freelist(vm, pFunc, arg_end);
  } else {
    refalrts::reinit_char(arg_begin, '-');
    refalrts::reinit_number(pFunc, second - first);
    refalrts::splice_to_freelist(vm, pFirst, arg_end);
  }

  return refalrts::cSuccess;
%%
}

Sub-Normed {
  ('+' e.First) '+' e.Second = <Sub-Nat (e.First) e.Second>;
  ('+' e.First) '-' e.Second = <Add-Nat (e.First) e.Second>;
  ('+' e.First) 0            = e.First;
  ('-' e.First) '+' e.Second = '-' <Add-Nat (e.First) e.Second>;
  ('-' e.First) '-' e.Second = <Neg <Sub-Nat (e.First) e.Second>>;
  ('-' e.First) 0            = '-' e.First;
  (0)           '+' e.Second = '-' e.Second;
  (0)           '-' e.Second = e.Second;
  (0)           0            = 0;
}

Neg {
  0 = 0;
  '-' e.Digits = e.Digits;
  e.Digits = '-' e.Digits;
}

Sub-Nat {
  (e.First) e.Second
    = <Compare-Nat (e.First) e.Second>
    : {
        '+' = <Sub-Nat-Nat (e.First) e.Second>;
        '-' = '-' <Sub-Nat-Nat (e.Second) e.First>;
        '0' = 0;
      };
}

Sub-Nat-Nat {
  (e.First) e.Second = <LeadingZeros <DoSub-Nat-Nat (e.First) e.Second>>;
}

DoSub-Nat-Nat {
  (e.First s.FirstLast) e.Second s.SecondLast
    = s.FirstLast s.SecondLast
    : {
%%
        ARITHM_PRELUDE

        refalrts::RefalNumber diff = first - second;

        if (diff <= first) {
          pFirst->number_info = diff;
          refalrts::splice_to_freelist(vm, arg_begin, pFunc);
          refalrts::splice_to_freelist(vm, pSecond, arg_end);
        } else {
          refalrts::reinit_char(pFirst, '*');
          pSecond->number_info = diff;
          refalrts::splice_to_freelist(vm, arg_begin, pFunc);
          refalrts::splice_to_freelist(vm, arg_end, arg_end);
        }

        return refalrts::cSuccess;
%%
      }
    : {
        s.LastDigit = <DoSub-Nat-Nat (e.First) e.Second> s.LastDigit;

        '*' s.LastDigit
          = <DoSub-Nat-Nat (<Sub-Nat-Nat (e.First) 1>) e.Second> s.LastDigit;
      };

  (e.First) /* empty */ = e.First;
}

LeadingZeros {
  0 = 0;
  0 e.Digits = <LeadingZeros e.Digits>;
  e.Digits = e.Digits;
}

/**
  31. <Symb e.Sign s.NUMBER+> == e.Sign s.CHAR-DIGIT+
  e.Sign ::= {'+'|'-'}?
*/
$ENTRY Symb {
  s.Number = <__Step-Drop> <Symb-Digit s.Number>;

  s.First e.Tail
    = <__Step-Start> <NormNumber s.First e.Tail>
    : s.NormedSign e.NormedNumber
    = s.First s.NormedSign
    : {
        0 0 = '0' <__Step-End>;
        s.Sign 0 = s.Sign '0' <__Step-End>;
        s.Sign s.Sign = s.Sign <Symb-Nat e.NormedNumber> <__Step-End>;
        s.Digit '+' = <Symb-Nat e.NormedNumber> <__Step-End>;
      };
}

Symb-Nat {
  s.Number = <Symb-Digit s.Number>;

  e.Number
    = <Divmod-Nat (e.Number) 1000000000 () ()> : (e.Div) s.Mod
    = <Last 9 '000000000' <Symb-Digit s.Mod>> : (e.Zeros) e.StrDigits
    = <Symb-Nat e.Div> e.StrDigits;
}


/**
  32. <Time> == e.Time
      e.Time ::= s.CHAR+  — represents time as ctime() format
*/
$ENTRY Time {
%%
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator(vm);

  time_t timer;
  time(&timer);
  char *str_time = ctime(&timer);

  char *newline = strchr(str_time, '\n');
  if (newline) {
    *newline = '\0';
  }

  refalrts::alloc_string(vm, content_b, content_e, str_time);
  refalrts::splice_evar(arg_begin, content_b, content_e);
  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  33. <Type e.Expr> == s.Type s.SubType e.Expr

  s.Type and s.SubType describes begin of e.Expr

  s.Type s.SubType ::=
      'Lu' -- latin uppercase letter
    | 'Ll' -- latin lowercase letter
    | 'D0' -- decimal digit
    | 'Wi' -- identifier (compound symbol that can be written w/o quotes)
    | 'Wq' -- other compound symbol (must be enclosed to "...")
    | 'N0' -- macrodigit
    | 'Pu' -- uppercase printable symbol (isupper(c) returns true)
    | 'Pl' -- lowercase printable symbol
    | 'Ou' -- uppercase other symbol (isupper(c) returns true)
    | 'Ol' -- lowercase other symbol
    | 'B0' -- structure brackets (parenthesis)
    | '*0' -- e.Expr is empty expression

      -- extensions of Refal-5λ
    | 'H0' -- handle (pointer, refalrts::Node::file_info)
    | 'Fg' -- global function
    | 'Fc' -- closure capturing context
    | 'Ba' -- ADT brackets [square brackets]
*/
$ENTRY Type {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  char type = '*';
  char subtype = '0';

  if (! refalrts::empty_seq(content_b, content_e)) {
    switch (content_b->tag) {
    case refalrts::cDataChar:
      {
        char ch = content_b->char_info;

        if (isdigit(ch)) {
          type = 'D';
        } else {
          if (isalpha(ch)) {
            type = 'L';
          } else if (isprint(ch)) {
            type = 'P';
          } else {
            type = 'O';
          }

          if (isupper(ch)) {
            subtype = 'u';
          } else {
            subtype = 'l';
          }
        }
      }
      break;

    case refalrts::cDataNumber:
      type = 'N';
      break;

    case refalrts::cDataFunction:
      type = 'F';
      subtype = 'g';
      break;

    case refalrts::cDataIdentifier:
      {
        const char *name = content_b->ident_info->name();

        type = 'W';
        subtype = 'q';
        if (isalpha(*name)) {
          while (
            *name != '\0' && (isalnum(*name) || *name == '_' || *name == '-')
          ) {
            ++name;
          }

          if (*name == '\0') {
            subtype = 'i';
          }
        }
      }
      break;

    case refalrts::cDataOpenADT:
      type = 'B';
      subtype = 'a';
      break;

    case refalrts::cDataOpenBracket:
      type = 'B';
      break;

    case refalrts::cDataFile:
      type = 'H';
      break;

    case refalrts::cDataClosure:
      type = 'F';
      subtype = 'c';
      break;

    default:
      refalrts_switch_default_violation(content_b->tag);
      // break;
    }
  }

  refalrts::reinit_char(arg_begin, type);
  refalrts::reinit_char(pfunc_name, subtype);
  refalrts::splice_to_freelist(vm, arg_end, arg_end);

  return refalrts::cSuccess;
%%
}


/**
  34. <Upper e.Expr> == e.Expr’
*/
%%
namespace {

struct UpperConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataChar == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->char_info = static_cast<char>(toupper(item->char_info));
  }
};

}  // unnamed namespace
%%

$ENTRY Upper {
%%
  return convert(vm, arg_begin, arg_end, UpperConv());
%%
}


/**
  35. <Sysfun 1 e.FileName> == e.ObjectExpression
      <Sysfun 2 e.FileName (s.Width e.ObjectExpression)> == []
      e.FileName ::= s.CHAR+
      s.Width ::= s.MACRODIGIT
*/
$ENTRY Sysfun {
  1 e.FileName = <__Step-Start> <Sysfun-Xxin e.FileName> <__Step-End>;

  2 e.FileName (s.Width e.ObjectExpression)
    = <__Step-Start>
      <Sysfun-Xxout e.FileName (s.Width e.ObjectExpression)>
      <__Step-End>;
}

Sysfun-Xxin {
  e.FileName
    = <ExistFile e.FileName>
    : {
        True
          = <Open-Auto 'r' e.FileName> : s.FileNo
          = <Xxin-Scan s.FileNo General ('^') <Type <Get-Aux s.FileNo>>>;

        False = /* empty */;
      };
}

Xxin-Scan {
  s.FileNo s.State (t.Stack e.Scanned) '*' s.0
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned) <Type <Get-Aux s.FileNo>>>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S '\\' e.Tail
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned '\\') <Type e.Tail>>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S '\'' e.Tail
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned '\'') <Type e.Tail>>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S '\"' e.Tail
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned '\"') <Type e.Tail>>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S '(' e.Tail
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned '(') <Type e.Tail>>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S ')' e.Tail
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned ')') <Type e.Tail>>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S '<' e.Tail
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned '<') <Type e.Tail>>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S '>' e.Tail
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned '>') <Type e.Tail>>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S 'n' e.Tail
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned '\n') <Type e.Tail>>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S 't' e.Tail
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned '\t') <Type e.Tail>>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S 'r' e.Tail
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned '\r') <Type e.Tail>>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S 'x' e.Tail
    = <Xxin-Scan
        s.FileNo Escape-Hex ((s.State t.Stack e.Scanned)) <Type e.Tail>
      >;

  s.FileNo Escape-Hex ((s.State t.Stack e.Scanned) s.D1 s.D2) s.T s.S e.Tail
    = <Xxin-Scan
        s.FileNo
        s.State (t.Stack e.Scanned <Chr <Add-Digits <Mul-Digits s.D1 16> s.D2>>)
        s.T s.S e.Tail
      >;

  s.FileNo
  Escape-Hex ((s.State t.Stack e.Scanned) e.Digits)
  s.T s.S s.Char e.Tail
    = <HexDigit s.Char>
    : {
        s.Digit
          = <Xxin-Scan
              s.FileNo
              Escape-Hex ((s.State t.Stack e.Scanned) e.Digits s.Digit)
              <Type e.Tail>
            >;

        /* empty */
          = <Sysfun-Xxin-ERROR 'Unknown escape sequence \\x' s.Char>;
      };

  s.FileNo
  Escape-Hex ((s.State t.Stack e.Scanned) e.Digits)
  'N' s.0 0
    = <Sysfun-Xxin-ERROR 'Unexpected EOF in \\x...'>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) 'N' s.0 0
    = <Sysfun-Xxin-ERROR 'Unexpected EOF in escape sequence'>;

  s.FileNo Escape ((s.State t.Stack e.Scanned)) s.T s.S s.Next e.Tail
    = <Sysfun-Xxin-ERROR 'Bad escape sequence \\' s.Next>;

  s.FileNo s.State (t.Stack e.Scanned) s.T s.S '\\' e.Tail
    = <Xxin-Scan s.FileNo Escape ((s.State t.Stack e.Scanned)) <Type e.Tail>>;

  s.FileNo General (t.Stack e.Scanned) s.T s.S '(' e.Tail
    = <Xxin-Scan
        s.FileNo General ((General t.Stack e.Scanned)) <Type e.Tail>
      >;

  s.FileNo General ((General t.Stack e.Scanned) e.Inner) s.T s.S ')' e.Tail
    = <Xxin-Scan s.FileNo General (t.Stack e.Scanned (e.Inner)) <Type e.Tail>>;

  s.FileNo General ('^' e.Scanned) s.T s.S ')' e.Tail
    = <Sysfun-Xxin-ERROR 'Unbalanced )'>;

  /* EXIT FROM RECURSION */
  s.FileNo General ('^' e.Scanned) 'N' s.0 0 = <Close s.FileNo> e.Scanned;

  s.FileNo General ((General t.Stack e.Scanned) e.Inner) 'N' s.0 0
    = <Sysfun-Xxin-ERROR 'Unbalanced ('>;

  s.FileNo General (t.Stack e.Scanned) s.S s.T '\'' e.Tail
    = <Xxin-Scan
        s.FileNo Quote ((General t.Stack e.Scanned) '\'') <Type e.Tail>
      >;

  s.FileNo General (t.Stack e.Scanned) s.S s.T '"' e.Tail
    = <Xxin-Scan
        s.FileNo Quote ((General t.Stack e.Scanned) '"') <Type e.Tail>
      >;

  s.FileNo
  Quote ((General t.Stack e.Scanned) s.Quote e.Quotten)
  s.S s.T s.Quote e.Tail
    = <Xxin-Scan
        s.FileNo
        General (t.Stack e.Scanned <Quote s.Quote e.Quotten>)
        <Type e.Tail>
      >;

  s.FileNo Quote ((General t.Stack e.Scanned) s.Quote e.Quotten) 'N' s.0 0
    = <Sysfun-Xxin-ERROR 'Unexpected EOF in ' s.Quote '...'>;

  s.FileNo General (t.Stack e.Scanned) 'L' s.S s.Letter e.Tail
    = <Xxin-Scan
        s.FileNo Word ((General t.Stack e.Scanned) s.Letter) <Type e.Tail>
      >;

  s.FileNo Word (t.Stack e.Scanned) 'L' s.S s.Letter e.Tail
    = <Xxin-Scan s.FileNo Word (t.Stack e.Scanned s.Letter) <Type e.Tail>>;

  s.FileNo Word (t.Stack e.Scanned) 'D' s.0 s.Digit e.Tail
    = <Xxin-Scan s.FileNo Word (t.Stack e.Scanned s.Digit) <Type e.Tail>>;

  s.FileNo Word (t.Stack e.Scanned) s.T s.S '-' e.Tail
    = <Xxin-Scan s.FileNo Word (t.Stack e.Scanned '-') <Type e.Tail>>;

  s.FileNo Word (t.Stack e.Scanned) s.T s.S '_' e.Tail
    = <Xxin-Scan s.FileNo Word (t.Stack e.Scanned '_') <Type e.Tail>>;

  s.FileNo Word ((General t.Stack e.Scanned) e.Word) s.T s.S ' ' e.Tail
    = <Xxin-Scan
        s.FileNo General (t.Stack e.Scanned <Implode_Ext e.Word>) <Type e.Tail>
      >;

  s.FileNo Word (t.Stack e.Scanned) 'N' s.0 0 /* EOF */
    = <Sysfun-Xxin-ERROR 'Unexpected EOF while reading word'>;

  s.FileNo Word (t.Stack e.Scanned) s.T s.S s.Other e.Tail
    = <Sysfun-Xxin-ERROR 'Unexpected "' s.Other '" while reading word'>;

  s.FileNo General (t.Stack e.Scanned) 'D' s.0 s.Digit e.Tail
    = <Xxin-Scan
        s.FileNo Number ((General t.Stack e.Scanned) s.Digit) <Type e.Tail>
      >;

  s.FileNo Number (t.Stack e.Scanned) 'D' s.0 s.Digit e.Tail
    = <Xxin-Scan s.FileNo Number (t.Stack e.Scanned s.Digit) <Type e.Tail>>;

  s.FileNo Number ((General t.Stack e.Scanned) e.Number) s.T s.S ' ' e.Tail
    = <Numb-Aux e.Number>
    : {
        s.OneMacroDigit
          = <Xxin-Scan
              s.FileNo
              General (t.Stack e.Scanned s.OneMacroDigit)
              <Type e.Tail>
            >;

        e.SeveralMacrodigits
          = <Sysfun-Xxin-ERROR 'Very long macrodigit is read'>;
      };

  s.FileNo Number (t.Stack e.Scanned) 'N' s.0 0 /* EOF */
    = <Sysfun-Xxin-ERROR 'Unexpected EOF while reading macrodigit'>;

  s.FileNo Number (t.Stack e.Scanned) s.T s.S s.Other e.Tail
    = <Sysfun-Xxin-ERROR 'Unexpected "' s.Other '" while reading macrodigit'>;

  s.FileNo General (t.Stack e.Scanned) s.T s.S ' ' e.Tail
    = <Xxin-Scan s.FileNo General (t.Stack e.Scanned) <Type e.Tail>>;

  s.FileNo s.State (t.Stack e.Scanned) s.T s.S s.Other e.Tail
    = <Xxin-Scan s.FileNo s.State (t.Stack e.Scanned s.Other) <Type e.Tail>>;
}

HexDigit {
  '0' = 0;  '1' = 1;  '2' = 2;  '3' = 3;  '4' = 4;
  '5' = 5;  '6' = 6;  '7' = 7;  '8' = 8;  '9' = 9;

  'A' = 10; 'B' = 11; 'C' = 12; 'D' = 13; 'E' = 14; 'F' = 15;
  'a' = 10; 'b' = 11; 'c' = 12; 'd' = 13; 'e' = 14; 'f' = 15;

  s.Other = /* empty */;
}

$ENUM Sysfun-Xxin-ERROR;

Quote {
  '\'' e.Text = e.Text;
  '"' e.Text = <Implode_Ext e.Text>;
}

Sysfun-Xxout {
  e.FileName (s.Width e.Expression)
    = <Xxout-Wrap
        <Open-Auto 'w' e.FileName> s.Width
        <Xxout-Scan <Type e.Expression>>
      >;
}

Xxout-Wrap {
  s.FileNo s.Width e.Text
    = <First s.Width e.Text>
    : {
        (e.Line) /* empty */ = <Write-Aux s.FileNo e.Line> <Close s.FileNo>;

        (e.Line) e.Rest
          = <Putout-Aux s.FileNo e.Line>
            <Xxout-Wrap s.FileNo s.Width e.Rest>;
      };
}

Xxout-Scan {
  'L' s.S s.Letter e.Tail
    = <Xxout-Chars () 'L' s.S s.Letter e.Tail> : (e.Chars) s.T s.S^ e.Tail^
    = '\'' e.Chars '\'' <Xxout-Scan s.T s.S e.Tail>;

  'D' s.0 s.Digit e.Tail
    = <Xxout-Chars () 'D' s.0 s.Digit e.Tail> : (e.Chars) s.T s.S e.Tail^
    = '\'' e.Chars '\'' <Xxout-Scan s.T s.S e.Tail>;

  'Wi' s.Word e.Tail = <Explode s.Word> ' ' <Xxout-Scan <Type e.Tail>>;

  'Wq' s.Compound e.Tail
    = <Xxout-Chars () <Type <Explode s.Compound>>> : (e.Chars) '*' s.0
    = '"' e.Chars '"' <Xxout-Scan <Type e.Tail>>;

  'N' s.0 s.Number e.Tail
    = <Symb-Digit s.Number> ' ' <Xxout-Scan <Type e.Tail>>;

  'P' s.S s.Printable e.Tail
    = <Xxout-Chars () 'P' s.S s.Printable e.Tail> : (e.Chars) s.T s.S^ e.Tail^
    = '\'' e.Chars '\'' <Xxout-Scan s.T s.S e.Tail>;

  'O' s.S s.Other e.Tail
    = <Xxout-Chars () 'O' s.S s.Other e.Tail> : (e.Chars) s.T s.S^ e.Tail^
    = '\'' e.Chars '\'' <Xxout-Scan s.T s.S e.Tail>;

  'B' s.0 (e.Inner) e.Tail
    = '(' <Xxout-Scan <Type e.Inner>> ')' <Xxout-Scan <Type e.Tail>>;

  '*' s.0 /* empty */ = /* empty */;
}

Xxout-Chars {
  (e.Scanned) s.T s.S s.Escaped e.Tail
    , ('\\\\') ('\'\'') ('""') ('((') ('))')
      ('<<') ('>>') ('\nn') ('\tt') ('\rr')
    : e.Escaped-B (s.Escaped e.Replace) e.Escaped-E
    = <Xxout-Chars (e.Scanned '\\' e.Replace) <Type e.Tail>>;

  (e.Scanned) 'L' s.S s.Letter e.Tail
    = <Xxout-Chars (e.Scanned s.Letter) <Type e.Tail>>;

  (e.Scanned) 'D' s.S s.Digit e.Tail
    = <Xxout-Chars (e.Scanned s.Digit) <Type e.Tail>>;

  (e.Scanned) 'W' s.S s.Word e.Tail = (e.Scanned) 'W' s.S s.Word e.Tail;

  (e.Scanned) 'N' s.0 s.Number e.Tail = (e.Scanned) 'N' s.0 s.Number e.Tail;

  (e.Scanned) 'P' s.S s.Printable e.Tail
    = <Xxout-Chars (e.Scanned s.Printable) <Type e.Tail>>;

  (e.Scanned) 'O' s.S s.Other e.Tail
    = <Divmod-Digits <Ord s.Other> 16> : (s.Hi) s.Low
    = <Xxout-Chars (e.Scanned '\\x' <Hex s.Hi> <Hex s.Low>) <Type e.Tail>>;

  (e.Scanned) 'B' s.0 (e.Inner) e.Tail = (e.Scanned) 'B' s.0 (e.Inner) e.Tail;

  (e.Scanned) '*' s.0 /* empty */ = (e.Scanned) '*' s.0 /* empty */;
}

Hex {
   0 = '0';  1 = '1';  2 = '2';  3 = '3';
   4 = '4';  5 = '5';  6 = '6';  7 = '7';
   8 = '8';  9 = '9'; 10 = 'A'; 11 = 'B';
  12 = 'C'; 13 = 'D'; 14 = 'E'; 15 = 'F';
}


/**
  45. Freeze — not implemented yet
*/
$EENUM Freeze;


/**
  46. Freezer — not implemented yet
*/
$EENUM Freezer;


/**
  47. Dn — not implemented yet
*/
$EENUM Dn;


/**
  51. <GetEnv e.EnvVar> == e.EnvValue
  e.EnvVar, e.EnvValue ::= s.CHAR*
*/
%%
namespace {

refalrts::FnResult string_from_seq(
  std::vector<char>& string, refalrts::Iter begin, refalrts::Iter end
) {
  std::vector<char> result;

  enum { cBufLen = 100 };
  char buffer[cBufLen + 1] = { 0 };

  unsigned read;
  while ((read = refalrts::read_chars(buffer, cBufLen, begin, end)) != 0) {
    // В текущей версии Open Watcom (и форка Open Watcom V2) есть ошибка
    // в функции vector::insert, которая возникает в случае,
    // если во время вставки вектор увеличивает свою ёмкость (capacity).
    // Для обхода этой ошибки предварительно резервируем место.
    result.reserve(result.size() + read + 1);
    result.insert(result.end(), buffer, buffer + read);
  }

  /*
    Здесь refalrts::empty_seq(begin, end) || (begin->tag != cDataChar).
  */

  if (refalrts::empty_seq(begin, end)) {
    result.push_back('\0');
    string.swap(result);
    return refalrts::cSuccess;
  } else {
    // здесь begin->tag != cDataChar
    return refalrts::cRecognitionImpossible;
  }
}

}  // unnamed namespace
%%

$ENTRY GetEnv {
%%
  refalrts::Iter envname_b = 0;
  refalrts::Iter envname_e = 0;
  refalrts::call_left(envname_b, envname_e, arg_begin, arg_end);

  std::vector<char> envname;
  refalrts::FnResult envname_res =
    string_from_seq(envname, envname_b, envname_e);

  if (envname_res != refalrts::cSuccess) {
    return envname_res;
  }

  refalrts::reset_allocator(vm);
  const char *envres = getenv(& envname[0]);

  if (envres != 0) {
    refalrts::Iter env_begin;
    refalrts::Iter env_end;

    refalrts::alloc_string(vm, env_begin, env_end, envres);
    refalrts::splice_evar(arg_begin, env_begin, env_end);
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  52. <System e.Command> == '-'? s.NUMBER
  e.Command ::= s.CHAR
*/
$ENTRY System {
%%
  refalrts::Iter command_b = 0;
  refalrts::Iter command_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(command_b, command_e, arg_begin, arg_end);

  std::vector<char> command;
  refalrts::FnResult command_res =
    string_from_seq(command, command_b, command_e);

  if (command_res != refalrts::cSuccess) {
    return command_res;
  }

  fflush(stdout);
  fflush(stderr);

  int ret = refalrts::api::system(&command[0]);

  refalrts::reset_allocator(vm);
  if (ret < 0) {
    refalrts::Iter minus = 0;
    refalrts::alloc_char(vm, minus, '-');
    refalrts::splice_elem(arg_begin, minus);

    ret = -ret;
  }

  refalrts::reinit_number(arg_begin, ret);

  refalrts::splice_to_freelist(vm, pfunc_name, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  53. <Exit s.Sign? s.RetCode>
  no return
  s.Sign ::= '+' | '-'
  s.RetCode ::= s.MACRODIGIT
*/
$ENTRY Exit {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  int sign = +1;

  if (refalrts::char_left('+', content_b, content_e)) {
    sign = +1;
  } else if (refalrts::char_left('-', content_b, content_e)) {
    sign = -1;
  }

  refalrts::Iter pretcode = 0;
  if (
    ! refalrts::svar_left(pretcode, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
    || refalrts::cDataNumber != pretcode->tag
    || refalrts::dangerous_state(vm)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::set_return_code(vm, sign * static_cast<int>(pretcode->number_info));
  return refalrts::cExit;
%%
}


/**
  54. <Close s.FileNo> == []
  If file not opened function never does.
*/
$ENTRY Close {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;
  if (
    ! file_handle_left(identifiers, pfile_handle, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(vm, identifiers, pfile_handle);
  if (handle) {
    if (! release_file_handle(vm, pfile_handle)) {
      return refalrts::cRecognitionImpossible;
    }
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  55. <ExistFile e.FileName> == True | False
  e.FileName ::= s.CHAR*
*/
*$IDENT True, False

$ENTRY ExistFile {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  char filename[FILENAME_MAX + 1] = { '\0' };
  unsigned len =
    refalrts::read_chars(filename, FILENAME_MAX, content_b, content_e);

  if (! refalrts::empty_seq(content_b, content_e) || len == 0) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter ans = arg_begin;
  if (FILE *f = fopen(filename, "r")) {
    // Файл существует
    fclose(f);

    refalrts::reinit_ident(ans, USE_IDENT(True));
  } else {
    // Файл по-видимому не существует
    refalrts::reinit_ident(ans, USE_IDENT(False));
  }

  refalrts::splice_to_freelist(vm, pfunc_name, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  56. <GetCurrentDirectory> == s.CHAR*
*/
$ENTRY GetCurrentDirectory {
%%
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  char directory[FILENAME_MAX + 1] = { '\0' };

  if (! refalrts::api::get_current_directory(directory, sizeof(directory))) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter directory_b = 0, directory_e = 0;
  refalrts::alloc_string(vm, directory_b, directory_e, directory);
  refalrts::splice_evar(arg_begin, directory_b, directory_e);
  refalrts::splice_to_freelist(vm, arg_begin, arg_end);

  return refalrts::cSuccess;
%%
}


/**
  57. <RemoveFile e.FileName>
        == True ()
        == False (e.ErrorMessage)
      e.ErrorMessage ::= s.CHAR*
*/
$ENTRY RemoveFile {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter filename_b = content_b;
  refalrts::Iter filename_e = content_e;

  char filename[FILENAME_MAX + 1] = { '\0' };
  // возвращаемое значение не проверяем для совместимости с РЕФАЛом-5
  refalrts::read_chars(filename, FILENAME_MAX, filename_b, filename_e);

  const char *error_message = "";
  refalrts::RefalIdentifier i_result = USE_IDENT(False);

  if (! refalrts::empty_seq(filename_b, filename_e)) {
    error_message = "File name is too long.";
  } else {
    errno = 0;
    int result = remove(filename);

    if (result == 0) {
      i_result = USE_IDENT(True);
    } else {
      error_message = strerror(errno);
    }
  }

  refalrts::Iter error_b = 0, error_e = 0;
  refalrts::alloc_string(vm, error_b, error_e, error_message);
  refalrts::reinit_ident(arg_begin, i_result);
  refalrts::reinit_open_bracket(pfunc_name);
  refalrts::reinit_close_bracket(arg_end);
  refalrts::splice_evar(arg_end, error_b, error_e);
  refalrts::splice_to_freelist(vm, content_b, content_e);
  refalrts::link_brackets(pfunc_name, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  58. <Implode_Ext e.CHARS*> == s.COMPOUND
*/
$ENTRY Implode_Ext {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  std::vector<char> ident_str;
  refalrts::FnResult res = string_from_seq(ident_str, content_b, content_e);

  if (res != refalrts::cSuccess) {
    return res;
  }

  refalrts::RefalIdentifier ident = refalrts::ident_implode(vm, &ident_str[0]);

  if (! ident) {
    return refalrts::cIdentTableLimit;
  }

  refalrts::reinit_ident(arg_begin, ident);
  refalrts::splice_to_freelist(vm, pfunc_name, arg_end);

  return refalrts::cSuccess;
%%
}


/**
  59. <Explode_Ext s.COMPOUND> == s.CHAR*
*/
$ENTRY Explode_Ext {
  s.Compound = <__Step-Drop> <Explode s.Compound>;
}


/**
  60. <TimeElapsed e.Init> == s.CHAR-DIGIT* '.' s.CHAR-DIGIT*
*/
%%
namespace {

refalrts::GlobalRef<clock_t> g_time_elapsed_edge;

}  // unnamed namespace
%%

$ENTRY TimeElapsed {
%%
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  bool make_edge = refalrts::number_left(0, content_b, content_e) != 0;

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  const double fClocksPerSec = CLOCKS_PER_SEC;
  clock_t now = clock();
  double time_elapsed = (now - g_time_elapsed_edge.ref(vm)) / fClocksPerSec;

  char str_time_elapsed[
    DBL_MAX_10_EXP + 1 /* maximum digits before point */
    + 1 /* point */
    + 6 /* default digits after point for sprintf */
    + 1 /* last '\0' */
    + 10 /* just in case */
  ] = { '\0' };

  sprintf(str_time_elapsed, "%f", time_elapsed);

  refalrts::alloc_string(vm, content_b, content_e, str_time_elapsed);

  if (make_edge) {
    g_time_elapsed_edge.ref(vm) = now;
  }

  refalrts::splice_evar(arg_begin, content_b, content_e);
  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  61. <Compare t.FirstNumber e.SecondNumber> == '-' | '0' | '+'
*/
$ENTRY Compare {
  /* optimization for two digits */
  s.First s.Second = <__Step-Drop> <Compare-Digits s.First s.Second>;

  e.ArithmArg
    , <__Step-Start> <NormArithmArg e.ArithmArg> : (e.First) e.Second
    = <Compare-Normed (e.First) e.Second> <__Step-End>;
}

Compare-Normed {
  ('+' e.First) '+' e.Second = <Compare-Nat (e.First) e.Second>;
  ('+' e.First) '-' e.Second = '+';
  ('+' e.First) 0            = '+';
  ('-' e.First) '+' e.Second = '-';
  ('-' e.First) '-' e.Second = <Compare-Nat (e.Second) e.First>;
  ('-' e.First) 0            = '-';
  (0)           '+' e.Second = '-';
  (0)           '-' e.Second = '+';
  (0)           0            = '0';
}

Compare-Nat {
  (e.First) e.Second = <Compare-Align (() e.First) () e.Second>;
}

Compare-Align {
  ((e.First-L) s.First-Dig e.First-R) (e.Second-L) s.Second-Dig e.Second-R
    = <Compare-Align
        ((e.First-L s.First-Dig) e.First-R) (e.Second-L s.Second-Dig) e.Second-R
      >;

  ((e.First-L) s.First-Dig e.First-R) (e.Second-L) /* empty */ = '+';
  ((e.First-L) /* empty */) (e.Second-L) s.Second-Dig e.Second-R = '-';

  ((s.First-Dig e.First)) (s.Second-Dig e.Second)
    = <Compare-ByDigits
        <Compare-Digits s.First-Dig s.Second-Dig> (e.First) e.Second
      >;
}

Compare-ByDigits {
  '0' (s.First-Dig e.First) s.Second-Dig e.Second
    = <Compare-ByDigits
        <Compare-Digits s.First-Dig s.Second-Dig> (e.First) e.Second
      >;

  '0' (/* empty */) /* empty */ = '0';

  s.Compare-Res (e.First) e.Second = s.Compare-Res;
}

Compare-Digits {
%%
  ARITHM_PRELUDE

  char res = first < second ? '-' : first > second ? '+' : '0';

  refalrts::reinit_char(arg_begin, res);
  refalrts::splice_to_freelist(vm, pFunc, arg_end);
  return refalrts::cSuccess;
%%
}


/**
      <DeSysfun e.FileName (s.Width e.ObjectExpression)> == []
*/
$ENTRY DeSysfun {
  e.FileName (s.Width e.ObjectExpression)
    = <__Step-Start>
      <Sysfun-Xxout e.FileName (s.Width e.ObjectExpression)>
      <__Step-End>;
}


/**
  63. XMLParse — not implemented yet
*/
$EENUM XMLParse;


/**
  64. <Random '+'? s.Length> == e.LongNumber
      s.Length ::= s.MACRODIGIT
      e.LongNumber ::= s.MACRODIGIT+
      |e.LongNumber| <= max(s.Length, 1)
*/
%%
namespace {

class RndGen {
  /*
    See D. E. Knuth, The Art of Computer Programming,
    Volume 2, chapter 3.2.2, program A
  */
public:
  typedef refalrts::RefalNumber UInt;

  enum {
    cMaxVal = ~(UInt(0)),
    cMinDelay = 24,
    cMaxDelay = 55,
  };

  RndGen();

  UInt next_value() {
    m_y[m_k] = m_y[m_k] + m_y[m_j];
    UInt result = m_y[m_k];
    m_k = (m_k + cMaxDelay - 1) % cMaxDelay;
    m_j = (m_j + cMaxDelay - 1) % cMaxDelay;
    return result;
  }

  UInt next_in_range(UInt max);

private:
  /*
    Variable names from Knuth.
  */
  int m_k;
  int m_j;
  UInt m_y[cMaxDelay];
};

RndGen::RndGen()
  : m_k(cMaxDelay - 1), m_j(cMinDelay - 1)
{
  UInt seed = static_cast<UInt>(time(NULL));

  for (size_t i = 0; i < cMaxDelay; ++i) {
    seed = seed * 1103515245 + 12345;
    m_y[i] = seed;
  }
}

RndGen::UInt RndGen::next_in_range(RndGen::UInt max) {
  if (0 == max) {
    return 0;
  } else if (cMaxVal == max) {
    return next_value();
  } else {
    ++max;

    const UInt cBucketSize = cMaxVal / max;
    const UInt cInvalid = cBucketSize * max;
    UInt val;

    do {
      val = next_value();
    } while(val > cInvalid);

    return val / cBucketSize;
  }
}

refalrts::GlobalRef<RndGen*> g_gen;

bool positive_digit_arg(
  refalrts::Iter& pfunc_name, refalrts::RefalNumber& value,
  refalrts::Iter arg_begin, refalrts::Iter arg_end
) {
  refalrts::Iter content_b = 0, content_e = 0;
  pfunc_name = refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  // don't check return value
  refalrts::char_left('+', content_b, content_e);

  refalrts::Iter pnumber = 0;
  if (
    refalrts::svar_left(pnumber, content_b, content_e)
    && refalrts::empty_seq(content_b, content_e)
    && refalrts::cDataNumber == pnumber->tag
  ) {
    value = pnumber->number_info;
    return true;
  } else {
    return false;
  }
}

}  // unnamed namespace
%%

$ENTRY Random {
%%
  refalrts::Iter pfunc_name = 0;
  refalrts::RefalNumber max = 0;

  if (! positive_digit_arg(pfunc_name, max, arg_begin, arg_end)) {
    return refalrts::cRecognitionImpossible;
  }

  max = g_gen.ref(vm)->next_in_range(max);

  if (0 == max) {
    max = 1;
  }

  refalrts::reset_allocator(vm);
  bool zero = true;
  for (size_t i = 0; i < static_cast<size_t>(max); ++i) {
    refalrts::RefalNumber digit = g_gen.ref(vm)->next_value();
    if (digit != 0 || ! zero) {
      zero = false;

      refalrts::Iter dummy = 0;
      refalrts::alloc_number(vm, dummy, digit);
    }
  }

  if (zero) {
    refalrts::Iter dummy = 0;
    refalrts::alloc_number(vm, dummy, 0);
  }

  refalrts::splice_from_freelist(vm, arg_begin);
  refalrts::splice_to_freelist(vm, arg_begin, arg_end);

  return refalrts::cSuccess;
%%
}


/**
  65. <RandomDigit '+'? s.Max> == s.RandomDigit
      s.Max, s.RandomDigit ::= s.MACRODIGIT
      s.RandomDigit <= s.Max
*/
$ENTRY RandomDigit {
%%
  refalrts::Iter pfunc_name = 0;
  refalrts::RefalNumber max = 0;

  if (! positive_digit_arg(pfunc_name, max, arg_begin, arg_end)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber digit = g_gen.ref(vm)->next_in_range(max);

  refalrts::reinit_number(arg_begin, digit);
  refalrts::splice_to_freelist(vm, pfunc_name, arg_end);

  return refalrts::cSuccess;
%%
}


/**
  66. <Write s.FileNo e.AnyExpression> == []
*/
$ENTRY Write {
  s.FileNo e.AnyExpression
    = <__Step-Start>
      <Autoopen 'w' s.FileNo>
      <Write-Aux <ZeroHandle s.FileNo stderr> e.AnyExpression>
      <__Step-End>;
}

Write-Aux {
%%
  return cookie_ns::fwrite_line(
    vm, identifiers, arg_begin, arg_end, cookie_ns::cFlags_NoEOL
  );
%%
}


/**
  67. <ListOfBuiltin> == (s.NUMBER s.COMPOUND { regular | special })*
*/
$ENTRY ListOfBuiltin {
  = (1 Mu special)
    (2 Add regular)
    (3 Arg regular)
    (4 Br regular)
    (5 Card regular)
    (6 Chr regular)
    (7 Cp regular)
    (8 Dg regular)
    (9 Dgall regular)
    (10 Div regular)
    (11 Divmod regular)
    (12 Explode regular)
    (13 First regular)
    (14 Get regular)
    (15 Implode regular)
    (16 Last regular)
    (17 Lenw regular)
    (18 Lower regular)
    (19 Mod regular)
    (20 Mul regular)
    (21 Numb regular)
    (22 Open regular)
    (23 Ord regular)
    (24 Print regular)
    (25 Prout regular)
    (26 Put regular)
    (27 Putout regular)
    (28 Rp regular)
    (29 Step regular)
    (30 Sub regular)
    (31 Symb regular)
    (32 Time regular)
    (33 Type regular)
    (34 Upper regular)
    (35 Sysfun regular)
    (45 Freeze regular)
    (46 Freezer regular)
    (47 Dn regular)
    (48 Up special)
    (49 Ev-met special)
    (50 Residue special)
    (51 GetEnv regular)
    (52 System regular)
    (53 Exit regular)
    (54 Close regular)
    (55 ExistFile regular)
    (56 GetCurrentDirectory regular)
    (57 RemoveFile regular)
    (58 Implode_Ext regular)
    (59 Explode_Ext regular)
    (60 TimeElapsed regular)
    (61 Compare regular)
    (62 DeSysfun regular)
    (63 XMLParse regular)
    (64 Random regular)
    (65 RandomDigit regular)
    (66 Write regular)
    (67 ListOfBuiltin regular)
    (68 SizeOf regular)
    (69 GetPID regular)
    (71 GetPPID regular);
}


/**
  68. <SizeOf s.C-Type> == s.Size-of-C-Type
     s.C-Type ::=
         'c' -- char
       | 's' -- short
       | 'i' -- int
       | 'l' -- long
       | 'p' -- char *
     s.Size-of-C-Type ::= s.NUMBER -- sizeof(type)
*/
$ENTRY SizeOf {
%%
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter ptype = 0;
  if (
    ! refalrts::svar_left(ptype, content_b, content_e)
    || refalrts::cDataChar != ptype->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber result;

  switch (ptype->char_info) {
    case 'c': result = sizeof(char); break;
    case 's': result = sizeof(short); break;
    case 'i': result = sizeof(int); break;
    case 'l': result = sizeof(long); break;
    case 'p': result = sizeof(char *); break;

    default:
      return refalrts::cRecognitionImpossible;
  }

  refalrts::reinit_number(arg_begin, result);
  refalrts::splice_to_freelist(vm, pfunc_name, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  69. <GetPID> == s.NUMBER
*/
%%
namespace cookie_ns {

refalrts::FnResult return_pid(
  refalrts::VM *vm,
  refalrts::RefalNumber pid, refalrts::Iter arg_begin, refalrts::Iter arg_end
);

}  // namespace cookie_ns
%%

$ENTRY GetPID {
%%
  return cookie_ns::return_pid(
    vm, refalrts::api::get_pid(), arg_begin, arg_end
  );
%%
}

%%
refalrts::FnResult cookie_ns::return_pid(
  refalrts::VM *vm,
  refalrts::RefalNumber pid, refalrts::Iter arg_begin, refalrts::Iter arg_end
) {
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reinit_number(arg_begin, pid);
  refalrts::splice_to_freelist(vm, pfunc_name, arg_end);
  return refalrts::cSuccess;
}
%%


/**
  71. <GetPPID> == s.NUMBER
*/
$ENTRY GetPPID {
%%
  return cookie_ns::return_pid(
    vm, refalrts::api::get_ppid(), arg_begin, arg_end
  );
%%
}



*-------------------------------------------------------------------------------
*  Стандартные функции Простого Рефала
*-------------------------------------------------------------------------------


* Ввод-вывод

/**
  <Open-Auto t.Mode e.FileName> == s.FileNo
  t.Mode ::=
      'r' | 'w' | 'a'
    | 'R' | 'W' | 'A'
    | s.COMPOUND | (s.CHAR*)
*/
$ENTRY Open-Auto {
  t.Mode s.FileNameChar e.FileName
    = <GetFreeHandle> : s.FreeHandle
    = <Open t.Mode s.FreeHandle s.FileNameChar e.FileName>
      s.FreeHandle;
}


/*
  <GetFreeHandle> == s.FileNo
  Function fails if free handle is not found.
*/
GetFreeHandle {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber free_file = 1;
  while (free_file < cMaxFileHandles && g_file_handles.ref(vm, free_file) != 0) {
    ++free_file;
  }

  if (free_file == cMaxFileHandles) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reinit_number(arg_begin, free_file);
  refalrts::splice_to_freelist(vm, pfunc_name, arg_end);
  return refalrts::cSuccess;
%%
}


* Работа с типами символов

/*
  <Symb-Digit s.MACRODIGIT> == s.DIGIT-CHAR+
*/
Symb-Digit {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter number = 0;
  if (
    ! refalrts::svar_left(number, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
    || refalrts::cDataNumber != number->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator(vm);
  refalrts::Iter begin_splice = arg_begin;

  if (refalrts::RefalNumber num = number->number_info) {
    // Длина десятичного числа = 0,3 * длина двоичного числа,
    // т.к. lg(2) = 0,3. Хрен с ним, что много. Главное, что не мало.
    enum { cMaxNumberLen = 8 * sizeof(refalrts::RefalNumber) * 3 / 10 + 2 };

    char buffer[cMaxNumberLen + 1] = { 0 };
    char *lim_digit = buffer + cMaxNumberLen;
    char *cur_digit = lim_digit;

    while (num != 0) {
      -- cur_digit;
      *cur_digit = static_cast<char>((num % 10) + '0');
      num /= 10;
    }

    refalrts::Iter num_begin;
    refalrts::Iter num_end;
    refalrts::alloc_chars(
      vm, num_begin, num_end, cur_digit, unsigned(lim_digit - cur_digit)
    );

    refalrts::splice_evar(arg_begin, num_begin, num_end);
  } else {
    refalrts::reinit_char(arg_begin, '0');
    begin_splice = pfunc_name;
  }

  refalrts::splice_to_freelist(vm, begin_splice, arg_end);

  return refalrts::cSuccess;
%%
}


/**
  <SymbCompare s.Left s.Right> == '<' | '=' | '>'
*/
%%
namespace cookie_ns {

bool compare(refalrts::Iter left, refalrts::Iter right);

} // namespace cookie_ns
%%

$ENTRY SymbCompare {
%%
  refalrts::Iter pX = 0, pY = 0;
  refalrts::Iter pFunc = refalrts::call_left(pX, pY, arg_begin, arg_end);

  if (pX->next != pY) {
    return refalrts::cRecognitionImpossible;
  }

  if (! cookie_ns::compare(pX, pY)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(vm, arg_begin, pFunc);
  refalrts::splice_to_freelist(vm, pY, arg_end);
  return refalrts::cSuccess;
%%
}

%%
namespace cookie_ns {

template <typename T>
char compare_char(T x, T y) {
  if (x < y) {
    return '<';
  } else if (x == y) {
    return '=';
  } else {
    return '>';
  }
}

char strcmp_char(const char *x, const char *y) {
  int res = strcmp(x, y);
  if (res < 0) {
    return '<';
  } else if (res > 0) {
    return '>';
  } else {
    return '=';
  }
}

} // namespace cookie_ns

bool cookie_ns::compare(refalrts::Iter left, refalrts::Iter right) {
  int rank[refalrts::cData_COUNT] = { 0 };

  rank[refalrts::cDataNumber] = 5;
  rank[refalrts::cDataChar] = 4;
  rank[refalrts::cDataFunction] = 3;
  rank[refalrts::cDataIdentifier] = 2;
  rank[refalrts::cDataFile] = 1;

  if (! rank[left->tag] || ! rank[right->tag]) {
    return false;
  }

  char order;

  if (rank[left->tag] > rank[right->tag]) {
    order = '>';
  } else if (rank[left->tag] < rank[right->tag]) {
    order = '<';
  } else {
    assert(left->tag == right->tag);

    switch(left->tag) {
      case refalrts::cDataNumber:
        order = compare_char(left->number_info, right->number_info);
        break;

      case refalrts::cDataChar:
        order = compare_char(left->char_info, right->char_info);
        break;

      case refalrts::cDataFunction:
        {
          refalrts::RefalFunction *fl = left->function_info;
          refalrts::RefalFunction *fr = right->function_info;

          const refalrts::RefalFuncName *fln = refalrts::function_name(fl);
          const refalrts::RefalFuncName *frn = refalrts::function_name(fr);

          order = strcmp_char(fln->name, frn->name);
          if (order == '=') {
            order = compare_char(fln->cookie1, frn->cookie1);
          }
          if (order == '=') {
            order = compare_char(fln->cookie2, frn->cookie2);
          }
          if (order == '=') {
            order = compare_char(fl, fr);
          }
        }
        break;

      case refalrts::cDataIdentifier:
        order =
          strcmp_char(left->ident_info->name(), right->ident_info->name());
        break;

      case refalrts::cDataFile:
        order = compare_char(left->file_info, right->file_info);
        break;

      default:
        refalrts_switch_default_violation(left->tag);
        assert(false);  // предупреждение компилятора
    }
  }

  refalrts::reinit_char(left, order);
  return true;
}
%%


* Двоичный ввод-вывод

/**
  <WriteBytes s.FileNo s.Byte*> == []
  s.Byte ::= s.MACRODIGIT | s.CHAR
*/
$ENTRY WriteBytes {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;

  if (! file_handle_left(identifiers, pfile_handle, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(vm, identifiers, pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  int fputc_return = 0;

  while (fputc_return != EOF && ! refalrts::empty_seq(content_b, content_e)) {
    switch (content_b->tag) {
      case refalrts::cDataChar:
        fputc_return = fputc(content_b->char_info, handle);
        break;

      case refalrts::cDataNumber:
        fputc_return = fputc(content_b->number_info & 0xFF, handle);
        break;

      default:
        return refalrts::cRecognitionImpossible;
    }

    refalrts::move_left(content_b, content_e);
  }

  if (fputc_return == EOF) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  <ReadBytes s.FileNo s.CountBytes> == e.ReadBytes

  s.CountBytes ::= s.MACRODIGIT
  e.ReadBytes ::= s.MACRODIGIT*

  |e.ReadBytes| <= s.CountBytes
*/
$ENTRY ReadBytes {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;
  refalrts::Iter pcount_bytes = 0;

  if (
    ! file_handle_left(identifiers, pfile_handle, content_b, content_e)
    || ! refalrts::svar_left(pcount_bytes, content_b, content_e)
    || refalrts::cDataNumber != pcount_bytes->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator(vm);

  FILE *handle = extract_file_handle(vm, identifiers, pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber count = pcount_bytes->number_info;

  refalrts::Iter begin = 0;
  refalrts::Iter end = 0;

  clearerr(handle);
  int cur_char = 0;
  while (count > 0 && (cur_char = getc(handle)) != EOF) {
    /*
      Пользуемся тем фактом, что в данной реализации размещёные в свободной
      памяти узлы располагаются в последовательных адресах.
    */
    refalrts::RefalNumber value = cur_char & 0xFFU;
    refalrts::alloc_number(vm, end, value);

    if (begin == 0) {
      begin = end;
    }
    --count;
  }

  if (begin == 0) assert (end == 0);
  if (begin != 0) assert (end != 0);

  if (cur_char == EOF && ferror(handle)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_evar(arg_begin, begin, end);
  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  <FTell s.FileNo> == s.MACRODIGIT
*/
$ENTRY FTell {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;

  if (
    ! file_handle_left(identifiers, pfile_handle, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(vm, identifiers, pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  long int pos = ftell(handle);

  if (pos == -1L) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reinit_number(arg_begin, static_cast<refalrts::RefalNumber>(pos));
  refalrts::splice_to_freelist(vm, pfunc_name, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  <FSeek s.FileNo s.Origin s.Sign s.Offset> == []

  s.Origin ::= CURRENT | BEGIN | END
  s.Sign ::= '+' | '-'
  s.Offset ::= s.MACRODIGIT
*/
*$IDENT CURRENT, BEGIN, END

$ENTRY FSeek {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;
  refalrts::Iter porigin = 0;
  refalrts::Iter psign = 0;
  refalrts::Iter poffset = 0;

  if (
    ! file_handle_left(identifiers, pfile_handle, content_b, content_e)
    || ! refalrts::svar_left(porigin, content_b, content_e)
    || refalrts::cDataIdentifier != porigin->tag
    || ! refalrts::svar_left(psign, content_b, content_e)
    || refalrts::cDataChar != psign->tag
    || ! refalrts::svar_left(poffset, content_b, content_e)
    || refalrts::cDataNumber != poffset->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(vm, identifiers, pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  int origin;
  if (USE_IDENT(BEGIN) == porigin->ident_info) {
    origin = SEEK_SET;
  } else if (USE_IDENT(CURRENT) == porigin->ident_info) {
    origin = SEEK_CUR;
  } else if (USE_IDENT(END) == porigin->ident_info) {
    origin = SEEK_END;
  } else {
    return refalrts::cRecognitionImpossible;
  }

  signed sign;
  if ('+' == psign->char_info) {
    sign = +1;
  } else if ('-' == psign->char_info) {
    sign = -1;
  } else {
    return refalrts::cRecognitionImpossible;
  }

  long int offset = sign * static_cast<long int>(poffset->number_info);

  if (fseek(handle, offset, origin) != 0) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  <RenameFile (e.Source) (e.Destination)> == True | False
*/
$ENTRY RenameFile {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter source_b = 0;
  refalrts::Iter source_e = 0;
  refalrts::Iter target_b = 0;
  refalrts::Iter target_e = 0;

  if (
    ! refalrts::brackets_left(source_b, source_e, content_b, content_e)
    || ! refalrts::brackets_left(target_b, target_e, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  char source[FILENAME_MAX + 1] = { '\0' };
  unsigned source_len =
    refalrts::read_chars(source, FILENAME_MAX, source_b, source_e);

  if (! refalrts::empty_seq(source_b, source_e) || source_len == 0) {
    return refalrts::cRecognitionImpossible;
  }

  char target[FILENAME_MAX + 1] = { '\0' };
  unsigned target_len =
    refalrts::read_chars(target, FILENAME_MAX, target_b, target_e);

  if (! refalrts::empty_seq(target_b, target_e) || target_len == 0) {
    return refalrts::cRecognitionImpossible;
  }

  int result = rename(source, target);

  refalrts::RefalIdentifier i_result =
    result == 0 ? USE_IDENT(True) : USE_IDENT(False);

  refalrts::reinit_ident(arg_begin, i_result);
  refalrts::splice_to_freelist(vm, pfunc_name, arg_end);
  return refalrts::cSuccess;
%%
}

/**
  <Module-Load e.ModuleName>
    == Success s.ModuleHandle
    == Fails e.Errors

  e.Errors ::= пусто
  TODO: поддержка сообщений об ошибках
*/
*$IDENT Success, Fails

$ENTRY Module-Load {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  char module_name[FILENAME_MAX + 1] = { '\0' };
  unsigned module_name_len =
    refalrts::read_chars(module_name, FILENAME_MAX, content_b, content_e);

  if (
    ! refalrts::empty_seq(content_b, content_e)
    || module_name_len == 0
    || refalrts::dangerous_state(vm)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::FnResult result;
  refalrts::RefalFunction *module =
    refalrts::load_module_rep(vm, arg_end, module_name, 0, 0, result);

  if (refalrts::cSuccess != result) {
    return result;
  }

  if (module != 0) {
    refalrts::Iter pSuccess = 0;
    refalrts::Iter pHandle = 0;

    refalrts::alloc_ident(vm, pSuccess, USE_IDENT(Success));
    refalrts::alloc_name(vm, pHandle, module);
    refalrts::splice_elem(arg_begin, pSuccess);
    refalrts::splice_elem(arg_begin, pHandle);
  } else {
    refalrts::Iter pFails = 0;
    refalrts::alloc_ident(vm, pFails, USE_IDENT(Fails));
    refalrts::splice_elem(arg_begin, pFails);
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

/**
  <Module-Unload s.ModuleHandle> == []
*/
$ENTRY Module-Unload {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pHandle = 0;
  if (
    ! refalrts::svar_right(pHandle, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
    || pHandle->tag != refalrts::cDataFunction
    || refalrts::dangerous_state(vm)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::FnResult result;
  bool success =
    refalrts::unload_module(vm, arg_end, pHandle->function_info, result);

  if (refalrts::cSuccess != result) {
    return result;
  }

  if (! success) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

/**
  <Module-Mu s.ModuleHandleEx e.Scope? t.Function e.Args>
    ≈≈ <t.Function e.Args>

  s.ModuleHandleEx ::= s.ModuleHandle | GLOBAL | CURRENT | CURRENT-AND-GLOBAL
  e.Scope ::= s.NUMBER s.NUMBER
  t.Function ::= s.FunctionName | (e.FunctionName)
  s.FunctionName ::= s.COMPOUND
  e.FunctionName ::= s.CHAR+
*/
*$IDENT GLOBAL, CURRENT, CURRENT-AND-GLOBAL

%%
namespace cookie_ns {

enum HandleExType {
  cHandleExType_Current,
  cHandleExType_Global,
  cHandleExType_CurrentAndGlobal,
  cHandleExType_Value,
};

bool module_handle_ex_left(
  const refalrts::RefalIdentifier *identifiers,
  HandleExType& type,
  refalrts::Iter& sModuleHandleEx,
  refalrts::Iter& content_b,
  refalrts::Iter& content_e
);

bool cookie_left(
  refalrts::UInt32& cookie1,
  refalrts::UInt32& cookie2,
  refalrts::Iter& content_b,
  refalrts::Iter& content_e
);

refalrts::RefalFunction *function_for_module(
  refalrts::VM *vm,
  HandleExType type,
  const char *func_name,
  refalrts::UInt32 cookie1,
  refalrts::UInt32 cookie2,
  refalrts::Iter sModuleHandleEx
);

}  // namespace cookie_ns
%%

$ENTRY Module-Mu {
%%
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  cookie_ns::HandleExType type = cookie_ns::cHandleExType_Value;
  refalrts::Iter sModuleHandleEx = 0;
  if (
    ! cookie_ns::module_handle_ex_left(
      identifiers, type, sModuleHandleEx, content_b, content_e
    )
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::UInt32 cookie1 = 0, cookie2 = 0;
  if (! cookie_ns::cookie_left(cookie1, cookie2, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  std::vector<char> func_name_vect;
  refalrts::Iter sFunctionName = 0;
  refalrts::Iter eFunctionName_b = 0, eFunctionName_e = 0;
  refalrts::Iter end_garbage;
  if (
    refalrts::svar_left(sFunctionName, content_b, content_e)
    && sFunctionName->tag == refalrts::cDataIdentifier
  ) {
    const char *func_name_cstr = sFunctionName->ident_info->name();
    size_t len = strlen(func_name_cstr);
    func_name_vect.assign(func_name_cstr, func_name_cstr + len + 1);
    end_garbage = sFunctionName;
  } else if (
    end_garbage = refalrts::brackets_left(
      eFunctionName_b, eFunctionName_e, content_b, content_e
    ),
    end_garbage != 0
  ) {
    refalrts::FnResult res = string_from_seq(
      func_name_vect, eFunctionName_b, eFunctionName_e
    );
    if (res != refalrts::cSuccess) {
      return res;
    }
    end_garbage = end_garbage->link_info;
  } else {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalFunction *result = cookie_ns::function_for_module(
    vm, type, &func_name_vect[0], cookie1, cookie2, sModuleHandleEx
  );

  if (! result) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::update_name(pfunc_name, result);
  refalrts::Iter begin_garbage = sModuleHandleEx;
  refalrts::splice_to_freelist(vm, begin_garbage, end_garbage);
  refalrts::push_stack(vm, arg_end);
  refalrts::push_stack(vm, arg_begin);
  return refalrts::cSuccess;
%%
}

%%
bool cookie_ns::module_handle_ex_left(
  const refalrts::RefalIdentifier *identifiers,
  cookie_ns::HandleExType& type,
  refalrts::Iter& sModuleHandleEx,
  refalrts::Iter& content_b,
  refalrts::Iter& content_e
) {
  if (
    ! refalrts::svar_left(sModuleHandleEx, content_b, content_e)
    && sModuleHandleEx->tag != refalrts::cDataFunction
    && ! refalrts::ident_term(USE_IDENT(GLOBAL), sModuleHandleEx)
    && ! refalrts::ident_term(USE_IDENT(CURRENT), sModuleHandleEx)
    && ! refalrts::ident_term(USE_IDENT(CURRENTm_ANDm_GLOBAL), sModuleHandleEx)
  ) {
    return false;
  }

  if (refalrts::ident_term(USE_IDENT(GLOBAL), sModuleHandleEx)) {
    type = cookie_ns::cHandleExType_Global;
  } else if (refalrts::ident_term(USE_IDENT(CURRENT), sModuleHandleEx)) {
    type = cookie_ns::cHandleExType_Current;
  } else if (
    refalrts::ident_term(USE_IDENT(CURRENTm_ANDm_GLOBAL), sModuleHandleEx)
  ) {
    type = cookie_ns::cHandleExType_CurrentAndGlobal;
  } else {
    type = cookie_ns::cHandleExType_Value;
  }

  return true;
}

bool cookie_ns::cookie_left(
  refalrts::UInt32& cookie1,
  refalrts::UInt32& cookie2,
  refalrts::Iter& content_b,
  refalrts::Iter& content_e
) {
  cookie1 = 0;
  cookie2 = 0;
  if (
    ! refalrts::empty_seq(content_b, content_e)
    && content_b->tag == refalrts::cDataNumber
  ) {
    refalrts::Iter sCookie1 = 0, sCookie2 = 0;
    if (
      refalrts::svar_left(sCookie1, content_b, content_e)
      && refalrts::svar_left(sCookie2, content_b, content_e)
      && sCookie2->tag == refalrts::cDataNumber
    ) {
      cookie1 = sCookie1->number_info;
      cookie2 = sCookie2->number_info;
    } else {
      return false;
    }
  }
  return true;
}

refalrts::RefalFunction *cookie_ns::function_for_module(
  refalrts::VM *vm,
  cookie_ns::HandleExType type,
  const char *func_name_cstr,
  refalrts::UInt32 cookie1,
  refalrts::UInt32 cookie2,
  refalrts::Iter sModuleHandleEx
) {
  const refalrts::RefalFuncName func_name(func_name_cstr, cookie1, cookie2);
  refalrts::Module *current = refalrts::current_module(vm);
  refalrts::RefalFunction *result = 0;

  switch (type) {
    case cookie_ns::cHandleExType_Global:
      result = refalrts::lookup_function_in_domain(vm, func_name);
      break;

    case cookie_ns::cHandleExType_Current:
      result = refalrts::lookup_function_in_module(vm, current, func_name);
      break;

    case cookie_ns::cHandleExType_CurrentAndGlobal:
      result = refalrts::lookup_function_in_module(vm, current, func_name);
      if (! result) {
        result = refalrts::lookup_function_in_domain(vm, func_name);
      }
      break;

    case cookie_ns::cHandleExType_Value:
      {
        refalrts::Module *module =
          refalrts::module_from_function_rep(vm, sModuleHandleEx->function_info);
        result = refalrts::lookup_function_in_module(vm, module, func_name);
      }
      break;

    default:
      refalrts_switch_default_violation(type);
  }

  return result;
}
%%

/**
  <Module-LookupFunction s.ModuleHandleEx e.Scope? e.Function>
    == Success s.FunctionPtr
    == Fails

  e.Function ::= s.COMPOUND | s.CHAR+
*/
%%
namespace cookie_ns {

refalrts::FnResult find_function(
  refalrts::VM *vm, const refalrts::RefalIdentifier *identifiers,
  refalrts::Iter arg_begin, refalrts::Iter arg_end,
  bool fail_down
);

}  // namespace cookie_ns
%%

$ENTRY Module-LookupFunction {
%%
  return cookie_ns::find_function(vm, identifiers, arg_begin, arg_end, false);
%%
}

%%

refalrts::FnResult cookie_ns::find_function(
  refalrts::VM *vm, const refalrts::RefalIdentifier *identifiers,
  refalrts::Iter arg_begin, refalrts::Iter arg_end,
  bool fail_down
) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  cookie_ns::HandleExType type = cookie_ns::cHandleExType_Value;
  refalrts::Iter sModuleHandleEx = 0;
  if (
    ! cookie_ns::module_handle_ex_left(
      identifiers, type, sModuleHandleEx, content_b, content_e
    )
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::UInt32 cookie1 = 0, cookie2 = 0;
  if (! cookie_ns::cookie_left(cookie1, cookie2, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  std::vector<char> func_name_vect;
  refalrts::Iter sFunctionName = 0;
  if (content_b->tag == refalrts::cDataIdentifier) {
    refalrts::svar_left(sFunctionName, content_b, content_e);
    const char *func_name_cstr = sFunctionName->ident_info->name();
    size_t len = strlen(func_name_cstr);
    func_name_vect.assign(func_name_cstr, func_name_cstr + len + 1);
  } else {
    refalrts::FnResult res =
      string_from_seq(func_name_vect, content_b, content_e);
    if (res != refalrts::cSuccess) {
      return res;
    }
  }

  refalrts::RefalFunction *result = cookie_ns::function_for_module(
    vm, type, &func_name_vect[0], cookie1, cookie2, sModuleHandleEx
  );

  if (result != 0) {
    if (fail_down) {
      refalrts::reinit_name(arg_begin, result);
      refalrts::splice_to_freelist(vm, pfunc_name, arg_end);
    } else {
      refalrts::reinit_ident(arg_begin, USE_IDENT(Success));
      refalrts::update_name(pfunc_name, result);
      refalrts::splice_to_freelist(vm, sModuleHandleEx, arg_end);
    }
  } else {
    if (fail_down) {
      return refalrts::cRecognitionImpossible;
    } else {
      refalrts::reinit_ident(arg_begin, USE_IDENT(Fails));
      refalrts::splice_to_freelist(vm, pfunc_name, arg_end);
    }
  }

  return refalrts::cSuccess;
}
%%

/**
  <Module-FunctionPtr s.ModuleHandleEx e.Scope? e.Function>
    == s.FunctionPtr
    fail donw if not found
*/
$ENTRY Module-FunctionPtr {
%%
  return cookie_ns::find_function(vm, identifiers, arg_begin, arg_end, true);
%%
}


/**
  <Platform> == Windows | POSIX
*/
$ENTRY Platform {
%%
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalIdentifier platform =
    refalrts::ident_implode(vm, refalrts::api::platform);

  if (! platform) {
    return refalrts::cIdentTableLimit;
  }

  refalrts::reinit_ident(arg_begin, platform);
  refalrts::splice_to_freelist(vm, pfunc_name, arg_end);

  return refalrts::cSuccess;
%%
}


/*
  <DirectorySeparators> == s.CHAR+
*/
DirectorySeparators {
%%
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator(vm);
  refalrts::alloc_string(
    vm, content_b, content_e, refalrts::api::directory_separators
  );
  refalrts::splice_evar(arg_begin, content_b, content_e);
  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}


/**
  <DirectorySeparator> == s.CHAR
*/
$ENTRY DirectorySeparator {
  = <DirectorySeparators> : s.Default e.Other = s.Default;
}


/**
  <IsDirectorySeparator s.CHAR> == True | False
*/
$ENTRY IsDirectorySeparator {
  s.Char
    , <DirectorySeparators>
    : {
        e.Separators-B s.Char e.Separators-E = True;
        e.Separators = False;
      }
}


/**
  <PathSeparator> == s.CHAR
*/
$ENTRY PathSeparator {
%%
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reinit_char(arg_begin, refalrts::api::path_env_separator);
  refalrts::splice_to_freelist(vm, pfunc_name, arg_end);

  return refalrts::cSuccess;
%%
}


__INIT {
%%
  // 1. Дескрипторы файлов
  for (size_t i = 0; i < cMaxFileHandles; ++i) {
    g_file_handles.ref(vm, i) = 0;      // на всякий случай
  }

  // 2. Точный счётчик шагов
  const unsigned long init_and_go_steps = 2;
  cookie_ns::g_correction.ref(vm) = cookie_ns::raw_step(vm) + init_and_go_steps;
  cookie_ns::g_start_step.ref(vm) = 0;

  // 3. Время запуска программы для TimeElapsed
  g_time_elapsed_edge.ref(vm) = clock();

  // 4. Генератор случайных чисел
  g_gen.ref(vm) = new RndGen();

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}

__FINAL {
%%
  // 4. Генератор случайных чисел
  delete g_gen.ref(vm);
  g_gen.ref(vm) = 0;

  // 3. Время запуска программы для TimeElapsed
  //   (нет финализации)

  // 2. Точный счётчик шагов
  //   (нет финализации)

  // 1. Дескрипторы файлов
  for (size_t i = 0; i < cMaxFileHandles; ++i) {
    if (g_file_handles.ref(vm, i) != 0) {
      fclose(g_file_handles.ref(vm, i));
      g_file_handles.ref(vm, i) = 0;    // на всякий случай
    }
  }

  refalrts::splice_to_freelist(vm, arg_begin, arg_end);
  return refalrts::cSuccess;
%%
}
